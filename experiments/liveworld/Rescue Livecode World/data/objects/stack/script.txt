--> Metadata
-
name: Rescue Livecode World
type: stack
author: David Bovill
copyright: David Bovill
deps: model_Project


/*
There are currently 5 active globals in use by the LiveCode environment.
These are:

-  gHkeyArray
-  gLibrarySetArray
-  gPrefs_Array
- gTemp_ActiveMenuArray

gHkeyArray is broken down into:

-  Global Menus = an array of all Global Menus linked to a numerically linked array of menu items, and the ruggedID of the menu_Controller 
-  behaviorArray = an array of objects with behaviors linked to metadata about that object
-  handlerArray = also known as hArray - a huge array of all handlers linked to every object they occur in with metadata such as hash and lineNums in script.
-  keywordArray = keyword automatically extracted from (library handlers) referencing the last object they were exported from
-  objectType = an automatically cahced index of objects tagged using the uRIP metadata convention on script compile
-  scriptArray = metadata about an objects script (without information about depndency calls)

gLibrarySetArray is broken down to data and metadata:

-  data         = front, back, used arrays and information like whether to add the ide_AddBehaviorHacks
- metadata  = the library set name

gOPN at the moment contains just the active library_SetName
gPrefs_Array contains things like paths to command line tools
gTemp_ActiveMenuArray is a global that contains infromation useful to the functioning of the last or current menu being used

These should probably be rationalised into one for clarity, and ease of removal.
Let's call the new array we move over to:  gLiveCodeWorld
But that is for later...
*/


--> Currently Working On | Project | Stack Files
-

/*
The handlers have an exact equivalent with regard to "library" handlers.

The aim is to move over from one huge library, to individual projects.
Each project would have it's own "home" stack, where we store stackfiles to all the stacks it needs to know about.
Associated with this home stack we can use the standardised technique of logging metadata,
where we can store arbitrary information.

In this way the metadata of the projects home stack contains all the information we need about the project.

For now let's keep using the old "library" rather than "project" based model for stackFiles.
By this I mean we continue to store set array in the global library rather than in a folder associated with the project.
The first stage of teh transition is to see if multiple home stacks with stackfiles works well.
See also "meta_StackArrayFile" for project level stackfile storage
*/


--> Project | Home
-
[[ _FetchHandler (project_HomeStack,g) ]]

[[ _FetchHandler (project_GuessHomeStack,c) ]]


--> Fix Things
-
[[ _FetchHandler (project_FixUsed,c) ]]

[[ _FetchHandler (fix_CardBehaviors,c) ]]


--> Rescue
-
[[ _FetchHandler (rescue_Me,c) ]]

[[ _FetchHandler (_importantView,f) ]]


--> Stackfiles | Known
-
[[ _FetchHandler (known_Stackfiles,g) ]]

[[ _FetchHandler (known_StackfileArray,g) ]]

[[ _FetchHandler (know_Me,c) ]]

[[ _FetchHandler (know_Everything,c) ]]

[[ _FetchHandler (known_ListRelativeStackFiles,f) ]]

[[ _FetchHandler (known_GetStackFileArray,f) ]]

[[ _FetchHandler (ide_StripRevStackPaths,c) ]]

[[ _FetchHandler (spotlight_ListAllStacks,f) ]]


--> Project | Deps | To Sort
-
--> Environment | Start
-
/*
Here we start basic things that all projects need.
*/

[[ _FetchHandler (environment_Start,c) ]]

[[ _FetchHandler (bash_AddSystemPathsToPATH,c) ]]

[[ _FetchHandler (stack_CheckStackMetadata,f) ]]

[[ _FetchHandler (global_Load,c) ]]

[[ _FetchHandler (ide_AddBehaviorHacks,c) ]]


--> Deps | hArray
-
[[ _FetchHandler (hArray_GetNamedObjectType,f) ]]

[[ _FetchHandler (hArray_GetObjectTypeArray,f) ]]

[[ _FetchHandler (hArray_GetObjectTypeData,f) ]]

[[ _FetchHandler (hArray_GetUripArray,f) ]]

[[ _FetchHandler (hArray_GetObjectArray,f) ]]


/*
--> Deps | Script Editor
-
function scriptEditor_GetBehaviorButton bName   
   put hArray_GetNamedObjectType (bName, "behavior") into behaviorButton
   return behaviorButton
end scriptEditor_GetBehaviorButton

function rev_LaunchDocsButton pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (btn "LaunchDocs" of group "Documentation" of cd "Main" of editorStack) is false then return empty
   put the long id of btn "LaunchDocs" of group "Documentation" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_LaunchDocsButton

function rev_ScriptEditorStack pEditorNum
   switch
      case pEditorNum is empty
         return rev_TopScriptEditor()
      case pEditorNum = 0
         put the long id of stack "revSETemplate" of stack "revNewScriptEditor" into stackObject
         return revRuggedID (stackObject)
      case pEditorNum is a number
         put "revNewScriptEditor" && pEditorNum into stackName
         if exists (stack stackName) is false then return empty
         return the name stack stackName
      default
         return rev_TopScriptEditor()
   end switch
end rev_ScriptEditorStack

function rev_TopScriptEditor
   put the stack_Name of the target into stackName
   if word 1 of stackName is "revNewScriptEditor" then
      return the long id of stack stackName
   else 
      put the openstacks into stackNames
      filter stackNames with "revNewScriptEditor*"
      if stackNames is empty then return empty
      put line 1 of stackNames into stackName
      if exists(stack stackName) is false then
         put the stack_Name of the target into stackName
      end if
      return the long id of stack stackName
   end if
end rev_TopScriptEditor

function rev_OpenScriptEditorNames
   put the openstacks into stackNames
   -- filter stackNames with "revscripteditor *" -- old version ???
   filter stackNames with "revNewScriptEditor *"
   return stackNames
end rev_OpenScriptEditorNames

function rev_ScriptEditorField pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (fld "Script" of group "Editor" of cd "Main" of editorStack) is false then return empty
   put the long id of fld "Script" of group "Editor" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_ScriptEditorField

function rev_HistoryButton pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (btn "history" of group "Script Tabs" of cd "Main" of editorStack) is false then return empty
   put the long id of btn "history" of group "Script Tabs" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_HistoryButton

function rev_HandlerTreeField pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (field "handlers" of group "Left Bar" of cd "Main" of editorStack) is false then return empty
   put the long id of field "handlers" of group "Left Bar" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_HandlerTreeField

function rev_SimpleFindField pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (btn "history" of group "Script Tabs" of cd "Main" of editorStack) is false then return empty
   put the long id of fld "find" of group "Interactive Find" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_SimpleFindField

function rev_CompileButton pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (btn "compile" of group "Toolbar" of cd "Main" of editorStack) is false then return empty
   put the long id of btn "compile" of group "Toolbar" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_CompileButton

function rev_ScriptEditorDocField pEditorNum
   put rev_ScriptEditorStack (pEditorNum) into editorStack
   if exists (field "View" of group "Documentation" of cd "Main" of editorStack) is false then return empty
   put the long id of field "View" of group "Documentation" of cd "Main" of editorStack into someObject
   return revRuggedID (someObject)
end rev_ScriptEditorDocField


--> IDE | Behavios
-
function scriptEditor_HandlerListBehavior
   -- behavior_IdeHandlerListField
   if exists (stack "behavior_IdeHandlerListField") then
      put the name of stack "behavior_IdeHandlerListField" into someObject
   else
      -- this is the old way of doing things and is too fragile
      breakpoint
      put scriptEditor_GetBehaviorButton ("Livecode Handler List Field") into someObject
   end if
   if exists(someObject) is false then return empty
   return revRuggedID (someObject)
end scriptEditor_HandlerListBehavior

function scriptEditor_ScriptFieldBehavior
   if exists (stack "behavior_IdeScriptEditorField") then
      put the name of stack "behavior_IdeScriptEditorField" into bObject
      return bObject
   else
      put scriptEditor_GetBehaviorButton ("LiveCode Script Editor Field") into someObject
      if exists(someObject) is false then return empty
      return revRuggedID (someObject)
   end if
end scriptEditor_ScriptFieldBehavior

function scriptEditor_HistoryButtonBehavior
   if exists (stack "behavior_IdeRecentButton") then
      put the name of stack "behavior_IdeRecentButton" into bObject
      return bObject
   else
      -- this is the old way of doing things and is too fragile
      breakpoint
      put scriptEditor_GetBehaviorButton ("Livecode Script History Button") into bObject
      if exists(bObject) is false then return empty
      return revRuggedID (bObject)
   end if
end scriptEditor_HistoryButtonBehavior

function scriptEditor_FindFieldBehavior
   put scriptEditor_GetBehaviorButton ("Livecode Simple Find Field") into someObject
   if exists(someObject) is false then return empty
   return revRuggedID (someObject)
end scriptEditor_FindFieldBehavior

function scriptEditor_CompileButtonBehavior
   if exists (stack "behavior_IdeCompileButton") then
      put the name of stack "behavior_IdeCompileButton" into bObject
      return bObject
   else
      -- this is the old way of doing things and is too fragile
      breakpoint
      put the long id of control id 1014 of stack "View|Menu|Button" into compileButtonBehavior
      return revRuggedID (compileButtonBehavior)
   end if
end scriptEditor_CompileButtonBehavior

function scriptEditor_DocumentationFieldBehavior
   if exists (stack "behavior_IdeRecentButton") then
      put the name of stack "behavior_IdeFindField" into bObject
      return bObject
   else
      -- this is the old way of doing things and is too fragile
      breakpoint
      put scriptEditor_GetBehaviorButton ("LiveCode Script Documentation Field Behavior") into someObject
      if exists(someObject) is false then return empty
      return revRuggedID (someObject)
   end if
end scriptEditor_DocumentationFieldBehavior

function scriptEditor_LaunchDocsBehavior
   if exists (stack "behavior_IdeRecentButton") then
      put the name of stack "behavior_IdeFindField" into bObject
      return bObject
   else
      put scriptEditor_GetBehaviorButton ("LiveCode Launch Docs Button Behavior") into someObject
      if exists(someObject) is false then return empty
      return revRuggedID (someObject)
   end if
end scriptEditor_LaunchDocsBehavior
*/


--> Deps | OPN Notify
-
[[ _FetchHandler (opn_Notify,c) ]]

[[ _FetchHandler (osx_Notify,c) ]]


--> Deps | Text
-
[[ _FetchHandler (kwote,f) ]]

[[ _FetchHandler (text_AddTrailing,c) ]]

[[ _FetchHandler (version_IsEarlier,f) ]]

[[ _FetchHandler (_convertVersionToNumber,f) ]]

[[ _FetchHandler (text_Merge,f) ]]


--> Deps | Files
-
[[ _FetchHandler (file_FromRelativeRoot,f) ]]

[[ _FetchHandler (file_GetRelativePath,f) ]]

[[ _FetchHandler (folder_Above,f) ]]

[[ _FetchHandler (folder_CreateNested,c) ]]

[[ _FetchHandler (folder_Format,c) ]]


--> Deps | Stack
-
[[ _FetchHandler (stack_Name,g) ]]

[[ _FetchHandler (stack_Object,g) ]]


--> Deps | Stackfiles
-
[[ _FetchHandler (stackfile_Paths,g) ]]

[[ _FetchHandler (stackfile_Paths,s) ]]

[[ _FetchHandler (stackFile_ExtraPaths,s) ]]

[[ _FetchHandler (stackfile_Array,g) ]]

[[ _FetchHandler (stackfile_Array,s) ]]

[[ _FetchHandler (stackFile_ToArray,f) ]]

[[ _FetchHandler (stackFile_FromArray,f) ]]

[[ _FetchHandler (stackFile_AddToArray,c) ]]

[[ _FetchHandler (stackFile_TableFromPaths,f) ]]

[[ _FetchHandler (stackFile_AddStackPaths,c) ]]

[[ _FetchHandler (stackFile_ConstructFileIndex,f) ]]


--> Deps | Array
-
[[ _FetchHandler (array_Fetch,f) ]]

[[ _FetchHandler (array_Save,c) ]]


--> Old or needs sorting
-
--> Library | Model | gOPN_LibrarySets
-
/*
This is old and should be removed.

Information about "sets" are stored in an array named after an old global variable "gOPN_LibrarySets"
It is a light-weight array. The heavy duty stuff is linked to, but stored in another model.

A set is simple a named collection of things to use and set up in an evnironment.
In particular stacks to use, back and front scripts,
but also things like preferences.

It's being used every day, but is an evolvign data structure.
A set should becoem what we need to define a project.
*/

[[ _FetchHandler (library_Sets,s) ]]

[[ _FetchHandler (library_ListSetNames,f) ]]

[[ _FetchHandler (library_StoreSetNames,c) ]]

[[ _FetchHandler (library_RemoveSetNamesFromStore,c) ]]

[[ _FetchHandler (library_FetchSetArray,f) ]]

[[ _FetchHandler (library_StoreSetArray,c) ]]

[[ _FetchHandler (library_FetchSetData,f) ]]

[[ _FetchHandler (library_StoreSetData,c) ]]


--> Project | Prefs | To Sort
-
[[ _FetchHandler (library_CheckEssentialPrefs,c) ]]

[[ _FetchHandler (project_ReloadCheckoutGlobals,c) ]]

--> Project | Checkout Globals
-
[[ _FetchHandler (project_StoreCheckoutGlobals,c) ]]

[[ _FetchHandler (library_ConstructCheckoutArray,f) ]]

[[ _FetchHandler (library_StoreCheckoutGlobal,c) ]]

[[ _FetchHandler (library_FetchCheckoutGlobal,f) ]]
