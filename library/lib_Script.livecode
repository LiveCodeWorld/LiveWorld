script "lib_Script"
--> MetaData
-
license: GPLv3
name: lib_Script
type: script library
version: 0.1

/*
A library for script analysis and processing.
*/


--> Currently Working On
-
--> Script | Object File Properteis
-
/*
These utility propoerties allow you to fetch script metadata related files of an object..
*/

getprop script_File [pDontCreate]
   put pDontCreate is not false into pDontCreate
   put the object_Folder [pDontCreate] of the target into objectFolder
   put objectFolder & "script.txt" into someFile
   return someFile
end script_File

getprop script_RelativeFile
   put the script_File of the target into scriptFile
   put git_GetRootFolder() into baseFolder
   file_SetRelativePath scriptFile, baseFolder
   return scriptFile
end script_RelativeFile

getprop script_Files
   put the long id of the target into scriptObject
   put the object_MetaDataFolder [true] of scriptObject into metadataFolder
   put folder_ShortFiles (metadataFolder) into someFiles
   return someFiles
end script_Files

getprop script_HelpFile [pDontCreate]
   put the long id of the target into scriptObject
   put the object_MetaDataFolder [pDontCreate] of scriptObject into metadataFolder
   put metadataFolder & "help.html" into someFile
   return someFile
end script_HelpFile

getprop script_OverlayFile [pDontCreate]
   put the long id of the target into scriptObject
   put the overlay_Folder [pDontCreate] of scriptObject into overlayFolder
   
   -- put overlayFolder & "overlaydata.array" into someFile
   put overlay_ArrayFile (overlayFolder) into someFile
   return someFile
end script_OverlayFile

getprop script_DotFile [pOverlayName]
   put the long id of the target into scriptObject
   put scriptObject_DotFile (scriptObject, pOverlayName) into scriptArrayFolder
   return scriptArrayFolder
end script_DotFile

getprop script_CmapFile [pOverlayName]
   put the long id of the target into scriptObject
   put the object_MetaDataFolder [true] of scriptObject into scriptFolder
   
   scriptObject_NormalizeGraphName pOverlayName, scriptFolder
   put pOverlayName & ".cmapx" into shortFile
   put scriptFolder & shortFile into someFile
   return someFile
end script_CmapFile

getprop script_GraphImageFile [pOverlayName]
   put the long id of the target into scriptObject
   return scriptObject_ImageFile (scriptObject, pOverlayName)
end script_GraphImageFile

getprop script_ImageFiles
   put the script_Files of the target into somePngs
   filter somePngs with "*.png"
   return somePngs
end script_ImageFiles


--> Script | Object File Properteis
-
/*
These utility propoerties allow you to fetch script metadata related files of an object..
*/

getprop script_File [pDontCreate]
   put pDontCreate is not false into pDontCreate
   put the object_Folder [pDontCreate] of the target into objectFolder
   put objectFolder & "script.txt" into someFile
   return someFile
end script_File

getprop script_RelativeFile
   put the script_File of the target into scriptFile
   put git_GetRootFolder() into baseFolder
   file_SetRelativePath scriptFile, baseFolder
   return scriptFile
end script_RelativeFile

getprop script_Files
   put the long id of the target into scriptObject
   put the object_MetaDataFolder [true] of scriptObject into metadataFolder
   put folder_ShortFiles (metadataFolder) into someFiles
   return someFiles
end script_Files

getprop script_HelpFile [pDontCreate]
   put the long id of the target into scriptObject
   put the object_MetaDataFolder [pDontCreate] of scriptObject into metadataFolder
   put metadataFolder & "help.html" into someFile
   return someFile
end script_HelpFile

getprop script_OverlayFile [pDontCreate]
   put the long id of the target into scriptObject
   put the overlay_Folder [pDontCreate] of scriptObject into overlayFolder
   
   -- put overlayFolder & "overlaydata.array" into someFile
   put overlay_ArrayFile (overlayFolder) into someFile
   return someFile
end script_OverlayFile

getprop script_DotFile [pOverlayName]
   put the long id of the target into scriptObject
   put scriptObject_DotFile (scriptObject, pOverlayName) into scriptArrayFolder
   return scriptArrayFolder
end script_DotFile

getprop script_CmapFile [pOverlayName]
   put the long id of the target into scriptObject
   put the object_MetaDataFolder [true] of scriptObject into scriptFolder
   
   scriptObject_NormalizeGraphName pOverlayName, scriptFolder
   put pOverlayName & ".cmapx" into shortFile
   put scriptFolder & shortFile into someFile
   return someFile
end script_CmapFile

getprop script_GraphImageFile [pOverlayName]
   put the long id of the target into scriptObject
   return scriptObject_ImageFile (scriptObject, pOverlayName)
end script_GraphImageFile

getprop script_ImageFiles
   put the script_Files of the target into somePngs
   filter somePngs with "*.png"
   return somePngs
end script_ImageFiles


--> Script | Props
-
getprop script_ContainsString [someString]
   put the long id of the target into targetObject
   try
      put the script of targetObject into someScript
      if someScript contains someString then
         return true
      else
         return false
      end if
   catch someError
      return false -- script may be protected
   end try
end script_ContainsString

getprop script_ContainsToken [someToken]
   put the long id of the target into targetObject
   try
      put the script of targetObject into someScript
      if someScript is empty then return false
      if someToken is among the tokens of someScript then
         return true
      else
         return false
      end if
   catch someError
      -- script may be protected
      return false
   end try
end script_ContainsToken

getprop script_Suite [suiteName]
    put the script of the target into someScript
    return script_GetSuite(suiteName, someScript)
end script_Suite

getprop object_ContainsMessageHandler [messageName]
   put the script_AndBehavior of the target into someScript
   return script_ContainsMessageHandler(someScript, messageName)
end object_ContainsMessageHandler

getprop script_OffestTable
   put the long id of the target into scriptObject
   put the script of scriptObject into someScript
   return script_GetOffsetTable(someScript, scriptObject)
end script_OffestTable

getprop script_MessageHandlers
   return the script_Events of the target
end script_MessageHandlers

getprop script_Events
   put the long id of the target into scriptObject
   put the script_AndBehavior of scriptObject into someScript
   put script_ExtractMessageHandlers(someScript, scriptObject) into scriptEvents
   return scriptEvents
end script_Events

getprop script_SetProp [handlerName]
   put the script of the target into someScript
   -- return script_ExtractSetPropHandlers(someScript)
   put script_GetSetProp (handlerName, someScript) into someHandlers
   return someHandlers
end script_SetProp

getprop script_GetProp [handlerName]
   put the script of the target into someScript
   put script_GetGetProp (handlerName, someScript) into someHandler
   -- return script_ExtractGetPropHandlers (someScript, scriptObject)
   return someHandler
end script_GetProp

getprop script_Command [cName]
   put the script of the target into someScript
   put script_GetCommand(cName, someScript) into commandHandler
   return commandHandler
end script_Command

getprop script_CommandHandlers
   put the long id of the target into scriptObject
   put the script of scriptObject into someScript
   return script_ExtractCommandHandlers(someScript, scriptObject)
end script_CommandHandlers

getprop script_CommandLines
   put the long id of the target into scriptObject
   put the script of scriptObject into someScript
   return script_ExtractCommandLines(someScript, scriptObject)
end script_CommandLines

getprop script_Function [fName]
   put the script of the target into someScript
   return script_GetFunction (fName, someScript)
end script_Function

getprop script_FunctionHandlers
   put the long id of the target into scriptObject
   put the script of scriptObject into someScript
   return script_ExtractFunctionHandlers (someScript, scriptObject)
end script_FunctionHandlers

getprop script_DuplicateKeys
   put the script_Array of the target into scriptArray
   repeat for each key indexNum in scriptArray
      put scriptArray [indexNum]["hKey"] into hKey
      if hKey is not empty then
         hkey_Deconstruct hKey, handlerName, hType, scriptObject, handlerNum
         if handlerNum > 1 then
            put hKey & CR after duplicateKeys
         end if
      end if
   end repeat
   delete char -1 of duplicateKeys
   return duplicateKeys
end script_DuplicateKeys

getprop script_DuplicateKeyArray
   put the script_Array of the target into scriptArray
   repeat for each key indexNum in scriptArray
      put scriptArray [indexNum] into handerArray
      put handerArray ["hKey"] into hKey
      if hKey is empty then
         put hKey & CR after uniqueKeys
      else
         hkey_Deconstruct hKey, handlerName, hType, scriptObject, handlerNum
         if handlerNum > 1 then
            put handerArray into duplicateArray [hKey]         
         end if
      end if
   end repeat
   delete char - 1 of uniqueKeys
   return duplicateArray
end script_DuplicateKeyArray

getprop script_BreakdownArray [pKeepSpacer]
   put the script_Array of the target into scriptArray
   return script_ConstructBreakDownArray (scriptArray)
end script_BreakdownArray


--> Currently Working On
-
function script_Contains someToken, someScript, pHandlerType
   switch char 1 of pHandlerType
      case "h"
         put script_ExtractHandler (someToken, someScript) into someHandler
         if someHandler is not empty then return true
         break
      case "c"
         put script_GetCommand (someToken, someScript) into someHandler
         if someHandler is not empty then return true
         break
      case "f"
         put script_GetFunction (someToken, someScript) into someHandler
         if someHandler is not empty then return true
         break
      case "g"
         put script_GetGetProp(someToken, someScript) into someHandler
         if someHandler is not empty then return true
         break
      case "s"
         put script_GetSetProp (someToken, someScript) into someHandler
         if someHandler is not empty then return true
         break
      default
         if someScript contains someToken then
            return true
         end if
   end switch
   return false
end script_Contains

function hkey_ExportStatus hKey, pHandlerScript
   put hkey_ExtractHandlerFromObject (hKey) into objectHandler
   if pHandlerScript is empty then
      put library_FetchHandler (hKey) into fileHandler
   else
      put script_ExtractHandler (hKey, pHandlerScript) into fileHandler
   end if
   
   switch
      case objectHandler = fileHandler
         return "ok"
      case objectHandler is not empty and fileHandler is not empty
         return "different"
      case fileHandler = empty
         return "no file"
      case objectHandler = empty
         return "no object script"
   end switch
end hkey_ExportStatus


--> Hkey | MetaData | Dot
-
function hKeyArray_ConstructNestedObjectDot hLinkArray, hIdArray, graphName, graphHeader, pTargetObject
   dot_EscapeQuotes graphName
   if graphName is empty then put "Test" into graphName
   
   put hKeyArray_DotNodeSubGraphDefs (hLinkArray, hIdArray, pTargetObject) into colourDefs
   
   put hKeyArray_DotNestedObjectClusters(hIdArray, hLinkArray) into clusterDefs
   put colourDefs & CR & CR & clusterDefs into defSection
   
   put hKeyArray_DotNodeLinks (hLinkArray, empty, pTargetObject) into linkSection
   if defSection is empty then
      put linkSection into nodeSection
   else
      put defSection & CR & CR & linkSection into nodeSection
   end if
   put dot_Construct(graphName, nodeSection, graphHeader) into dotText
   return dotText
end hKeyArray_ConstructNestedObjectDot


--> Script | Comments
-
function script_GetCommentAboveMe
   get line -2 of the executioncontexts
   put item -1 of it into lineNum
   -- put item -2 of it into hName
   put item 1 to -3 of it into scriptObject
   put the script of scriptObject into someScript
   
   -- test until we find a line with content
   repeat with testLineNum = (lineNum - 1) down to 1
      put word 1 to -1 of line testLineNum of someScript into scriptLine
      if scriptLine is not empty then exit repeat 
   end repeat
   if scriptLine is empty then return empty -- a blank script
   
   switch
      case char 1 to 2 of scriptLine = "--"
         delete char 1 to 2 of scriptLine
         return word 1 to -1 of scriptLine
      case char 1 of scriptLine = "#"
         repeat while char 1 of scriptLine = "#"
            delete char 1 ofscriptLine
         end repeat
         return word 1 to -1 of scriptLine
      case char -2 to -1 of scriptLine = "*/"
         -- a multiline comment
         put testLineNum into lastLineNum
         
         -- test until we find a line with content
         repeat with testLineNum = (lastLineNum - 1) down to 1
            put word 1 to -1 of line testLineNum of someScript into scriptLine
            if char 1 to 2 of scriptLine = "/*" then
               put testLineNum into startLineNum
               put line startLineNum to lastLineNum of someScript into multiComment
               put word 1 to -1 of multiComment into multiComment
               delete char 1 to 2 of multiComment
               delete char -2 to -1 of multiComment
               put word 1 to -1 of multiComment into multiComment
               
               repeat for each line cLine in multiComment
                  put word 1 to -1 of cLine & CR after cleanMultiComment
               end repeat
               delete char -1 of cleanMultiComment
               return cleanMultiComment
            end if
         end repeat
         return empty -- no start of comment ???
      default
         return empty -- not a comment
   end switch
end script_GetCommentAboveMe

function script_GetLineAboveMe
   get line -2 of the executioncontexts
   put item -1 of it into lineNum
   -- put item -2 of it into hName
   put item 1 to -3 of it into scriptObject
   
   put line (lineNum - 1) of the script of scriptObject into scriptLine
   return word 1 to -1 of scriptLine
end script_GetLineAboveMe

function script_CallingObject
   get the executioncontexts
   put item 1 of line -3 of it into callingObject
   return callingObject
end script_CallingObject


--> Script
-
command script_CreateAndEditHashCard someScript, pUniqueCardName
   if pUniqueCardName is empty then
      put text_Hash (someScript, "sha1") into pUniqueCardName
   end if
   script_CreateHashCard pUniqueCardName, someScript
   put the result into cardObject
   edit the script of cardObject
   return cardObject
end script_CreateAndEditHashCard

command script_CreateHashCard commitHash, someScript
   put "revTemporaryScriptCards" into stackName
   if exists (stack stackName) is false then
      put the tempname & ".livecode" into someFile
      create invisible stack stackName
      set the filename of stack stackName to someFile
   end if
   
   if exists (card commitHash of stack stackName) is false then
      put the defaultstack into oDefault
      set the defaultstack to stackName
      create card commitHash
      
      if someScript is not empty then
         set the script of card commitHash of stack stackName to someScript
      end if
      set the defaultstack to oDefault
   else
      set the script of card commitHash of stack stackName to someScript
   end if
   return the rugged_ID of card commitHash of stack stackName
end script_CreateHashCard


--> Script | Checks
-
function script_ConstructExportErrorArray someObjects
   repeat for each line someObject in someObjects
      try
         set the cursor to busy
         if exists (someObject) is false then next repeat
         try
            put the script of someObject into objectScript
         catch e
            next repeat -- must be a locked library
         end try
         
         put revRuggedID (someObject) into rObject
         --put the stack_Object of someObject into stackObject
         put token -1 of rObject into stackName
         if char 1 to 3 of stackName = "rev" then
            next repeat
         end if
         
         put the mobile_Name of someObject into mobileName
         put "Checking script of" && kwote (mobileName) into someTitle
         opn_Notify someTitle
         
         put the exported_Script of someObject into exportedScript
         switch
            case exportedScript is empty and objectScript is empty
               next repeat
            case exportedScript is empty and objectScript is not empty
               put empty into exportErrorArray ["Not Exported"][mobileName][rObject]
               break
            case objectScript is not exportedScript
               put empty into exportErrorArray ["Export Differs"][mobileName][rObject]
               break
         end switch
      catch e
         breakpoint
      end try
   end repeat
   return exportErrorArray
end script_ConstructExportErrorArray


--> Script | Duplicates
-
function script_ConstructBreakDownArray scriptArray
   repeat for each key indexNum in scriptArray
      put scriptArray [indexNum] into handerArray
      put handerArray ["hKey"] into hKey
      
      if pKeepSpacer is not true and hKey = "-,c" then next repeat
      
      if hKey is not empty then -- could be metadata etc
         hkey_Deconstruct hKey, handlerName, hType, scriptObject, handlerNum
         if handlerNum > 1 then
            put handerArray into duplicateArray [hKey]
         else
            put hKey & CR after uniqueKeys      
         end if
      end if
   end repeat
   delete char - 1 of uniqueKeys
   
   put uniqueKeys into breakdownArray ["uniqueKeys"]
   put duplicateArray into breakdownArray ["duplicateArray"]
   put scriptArray into breakdownArray ["scriptArray"]
   return breakdownArray
end script_ConstructBreakDownArray


--> Script | Comments
-
command script_ExtractAndStripMultiLineComments @someScript, @mulitLineComment
   put empty into mulitLineComment
   repeat
      script_MultiLineCommentOffsets someScript, startChar, endChar
      put the result into nextComment
      if nextComment is empty then
         exit repeat
      else
         put startChar,endChar & CR after commentOffsets
         delete char 1 to 2 of nextComment
         delete char -2 to -1 of nextComment
         put word 1 to -1 of nextComment into nextComment
         delete char startChar to (endChar + 1) of someScript   
         
         put nextComment & CR & CR after mulitLineComment
      end if
   end repeat
   delete char -1 of commentOffsets
   return commentOffsets
end script_ExtractAndStripMultiLineComments

command script_MultiLineCommentOffsets someScript, @startChar, @endChar
   text_SetOffsets "/*", "*/", someScript, startChar, endChar
   return the result
end script_MultiLineCommentOffsets

function script_StripComments someScript
   put someScript into testScript
   script_ExtractAndStripMultiLineComments testScript, mulitLineComment
   put text_TempReplaceQuoted(testScript, offsetArray) into testScript
   put text_Strip(testScript, "\", space) into testScript
   
   put "(--[^" & return & "]*)" & return into someReg
   put replacetext(testScript, someReg, return) into testScript -- more junk
   put "(#[^" & return & "]*)" & return into someReg
   put replacetext(testScript, someReg, return) into testScript
   
   put text_ReReplaceQuoted(testScript, offsetArray) into testScript
   return testScript
end script_StripComments

-- function script_StripComments someScript
put 0 into commentLineNum
repeat
   put lineStartsWith("--", someScript, false, commentLineNum) into commentLineNum
   if commentLineNum = 0 then
      return someScript
   else
      delete line commentLineNum of someScript
   end if
end repeat
end script_StripComments

function script_ExtractHandlerLines someScript, scriptObject
   -- best get rid of?
   -- replace "[" with " [ " in someScript	#  -- hack ???
   
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   return handlerArray ["handlerLines"]
end script_ExtractHandlerLines


--> Script | Command
-
function script_GetCommand cName, someScript, pNotPrivate
   local startHandler, endHandler
   if pNotPrivate is not true then
      script_SetPrivateHandlerOffsets startHandler, endHandler, cName, "on", someScript
      put the result into someHandler
      if someHandler is not empty then return someHandler
   end if
   
   script_SetHandlerOffsets startHandler, endHandler, cName, "on", someScript
   put the result into someHandler
   return someHandler
end script_GetCommand

function script_ExtractCommandHandlers someScript, scriptObject
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   return handlerArray ["command"]
end script_ExtractCommandHandlers


--> Script | Function
-
function script_GetFunction fName, someScript, pNotPrivate
   -- return script_ExtractHandler (fName, "function", someScript, notPrivate)
   local startHandler, endHandler
   if pNotPrivate is not true then
      script_SetPrivateHandlerOffsets startHandler, endHandler, fName, "function", someScript
      put the result into someHandler
      if someHandler is not empty then return someHandler
   end if
   
   script_SetHandlerOffsets startHandler, endHandler, fName, "function", someScript
   put the result into someHandler
   return someHandler
end script_GetFunction

function script_ExtractFunctionHandlers someScript, scriptObject
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   return handlerArray ["function"]
end script_ExtractFunctionHandlers


--> Script | Getprop
-
function script_GetGetProp propName, someScript, pNotPrivate
   local startHandler, endHandler
   if pNotPrivate is not true then
      script_SetPrivateHandlerOffsets startHandler, endHandler, propName, "getprop", someScript
      put the result into someHandler
      if someHandler is not empty then return someHandler
   end if
   
   script_SetHandlerOffsets startHandler, endHandler, propName, "getprop", someScript
   put the result into someHandler
   return someHandler
end script_GetGetProp

function script_ExtractGetPropHandlers someScript
   -- very important that this is fast for menus
   filter someScript with "getprop *"
   repeat for each line scriptLine in someScript
      put word 2 of scriptLine into handlerName
      put handlerName & CR after handlerNames
   end repeat
   delete char -1 of handlerNames
   return handlerNames
end script_ExtractGetPropHandlers

function script_SlowExtractGetPropHandlers someScript, scriptObject
   -- slower but talerant of white space
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   put handlerArray ["getprop"] into handlerNames
   put handlerNames
   return handlerNames
end script_SlowExtractGetPropHandlers


--> Script | Setprop
-
function script_GetSetProp propName, someScript, notPrivate
   local startHandler, endHandler
   if pNotPrivate is not true then
      script_SetPrivateHandlerOffsets startHandler, endHandler, propName, "setprop", someScript
      put the result into someHandler
      if someHandler is not empty then return someHandler
   end if
   
   script_SetHandlerOffsets startHandler, endHandler, propName, "setprop", someScript
   put the result into someHandler
   return someHandler
end script_GetSetProp

function script_ExtractSetPropHandlers someScript
   filter someScript with "setprop *"
   repeat for each line scriptLine in someScript
      put word 2 of scriptLine into handlerName
      put handlerName & CR after handlerNames
   end repeat
   delete char -1 of handlerNames
   return handlerNames
end script_ExtractSetPropHandlers

function script_SlowExtractSetPropHandlers someScript, scriptObject
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   put handlerArray ["setprop"] into handlerNames
   return handlerNames
end script_SlowExtractSetPropHandlers


--> Script | Events
-
function script_ExtractMessageHandlers someScript, scriptObject
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   return handlerArray ["message"]
end script_ExtractMessageHandlers


--> Script | Utilities
-
function script_GetOffsetTable someScript, scriptObject
   local scriptOffestTable
   -- put script_ExtractHandlerLines(someScript, scriptObject) into handlerLines
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   put handlerArray ["handlerLines"] into handlerLines
   repeat for each line handlerLine in handlerLines
      put word 1 of handlerLine into onWord
      put word 2 of handlerLine into handlerName
      script_SetHandlerOffsets startHandler, endHandler, handlerName, onWord, someScript
      put handler_GetType(handlerLine) into hType
      
      put handlerName,hType,startHandler,endHandler & CR after scriptOffestTable
   end repeat
   delete last char of scriptOffestTable
   return scriptOffestTable
end script_GetOffsetTable


--> Handler
-
function handler_GetType handlerLine
   if token 1 of handlerLine = "private" then
      delete token 1 of handlerLine
      put true into isPrivate
   end if
   
   switch token 1 of handlerLine
      case "on"
         put rev_MessageNames() into revMessageNames
         put token 2 of handlerLine into cName
         if cName is among the lines of revMessageNames then
            return _addPrivate ("m", isPrivate)    # message
         else
            return _addPrivate ("c", isPrivate)    # command
         end if
      case "command"
         return _addPrivate ("c", isPrivate)    # command
      case "function"
         return _addPrivate ("f", isPrivate)    # function
      case "getprop"
         return "g"	# getprop
      case "setprop"
         return "s"	# setprop
      default
         return empty
   end switch
end handler_GetType

private function _addPrivate hType, isPrivate
   if isPrivate is true then put "p" before hType
   return hType
end _addPrivate

function handler_ConvertType handlerType
   switch char 1 of word 1 of handlerType
      case "o"
         return "on"
      case "m"
         return "on"
      case "c"
         return "command"
      case "pc"
         return "private command"
      case "f"
         return "function"
      case "pf"
         return "private function"
      case "g"
         return "getprop"
      case "s"
         return "setprop"
      default
         return empty
   end switch
end handler_ConvertType


--> Script | Array | Offsets
-
command script_SetOffsetArrays someScript, @hKeyToOffsetArray, @offsetToCacheArray, scriptObject
   -- this hander is a real mess (slow and duplicates effort)
   -- as "script_ExtractHandlerLines" already parses every line (via "script_ConstructArraysFromScript")
   
   local handlerNumArray
   
   -- put the mobile_Name of scriptObject into scriptObject
   
   -- put script_ExtractHandlerLines(someScript) into handlerLines
   script_ConstructArraysFromScript someScript, handlerArray, uniqueArray, duplicateArray, scriptObject
   put handlerArray ["handlerLines"] into handlerLines
   
   repeat for each line handlerLine in handlerLines
      put word 1 of handlerLine into onWord
      put word 2 of handlerLine into handlerName
      script_SetHandlerOffsets startHandler, endHandler, handlerName, onWord, someScript
      put char 1 of handler_GetType(handlerLine) into hType
      
      put handlerNumArray [handlerName,hType] into lastHandlerNum
      put lastHandlerNum + 1 into handlerNum
      put hkey_Construct(handlerName, hType, scriptObject, handlerNum) into handlerKey
      put handlerNum into handlerNumArray [handlerName,hType]
      
      -- while we are at it cache the script?
      put char startHandler to endHandler of someScript into someHandler
      
      put someHandler into offsetToCacheArray [startHandler,endHandler]
      put startHandler,endHandler into hKeyToOffsetArray [handlerKey]
      put handlerKey & CR after handlerKeys
   end repeat
   
   -- "orderedHandlerKeys" allow "number" ie handler 2 or 3rd "getMe"
   delete last char of handlerKeys
   put handlerKeys into hKeyToOffsetArray ["orderedHandlerKeys"]
   return handlerKeys
end script_SetOffsetArrays

function script_ContainsMessageHandler someScript, messageName
   put "on" into onWord
   put "(?mi)^\s*(" & onWord & " +" & messageName & ")\W" after regExp
   return matchtext(someScript, regExp)
end script_ContainsMessageHandler

command script_SetPrivateHandlerOffsets @startHandler, @endHandler, handlerName, onWord, someScript
   local startH, endHandlerName, startEndHandlerLine, endH
   
   put word 1 of handlerName into handlerName
   text_EscapeRegularExpression handlerName  
   
   if onword is among the items of "command,on" then put "(command|on)" into onWord
   put "(?mi)^(private +" & onWord & " +" & handlerName & ")\W" into regExp
   
   put CR & someScript & CR into someScript
   if matchchunk (someScript, regExp, startHandler, endHandlerName, startEnd, endEnd) is true then
      put script_MatchEnd (handlerName, startHandler, someScript) into endHandler
      if endHandler is empty then
         put 0 into startHandler
         put 0 into endHandler
         return empty
      else
         -- because of CR insertion around someScript
         put char startHandler to endHandler of someScript into someHandler
         subtract 1 from startHandler
         subtract 1 from endHandler
         return someHandler
      end if
   else
      put 0 into startHandler
      put 0 into endHandler
      return empty
   end if
end script_SetPrivateHandlerOffsets

command script_SetHandlerOffsets @startHandler, @endHandler, handlerName, onWord, someScript
   local startH, endHandlerName, startEndHandlerLine, endH
   
   -- this will fail if the end has a space before it (can happen)
   -- put "(?mi)^(" & onWord & " +" & handlerName & ")\W" after regExp
   
   -- lets not distinguish between "command" and "on" as they are functinally equivalent
   if onword is among the items of "command,on" then put "(command|on)" into onWord
   
   put word 1 of handlerName into handlerName
   text_EscapeRegularExpression handlerName
   put "(?mi)^\s*(" & onWord & " +" & handlerName & ")\W" after regExp
   
   put CR & someScript & CR into someScript
   if matchchunk (someScript, regExp, startHandler, endHandlerName, startEnd, endEnd) is true then
      put script_MatchEnd (handlerName, startHandler, someScript) into endHandler
      if endHandler is empty then
         put 0 into startHandler
         put 0 into endHandler
         return empty
      else
         -- because of CR insertion around someScript
         put char startHandler to endHandler of someScript into someHandler
         subtract 1 from startHandler
         subtract 1 from endHandler
         return someHandler
      end if
   else
      put 0 into startHandler
      put 0 into endHandler
      return empty
   end if
end script_SetHandlerOffsets

function script_MatchEnd handlerName, startHandler, someScript
   put CR after someScript -- in case handler is at end
   put "(?mi)^\s*(" & "end" & " +" & handlerName & ")\W" into regExp
   
   -- this will fail if the end has a space before it (can happen)
   -- put "(?mi)^(" & "end" & " +" & handlerName & ")\W" into regExp
   
   delete char 1 to startHandler of someScript
   if matchchunk(someScript, regExp, startEndHandlerLine, endH) is true then
      put startHandler + endH - 0 into endHandler
      return endHandler
   else
      return empty
   end if
end script_MatchEnd

command text_EscapeRegularExpression @someString
   put "\" & tab & quote & "[]|*.?()" into specialChars
   repeat for each char specialChar in specialChars
      replace specialChar with "\" & specialChar in someString
   end repeat
end text_EscapeRegularExpression


--> Script | Arrays | Type
-
command handler_Deconstruct handlerLine, @handlerName, @hType, @privateBit
   if token 1 of handlerLine = "private" then
      put "p" into privateBit
      put token 3 of handlerLine into handlerName
   else
      put empty into privateBit
      put token 2 of handlerLine into handlerName
   end if
   put handler_GetType (handlerLine) into hType
end handler_Deconstruct

command script_ConstructArraysFromScript someScript, @handlerArray, @uniqueArray, @duplicateArray, scriptObject
   -- very slow as it loops through each line (use with care)
   
   local messageHandlers, commandHandlers, functionHandlers, setpropHandlers, getpropHandlers, orderedHandlers, errorHandlers, commandLines
   local handlerKeys, handlerName, hType, privateBit
   
   -- would be faster to do in repeat loop below
   local mulitLineComment
   script_ExtractAndStripMultiLineComments someScript, mulitLineComment
   
   put rev_MessageNames() into revMessageNames
   set the wholematches to true
   repeat for each line handlerLine in someScript
      if handlerLine is empty then next repeat
      handler_Deconstruct handlerLine, handlerName, hType, privateBit
      if handlerName = "_" then next repeat
      
      switch char 1 of hType
         case "f"
            put handlerName & CR after functionHandlers
            break
         case "g"
            put handlerName & CR after getpropHandlers
            break
         case "s"
            put handlerName & CR after setpropHandlers
            break
         case empty
            -- someJunk
            next repeat
         default -- (hType = "on" or hType = "command")
            if handlerName is among the lines of revMessageNames then
               put handlerName & CR after messageHandlers
            else
               put handlerName & CR after commandHandlers
               
               put handlerLine into commandLine
               delete token 1 of commandLine
               put commandLine & CR after commandLines
            end if
            break
      end switch
      
      put handlerLine & CR after handlerLines
      put handlerName & CR after orderedHandlers
      put char 1 of hType & privateBit into hType
      
      put handlerName & "," & hType into shortHKey
      put uniqueArray [shortHKey] into firstFoundObject
      
      if firstFoundObject is empty then
         put scriptObject into uniqueArray [shortHKey]
         put 1 into handlerNum
      else
         put duplicateArray [shortHKey] into duplicateIndex
         put the number of lines of duplicateIndex + 1 into handlerNum
         if handlerNum = 1 then
            put hkey_Construct (handlerName, hType, scriptObject, 1) & CR & hkey_Construct (handlerName, hType, scriptObject, 2) into duplicateIndex
         else
            put hkey_Construct (handlerName, hType, scriptObject, (handlerNum+1)) into duplicateKey
            line_Insert duplicateKey, duplicateIndex
         end if
         put duplicateIndex into duplicateArray [shortHKey]
      end if
      
      -- add last bit (new)
      if privateBit is not true then
         put hkey_Construct (handlerName, hType, scriptObject, handlerNum) into hKey
         put hKey & CR after notPrivateHkeys
      end if
      --
      if privateBit is empty then
         script_SetHandlerOffsets startHandler, endHandler, handlerName, onWord, someScript
      else
         script_SetPrivateHandlerOffsets startHandler, endHandler, handlerName, onWord, someScript
      end if
      put char startHandler to endHandler of someScript into someHandler
      put someHandler into handlerArray [hKey] -- this is a bit messy (better handlerArray ["handler"][hKey]
      -- put startHandler,endHandler into offsetArray [hKey]
   end repeat
   
   delete last char of handlerLines
   delete last char of commandLines
   delete last char of orderedHandlers
   
   delete last char of messageHandlers
   delete last char of commandHandlers
   delete last char of functionHandlers
   delete last char of getpropHandlers
   delete last char of setpropHandlers
   
   put handlerLines into handlerArray ["handlerLines"]
   put commandLines into handlerArray ["commandLines"]
   put orderedHandlers into handlerArray ["orderedHandlers"]
   
   put messageHandlers into handlerArray ["message"]
   put commandHandlers into handlerArray ["command"]
   put functionHandlers into handlerArray ["function"]
   put getpropHandlers into handlerArray ["getprop"]
   put setpropHandlers into handlerArray ["setprop"]
   
   delete last char of notPrivateHkeys
   return notPrivateHkeys
end script_ConstructArraysFromScript

command script_ExtendHkey @hKey, scriptObject, handlerNum
   if handlerNum is empty then put 1 into hKey
   hkey_Deconstruct hKey, handlerName, hType, scriptObject, handlerNum
   put hkey_Construct(handlerName, hType, scriptObject, handlerNum) into hKey
end script_ExtendHkey


--> Script | Construction
-
function script_ConstructCommand pigeon, hBody, pUseOn
   put tolower(char 1 of pigeon) into char 1 of pigeon
   
   set the itemdelimiter to "_"
   get item 2 of pigeon
   put toupper(char 1 of it) into char 1 of it
   put it into item 2 of pigeon
   
   if pUseOn is true then
      put "on" && pigeon into someHandler
   else
      put "command" && pigeon into someHandler
   end if
   put CR after someHandler
   repeat for each line scriptLine in hBody
      put "   " & scriptLine & CR after someHandler
   end repeat
   put "end" && word 1 of pigeon after someHandler
   return someHandler
end script_ConstructCommand

command script_DeconstructCommandLine handlerLine, @handlerName, @handlerPrefix, @handlerSuffix, @firstParam
   put token 1 of handlerLine into handlerName
   put token 2 of handlerLine into firstParam
   
   set the itemdelimiter to "_"
   put item 1 of handlerName into handlerPrefix
   put item 2 of handlerName into handlerSuffix
end script_DeconstructCommandLine

function script_ExtractSwitchSection someHandler, pSwitchOptions
   local startChar, endChar
   text_SetOffsets "  switch", "  end switch", someHandler, startChar, endChar, 0
   put the result into switchSection
   
   if pSwitchOptions is empty then return switchSection
   put word 2 of line 1 of switchSection into switchParam
   if switchParam is empty then return switchSection
   
   if switchParam is among the items of pSwitchOptions then
      return switchSection
   else
      return empty
   end if
end script_ExtractSwitchSection

function script_ExtractSetpropConditions someProp, viewBehaviorScript
   put script_GetSetProp (someProp, viewBehaviorScript) into propHandler
   if propHandler is empty then return empty
   
   script_DeconstructSetPropHandler propHandler, handlerName, setPropValue, setPropParam
   put setPropValue into pSwitchParams
   if setPropParam is not empty then put comma & setPropParam after pSwitchParams
   
   put script_ExtractCaseConditions (propHandler, pSwitchParams) into caseConditions
   sort caseConditions
   return caseConditions
end script_ExtractSetpropConditions

command script_DeconstructSetPropHandler propHandler, @handlerName, @setPropValue, @setPropParam
   get line 1 of propHandler
   put word 2 of it into handlerName
   put word -1 of it into setPropValue
   
   delete word 1 to 2 of it
   delete word -1 of it
   put token 2 of it into setPropParam
end script_DeconstructSetPropHandler

function script_ExtractCaseConditions someHandler, pSwitchParams
   -- should be renamed "handler_ExtractCaseConditions"
   put script_ExtractSwitchSection (someHandler, pSwitchParams) into caseSection
   if caseSection is empty then return empty
   
   filter caseSection with ("*case *")
   -- filter caseSection with ("*case" && quote & "*")
   put empty into caseConditions
   repeat for each line caseLine in caseSection
      if word 1 of caseLine is not among the items of "case,default" then next repeat
      get text_ExtractQuoted(caseLine)
      if it is not empty then put it & CR after caseConditions
   end repeat
   replace comma with CR in caseConditions
   
   /*
   -- optional second filter
   filter someHandler with ("*default *--")
   put text_ExtractQuoted(line -1 of someHandler) into defaultText
   if defaultText is not empty then put defaultText & CR after caseConditions
   */
   
   put word 1 to -1 of caseConditions into caseConditions
   return caseConditions
end script_ExtractCaseConditions


--> Script | Errors
-
function script_GetErrorDisplay
    global OPN
    return OPN ["Display Errors"]
end script_GetErrorDisplay

command script_SetErrorDisplay someBoolean
    global OPN
    put someBoolean into OPN ["Display Errors"]
end script_SetErrorDisplay


--> Script | Dictionary
-
function script_DocumentationTokens pIncludeTokenType
    if exists(stack "revGLX2 code") then
        put value("GetTokens()", stack "revGLX2 code")
    else if exists(stack "revGalaxy code") then -- ???
        return galaxy_DocumentationTokensOld()
    else
        return rev_DocumentationTokens()
    end if
end script_DocumentationTokens

function galaxy_DocumentationTokensOld
    -- from original galaxy function "glxGetTokens"
    global gDictionaryTerms, gDictionaryTermsWithTypes
     
    put empty into gDictionaryTermsWithTypes
    if length(gDictionaryTermsWithTypes) is 0 then
        put glx2GetDocsPath() into theDocsFolder
         
        put theDocsFolder & slash & "dict.index" into theDictFile
        put URL ("file:" & theDictFile) into theDictionaryIndex
        replace "&lt;" with "<" in theDictionaryIndex
        replace "&gt;" with ">" in theDictionaryIndex
         
        set the itemdel to tab
        repeat for each line theEntry in theDictionaryIndex
            put item 2 of theEntry into theToken
            put item 3 of theEntry into theType
             
            put 1 into gDictionaryTerms[theToken]
            put 1 into gDictionaryTermsWithTypes[theToken & tab & theType]
             
            if theType is "keyword" or theType is "object" then
                put item 5 of theEntry into theAbbrToken
                replace "    " with tab in theAbbrToken
                repeat for each item theWord in theAbbrToken
                    put word 1 to -1 of theWord into theWord
                    if theWord is not empty then
                        put 1 into gDictionaryTerms[theWord]
                        put 1 into gDictionaryTermsWithTypes[theWord & tab & theType]
                    end if
                end repeat
            end if
        end repeat
         
        put the keys of gDictionaryTerms into gDictionaryTerms
        sort gDictionaryTerms
         
        put the keys of gDictionaryTermsWithTypes into gDictionaryTermsWithTypes
        sort gDictionaryTermsWithTypes
    end if
     
    if pIncludeTokenType then
        return gDictionaryTermsWithTypes
    else
        return gDictionaryTerms
    end if
end galaxy_DocumentationTokensOld
