script "lib_Scrape"
--> MetaData
-
license: GPLv3
name: lib_Scrape
type: script library
version: 0.2


--> Scrape
-
function scrape_ContentSection someHtml
   -- this removes all html tags from the section
   put "//*[@id='content']" into someXPath
   put scrape_WithXPath (someHtml, someXPath, true) into contentSection
   return contentSection
end scrape_ContentSection
 
function scrape_ContentHeadings someHTML, pHeaderLevel
   put xpath_ConstructHeadingPath (pHeaderLevel, "content") into someXPath
   put scrape_WithXPath (someHtml, someXPath) into contentSection
   return contentSection
end scrape_ContentHeadings

function scrape_Headings someHTML, pHeaderLevel
   if pHeaderLevel is empty then put 3 into pHeaderLevel
   put xpath_ConstructHeadingPath (pHeaderLevel) into someXPath
   -- put format ("h%d", pHeaderLevel) into someXPath
   put scrape_WithXPath (someHtml, someXPath) into contentSection
   return contentSection
end scrape_Headings

function scrape_EvaluateContentHeadings someHTML, pHeaderLevel
   if pHeaderLevel is empty then put 3 into pHeaderLevel
   put format ("//*[@id='content']/h%d", pHeaderLevel) into someXPath

   put scrape_EvaluateXPath (someHtml, someXPath) into contentSection
   return contentSection
end scrape_EvaluateContentHeadings

function scrape_EvaluateXPath someHtml, someXPath, pTidyIsTrue
   if pTidyIsTrue then html_Tidy someHtml
   put revXMLCreateTree (someHTML, false, true, false) into treeID
   put revXMLEvaluateXPath (treeID, someXPath) into someContent
   revDeleteXMLTree treeID
   return someContent
end scrape_EvaluateXPath

function scrape_WithXPath someHtml, someXPath, pTidyIsTrue
   if pTidyIsTrue then html_Tidy someHtml
   put revXMLCreateTree (someHTML, false, true, false) into treeID
   put revXMLDataFromXPathQuery (treeID, someXPath) into someContent
   revDeleteXMLTree treeID
   return someContent
end scrape_WithXPath

function scrape_GetDiv someHtml, attributeName, attributeValue
   if pTidyIsTrue then html_Tidy someHtml
   put revXMLCreateTree (someHTML, false, true, false) into treeID
   put scrapeID_GetDiv (treeID, attributeName, attributeValue) into someContent
   revDeleteXMLTree treeID
   return someContent
end scrape_GetDiv


--> ScrapeID
-
function scrapeID_GetDiv treeID, pAttributeName, pAttributeValue
   put revXMLRootNode (treeID) into rootNode
   put revXMLMatchingNode (treeID, rootNode, "div", pAttributeName, pAttributeValue, -1, false) into someDiv
   return someDiv
end scrapeID_GetDiv

function scrapeID_GetContentSectionPath treeID
   put "//*[@id='content']" into someXPath
   put revXMLEvaluateXPath (treeID, someXPath) into contentSectionNode
   return line 1 of contentSectionNode
end scrapeID_GetContentSectionPath

function scrapeID_ConstructHeaderPageArray treeID
   put scrapeID_GetContentSectionPath (treeID) into contentSectionPath
   put revXMLNumberOfChildren (treeID, contentSectionPath, "", 1) into numberOfChildren -- for safety
   put revXMLFirstChild (treeID, contentSectionPath, false) into nextNode
   
   put 1 into headerNum
   put 0 into numKeyList
   set the itemdelimiter to "/"
   repeat numberOfChildren -- for safety
      put item -1 of nextNode into someLeaf
      put token 1 of someLeaf into headerNum
      delete char 1 of headerNum
      switch  
         case (char 1 of someLeaf = "h" and headerNum is a number)  
            put revXMLText (treeID, nextNode, true) into titleBit
            put revXMLNodeContents (treeID, nextNode) into headerTitle
            
            put scrape_TidyTitle (titleBit, headerTitle) into headerTitle
            
            scrape_IncrementNumKeyList numKeyList, headerNum
            put scrape_ConstructNumKeyArray (numKeyList, headerNum) into numKeyArray
            
            put headerTitle into headerPageArray [numKeyArray]["@attributes"]["title"]
            put headerNum into headerPageArray [numKeyArray]["@attributes"]["level"]
            
            -- now put content into previous headers numKeyArray
            if htmlArray is an array then
               put htmlArray into headerPageArray [previousNumKeyArray]["@content"]
               delete variable htmlArray
            end if
            
            put numKeyArray into previousNumKeyArray
            break
         default
            put revXMLText (treeID, nextNode, true) into htmlBit
            fedwiki_AddToEndOfIndexArray htmlBit, htmlArray
      end switch
      
      put revXMLNextSibling (treeID, nextNode, false) into nextNode
      if nextNode is empty then
         exit repeat
      end if
   end repeat
   
   if htmlArray is an array then
      -- if theri is only one title - theri may be some left here to add to the top title
      put htmlArray into headerPageArray [previousNumKeyArray]["@content"]
      delete variable htmlArray
   end if
   return headerPageArray
end scrapeID_ConstructHeaderPageArray

private function scrape_TidyTitle titleBit, headerTitle
   replace CR with empty in titleBit
   put replacetext (titleBit, "<[^><]*>","") into headerTitle
   return headerTitle
end scrape_TidyTitle

private command scrape_IncrementNumKeyList @numKeyList, headerNum
   put item headerNum of numKeyList into lastCount
   add 1 to lastCount
   put lastCount into item headerNum of numKeyList
   return lastCount
end scrape_IncrementNumKeyList

private function scrape_ConstructNumKeyArray numKeyList, headerNum
   repeat with itemNum =1 to headerNum
      if item itemNum of numKeyList is empty then
         put 1 into item itemNum of numKeyList
      end if
   end repeat
   
   put item 1 to headerNum of numKeyList into numKeyList
   split numKeyList by comma
   return numKeyList
end scrape_ConstructNumKeyArray


--> XPath
-
/*
Handlers that construct XPath queries
*/

function xpath_ConstructHeadingPath pHeaderLevel, pBelowAttributeID
   if pHeaderLevel is empty then put 3 into pHeaderLevel
   if pBelowAttributeID is empty then
      put format ("h%d", pHeaderLevel) into someXPath
   else
      put format ("//*[@id='%s']/h%d", pBelowAttributeID, pHeaderLevel) into someXPath
   end if
   return someXPath
end xpath_ConstructHeadingPath

