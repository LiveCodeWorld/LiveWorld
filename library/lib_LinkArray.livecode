script "lib_LinkArray"
--> MetaData
-
license: GPLv3
name: lib_LinkArray
type: script library
version: 0.1


--> Dot | MetaData | Array | Deps
-
function linkArray_ConstructDataArray linkArray, idLinkArray, idArray
   put linkArray into dataArray ["linkArray"]
   put idLinkArray into dataArray ["idLinkArray"]
   put idArray into dataArray ["idArray"]
   put array_ConstructReverseDictionary (idArray) into reversedIdArray
   put reversedIdArray into dataArray ["reverseIdArray"]
   return dataArray
end linkArray_ConstructDataArray

command linkArray_DeconstructDataArray dataArray, @linkArray, @idLinkArray, @idArray, @reversedIdArray
   -- same structure used by overlay_View (stored as local property)
   -- overlayArray = dataArray
   put dataArray ["linkArray"] into linkArray
   put dataArray ["idLinkArray"] into idLinkArray
   put dataArray ["idArray"] into idArray
   put dataArray ["reverseIdArray"] into reversedIdArray
end linkArray_DeconstructDataArray


--> LinkArray | Filter
-
function linkArray_ConstructObjectOutline hIdArray, hLinkArray
   if keys(hLinkArray) is not empty then put linkarray_FilterIdArray (hIdArray, hLinkArray) into hIdArray
   put hKeyArray_ConstructObjectIdArray(hIdArray) into objectIdArray
   put hKeyArray_ObjectOutline(hIdArray, hLinkArray) into objectOutline
   put object_ConstructPropertiesOutline (objectOutline, objectIdArray, hIdArray) into objectOutline
   return objectOutline
end linkArray_ConstructObjectOutline


--> LinkArray | Filter
-
function linkarray_HkeysFromIDs hIDs, hIdArray
   local hKeys
   repeat for each line hID in hIDs
      put hIdArray [hID] & CR after hKeys
   end repeat
   delete char -1 of hKeys
   return hKeys
end linkarray_HkeysFromIDs

function linkarray_FilterIdArray hIdArray, hLinkArray
   -- lets only get the bits of hIdArray that are actually in the link array
   put array_AllNodes (hLinkArray) into linkIds
   repeat for each line linkID in linkIds
      put hIdArray [linkID] into filteredArray [linkID]
   end repeat
   return filteredArray
end linkarray_FilterIdArray

command linkArray_RemoveSelfLinks @linkArray, pIsNested
   if pIsNested is empty then
      put linkArray_IsNested (linkArray) into pIsNested
   end if
   
   if pIsNested is not true then
      repeat for each key someKey in linkArray
         put linkArray [someKey] into someLinks
         line_Delete someKey, someLinks
         put someLinks into linkArray [someKey]
      end repeat
   else
      repeat for each key someKey in linkArray
         delete variable linkArray [someKey][someKey]
      end repeat
   end if
end linkArray_RemoveSelfLinks

function linkArray_IsNested linkArray
   put line 1 of keys (linkArray) into testKey
   put linkArray [testKey] is an array into isNested
   return isNested
end linkArray_IsNested

function linkArray_Reduce linkArray, minLinkNum
   -- updated to allow nested linkArray
   put array_Reverse (linkArray) into backArray
   repeat for each key someKeyWord in linkArray
      put linkArray [someKeyWord] into frontLinks
      if frontLinks is an array then put keys (frontLinks) into frontLinks
      put backArray [someKeyWord] into backLinks
      if backLinks is an array then put keys (backLinks) into backLinks
      
      if the number of lines of frontLinks > minLinkNum or the number of lines of backLinks > minLinkNum then
         put someKeyWord & CR after goodKeys
      end if
   end repeat
   delete char -1 of goodKeys
   
   repeat for each line goodKey in goodKeys
      put empty into goodFrontLinks
      put linkArray [goodKey] into testLinks
      if testLinks is an array then put keys (testLinks) into testLinks
      
      repeat for each line testLink in testLinks
         if testLink is among the lines of goodKeys then
            put testLink & CR after goodFrontLinks
         end if
      end repeat 
      delete char -1 of goodFrontLinks
      put goodFrontLinks into reducedArray [goodKey]
   end repeat
   return reducedArray
end linkArray_Reduce

function linkArray_ConstructSkipArray linkArray
   -- array_ConstructSkipArray, array_KeytokeyArray
   -- links keys to other keys via their links
   -- skipping a generation  fo links
   -- to create a key-to-key array
   put array_Reverse (linkArray) into backArray
   repeat for each key someKeyWord in linkArray
      put linkArray [someKeyWord] into idLinks
      repeat for each line idLink in idLinks
         put backArray [idLink] into nextKeyWords
         
         put keyToKeyArray [someKeyWord] into keyKeyLinks
         line_Add nextKeyWords, keyKeyLinks
         line_Delete someKeyWord, keyKeyLinks
         put keyKeyLinks into keyToKeyArray [someKeyWord]
         
         /*
         put keyToKeyArray [someKeyWord]["keyword links"] into keyKeyLinks
         line_Add nextKeyWords, keyKeyLinks
         line_Delete someKeyWord, keyKeyLinks
         put keyKeyLinks into keyToKeyArray [someKeyWord]["keyword links"]
         */
      end repeat
   end repeat
   return keyToKeyArray
end linkArray_ConstructSkipArray


--> LinkArray | Display
-

-- command display_LinkArray linkArray, pGraphPropertyArray, pDotPropertyArray, pImageView, pGraphController
local graphPropertyModel, pGraphSize, dotFile
linkArray_RedrawOverlayMap linkArray, dotFile, graphPropertyModel, pGraphController, pImageView, pGraphStyle, pGraphSize, pOverlayName
return pImageView

overlay_SetImage imageView, linkArray, idLinkArray, idArray, geometryArray, imageFile, dotFile, xdotFile, cmapFile 
return imageView

put view_GetTemplateObject ("View|Image|OPN Image") into pImageView
dot_DrawDependencyGraph hIdLinkArray, hIdArray, pImageView, pGraphController, dotFile, pGraphStyle, pGraphSize
object_GoTo pImageView

-- linkArray_DrawGraph linkArray, pImageView, pGraphController, pGraphStyle, pOverlayName
put the result into pImageView
return pImageView
end display_LinkArray


--> LinkArray | DotText
-
function linkArray_ConstructDot linkArray, pDotMetadataArray, pDefSection, pGraphController
   set the cursor to watch
   put pDotMetadataArray ["dot_HeaderArray"] into dotPropertyArray
   put pDotMetadataArray ["graph_PropertyArray"] into graphPropertyArray
   
   put graphPropertyArray ["overlay_Name"] into graphName
   if graphName is empty then put "linkArray_ConstructDot" into graphName
   put graphPropertyArray ["overlay_Size"] into graphSize
   put graphPropertyArray ["overlay_Style"] into graphStyle
   put graphPropertyArray ["overlay_UseInches"] into graphUseInches
   
   put dot_ConstructHeader (graphSize, dotPropertyArray, graphStyle, graphUseInches) into graphHeader
   
   put linkArray_DotNodeLinks (linkArray) into linkSection
   put linkArray_ConstructLinkSection (linkArray, pNodeTypeArray, pClusterArray, pGraphController) into nodeSection
   
   if pDefSection is empty then
      put linkSection into nodeSection
   else
      put pDefSection & CR & CR & linkSection into nodeSection
   end if
   put dot_Construct (graphName, nodeSection, graphHeader) into dotText
   return dotText
end linkArray_ConstructDot

function linkArray_ConstructLinkSection linkArray, pNodeTypeArray, pClusterArray, pGraphController
   -- all from arrays (with an optional script override in pGraphController)
   -- cloned from "hKeyArray_ConstructNodeSection", see also "hKeyArray_DotNestedObjectClusters"
   
   -- node defs
   if pNodeTypeArray is an array then put linkArray_ConstructDefSection (nodeTypeArray, pGraphController) into nodeDefs
   if pClusterArray is an array then put linkArray_ConstructClusterDefs (clusterArray, pGraphController) into clusterDefs  -- specific (construct object clusters)
   put nodeDefs & CR & CR & clusterDefs into defSection
   
   -- node links
   put linkArray_DotNodeLinks (linkArray) into linkSection
   if defSection is empty then
      return linkSection
   else
      return defSection & CR & CR & linkSection
   end if
end linkArray_ConstructLinkSection

function linkArray_ConstructClusterDefs clusterArray, pGraphController
   -- cloned from "hKeyArray_DotNestedObjectClusters"
   -- needs a recursive function to turn a nested array into a nested cluster def in dot
   
   return empty
   
   put array_ToXml 
   return clusterDefs
end linkArray_ConstructClusterDefs

command linkArray_RecurseClusters nodeID, nodeTypeArray, @clusterSection
   put nodeTypeArray [nodeID] into sectionArray
   -- put keys(
end linkArray_RecurseClusters


--> LinkArray | DotText | Node Links
-
function linkArray_DotNodeLinks linkArray, pNodeIDs
   if pNodeIDs is not empty then
      breakpoint -- not done
   end if
   
   -- this version uses nested array values
   repeat for each key someKey in linkArray
      put linkArray [someKey] into someLinkArray
      if the number of words of someKey > 1 then put kwote(someKey) into someKey
      
      if someLinkArray is an array then
         repeat for each key someLink in someLinkArray
            if the number of words of someLink > 1 then put kwote(someLink) into someLink
            put someKey && "->" && someLink & ";" & CR after linkSection
         end repeat
      else
         put someLinkArray into someLinks
         repeat for each line someLink in someLinks
            if the number of words of someLink > 1 then put kwote(someLink) into someLink
            put someKey && "->" && someLink & ";" & CR after linkSection
         end repeat
      end if
   end repeat
   delete char -1 of linkSection
   return linkSection
end linkArray_DotNodeLinks

function linkArray_DotNodeLinks linkArray, pNodeIDs
   -- without translating ids
   if pNodeIDs is empty then put keys(linkArray) into pNodeIDs
   repeat for each line someKey in pNodeIDs
      put linkArray [someKey] into someLinks
      repeat for each line someLink in someLinks
         put someKey && "->" && someLink & ";" & CR after linkSection
      end repeat
   end repeat
   delete char -1 of linkSection
   return linkSection
end linkArray_DotNodeLinks

function linkArray_NodeIdsToHkeys nodeIDs
   put the linkArray_Model of me into modelObject
   linkArray_Get modelObject, hLinkArray, hIdArray
   
   repeat for each line nodeID in nodeIDs
      put hIdArray [nodeID] into hKey
      put hKey & CR after hKeys
   end repeat
   delete char -1 of hKeys
   return hKeys
end linkArray_NodeIdsToHkeys


--> LinkArray | Recursion
-
command linkArray_DeleteNode @someArray, someKey, @alreadyDeleted
   local childKey,childKeys,otherLinkingNodes,reversedArray
   local testKey
   -- was "array_DeleteLinks"
   -- Treats an array as a place to store graphs.
   -- a recusive command
   
   -- do a recursion safety check to avoid infinite loops
   if someKey is among the lines of alreadyDeleted then return false
   put someKey & CR after alreadyDeleted
   
   -- delete the node someKey
   put someArray [someKey] into childKeys
   delete local someArray [someKey]
   
   --  delete any links to the deleted node from other nodes
   repeat for each key testKey in someArray
      array_DeleteFromIndex someKey, testKey, someArray
   end repeat
   
   -- delete any child nodes of the deleted node (chop the branch off)
   -- even if there are links from it
   -- but not if other nodes link to it
   put array_Reverse (someArray) into reversedArray
   
   repeat for each line childKey in childKeys
      -- lets work out what other nodes link TO the child
      put reversedArray [childKey] into otherLinkingNodes
      -- apart from someKey
      line_Delete someKey, otherLinkingNodes
      
      if otherLinkingNodes is empty then
         -- recursively delete node
         linkArray_DeleteNode someArray, childKey, alreadyDeleted
      end if
   end repeat
   return true
end linkArray_DeleteNode

function linkArray_ExtractTreeArray someKeys, linkArray
   repeat for each line someKey in someKeys
      linkArray_WalkKeys linkArray, someKey, subLinkArray
   end repeat
   return subLinkArray
end linkArray_ExtractTreeArray

command linkArray_WalkKeys linkArray, someKey, @subLinkArray
   if someKey is among the keys of subLinkArray then
      return empty -- lets not recurse!
   end if
   
   put linkArray [someKey] into subKeys
   put subKeys into subLinkArray [someKey]
   
   repeat for each line subKey in subKeys
      linkArray_WalkKeys linkArray, subKey, subLinkArray
   end repeat  
end linkArray_WalkKeys


--> LinkArray | Simple IDs
-
command linkArray_ConstructIdArray linkArray, @allKeys, @idArray, @backIdArray, @nodeIDs
   repeat for each key someKey in linkArray
      line_Add someKey, allKeys
      linkArray_ConstructSimpleKey someKey, idArray, backIdArray, true
      put linkArray [someKey] into someLinks
      line_Add someLinks, allKeys
      repeat for each line someLink in someLinks
         linkArray_ConstructSimpleKey someLink, idArray, backIdArray, true
      end repeat
   end repeat
   put keys(idArray) into nodeIDs
   sort numeric nodeIDs
   sort allKeys
   return nodeIDs
end linkArray_ConstructIdArray

command linkArray_IdConstruct linkArray, @nodeLinkArray, @nodeIdArray
   -- usefull to create simple arrays from complex data.
   -- that is it creates simple numbered nodes 1, 2 etc and stores references to these in arrays.
   local nodeBackArray
   repeat for each key someKey in linkArray
      put linkArray [someKey] into frontLinkArray
      linkArray_Add frontLinkArray, someKey, nodeLinkArray, nodeIdArray, nodeBackArray
   end repeat
   return allLinks
end linkArray_IdConstruct

private command linkArray_Add newLinkArray, someNode, @hLinkArray, @hIdArray, @backArray
   -- modified to work with nested newLinkArray
   put array_ConstructSimpleKeys (someNode, hIdArray, backArray) into nodeID
   put array_ConstructSimpleKeys (newLinkArray, hIdArray, backArray) into linkIDs   
   array_AddToIndex linkIDs, nodeID, hLinkArray
   return the result
end linkArray_Add

function linkArray_Keys linkArray
   local allKeys, idArray, backIdArray, nodeIDs
   linkArray_ConstructIdArray linkArray, allKeys, idArray, backIdArray, nodeIDs
   return allKeys
end linkArray_Keys

private command linkArray_ConstructSimpleKey someKey, @idArray, @backIdArray, pNumberOnly
   put backIdArray [someKey] into simpleID
   if simpleID is not empty then return empty -- already indexed
   
   -- work out new incremental ID and add to idArray and keyArray
   put the number of lines of keys(idArray) + 1 into keyNumber
   if pNumberOnly is true then
      put keyNumber into simpleID
   else
      put "n" & keyNumber into simpleID
   end if
   put simpleID into backIdArray [someKey]
   put someKey into idArray [simpleID]
   return simpleID
end linkArray_ConstructSimpleKey


--> LinkArray| Model | Convertion
-
function linkArray_ConstructOutline linkArray, hIdArray
    -- constructs a simple (reversable) outline from a link array
    -- different outlines are possible depending on the order of keys
    -- so sorting improves consistency
    
    put keys(linkArray) into linkKeys
    sort linkKeys
    repeat for each line keyID in linkKeys
        put hIdArray [keyID] into realKey
        put html_ConstructNameLink(realKey, keyID) & CR after someOutline
         
        put linkArray [keyID] into linkIDs
        put empty into realValues
        repeat for each line linkID in linkIDs
            put hIdArray [linkID] into realValue
            put tab & html_ConstructNameLink (realValue, linkID) & CR after someOutline
        end repeat
    end repeat
    delete char -1 of someOutline
    return someOutline
end linkArray_ConstructOutline
            
function linkArray_IdRevert linkArray, hIdArray
    repeat for each key keyID in linkArray
        put linkArray [keyID] into linkIDs
        put empty into realValues
        repeat for each line linkID in linkIDs
            put hIdArray [linkID] into realValue
            put realValue & CR after realValues
        end repeat
        delete char -1 of realValues
        
        put hIdArray [keyID] into realKey
        put realValues into realArray [realKey]
    end repeat
    return realArray
end linkArray_IdRevert

on linkArray_HashConstruct someArray, @hashedArray, @hashDictionary
    -- usefull to create simple arrays from complex data.
    -- references to complex data stored in hash key dictionary "hashDictionary"
    
    repeat for each key someKey in someArray
        put text_Hash (someKey) into hashKey
        put someKey into hashDictionary [hashKey]
         
        put someArray [someKey] into someValues
        
        put empty into hashValues
        repeat for each line someValue in someValues
            put text_Hash (someValue) into hashValue
            put someValue into hashDictionary [hashValue]
            put hashValue & CR after hashValues
        end repeat
        delete char -1 of hashValues
        put hashValues into hashedArray [hashKey]
    end repeat
end linkArray_HashConstruct

function linkArray_HashRevert hashedArray, hashDictionary
   repeat for each key hashKey in hashedArray
      put hashDictionary [hashKey] into realKey
      
      put hashedArray [hashKey] into hashValues
      
      put empty into realValues
      repeat for each line hashValue in hashValues
         put hashDictionary [hashValue] into realValue
         put realValue & CR after realValues
      end repeat
      delete char -1 of realValues
      put realValues into realArray [realKey]
   end repeat
   return realArray
end linkArray_HashRevert


--> LinkArray | Recursion | Experiments
-
on outline_RecurseToLinkArray tabbedOutline, someNode, @linkArray, @hIdArray, @backArray
   -- this recurses the outline properly
   -- and creates an abreviated array based on the node paths.
   
   -- not sure what its use is / if this makes a sensible array for muli-level outlines?
   -- so changed it to using paths instead of short names as the key to linkArray
   -- for a two level linkArray this is equivalent
   
   set the itemdelimiter to "/"
   put item -1 of someNode into nodeName
   put outline_PathOffset(someNode, tabbedOutline) into startOsLineNum
   put outline_GetChildren(startOsLineNum, tabbedOutline) into childNames
   
   linkArray_Add childNames, someNode, linkArray, hIdArray, backArray
   if someNode is empty then
      put empty into someStem
   else
      put someNode & "/" into someStem
   end if
   
   repeat for each line childName in childNames
      put someStem & childName into childNode
      outline_RecurseToLinkArray tabbedOutline, childNode, linkArray, hIdArray, backArray
   end repeat
end outline_RecurseToLinkArray

function linkArray_Xml linkArray, propertyArray
   breakpoint
   -- now use "outline_ToXmlStructure()"
   
   put "array" into rootNode
   xml_CreateTree rootNode, treeID
   
   repeat for each key someKey in linkArray
      put someKey into tagName
      xml_NormalizeTagName tagName
      
      put rootNode & "/" & tagName into firstLevelNode
      linkArray_ConstructXml firstLevelNode, linkArray, treeID, propertyArray
   end repeat
   put revXMLText(treeID, "", true) into someXml
   revDeleteXMLTree treeID
   return someXml
end linkArray_Xml

on linkArray_ConstructXml someNode, linkArray, treeID, @propertyArray
   breakpoint
   -- now use "outline_ToXmlStructure()"
   -- a recursive function
   -- more complex than it needs to be to allow outlines with dodgy xml tag names such as numbers
   
   -- add someNode to XML
   set the itemdelimiter to "/"
   put item -1 of someNode into tagName
   put item 1 to -2 of someNode into parentNode
   
   put revXMLRootNode(treeID) into rootNode
   put tagName into someKey
   xml_UnNormalizeTagName someKey
   
   if propertyArray [someKey,"indexedFlag"] = true then return false
   put true into propertyArray [someKey,"indexedFlag"]
   
   if tagName = rootNode then
      -- dont index
      -- do a header?
   else
      put propertyArray [someKey] into nodeContents
      put "" into nodeContents
      -- breakpoint
      revAddXMLNode treeID, parentNode, tagName, nodeContents
      
      -- lets add XML not content so it can be pretty indented and then replaced
      put the result into createdNode
      revAddXMLNode treeID, createdNode, "contents", nodeContents
      put the result into attributeNode
      revSetXMLAttribute treeID, attributeNode, "nodeID", tagName
      
   end if
   
   put linkArray [someKey] into childKeys
   repeat for each line childKey in childKeys
      put childKey into childName
      xml_NormalizeTagName childName
      put someNode & "/" & childName into childNode
      
      if propertyArray [childKey,"indexedFlag"] = true then
         -- do not recurse array node as it has already been indexed
         
         -- add child here as it will not be added by recursing!
         put propertyArray [someKey] into nodeContents
         revAddXMLNode treeID, someNode, childName, nodeContents
         next repeat
      else
         -- put indexedFlag into propertyArray [childKey]
         linkArray_ConstructXml childNode, linkArray, treeID, propertyArray
      end if
   end repeat  
end linkArray_ConstructXml


--> Private
-
private command _ConstructPropertyArray pDotPropertyArray, @overlap, @concentrate, @splines, @cluster, @direction, @dotOrder, @defaultShape, @defaultUrl
   -- see also dot_ConstructPropertyArray
   put pDotPropertyArray ["graphRect"] into graphRect
   delete local pDotPropertyArray ["graphRect"] 
   
   put pDotPropertyArray ["overlap"] into overlap
   delete local pDotPropertyArray ["overlap"] 
   
   put pDotPropertyArray ["concentrate"] into concentrate
   delete local pDotPropertyArray ["concentrate"] 
   
   put pDotPropertyArray ["splines"] into splines
   delete local pDotPropertyArray ["splines"] 
   
   put pDotPropertyArray ["cluster"] into cluster
   delete local pDotPropertyArray ["cluster"] 
   
   put pDotPropertyArray ["direction"] into direction
   delete local pDotPropertyArray ["direction"] 
   
   put pDotPropertyArray ["dotOrder"] into dotOrder
   delete local pDotPropertyArray ["dotOrder"] 
   
   put pDotPropertyArray ["defaultShape"] into defaultShape
   delete local pDotPropertyArray ["defaultShape"] 
   if defaultShape = "none" then put empty into defaultShape
   
   put pDotPropertyArray ["defaultUrl"] into defaultUrl
   delete local pDotPropertyArray ["defaultUrl"]
   return pDotPropertyArray
end _ConstructPropertyArray


--> Deps
-
on xml_NormalizeTagName @tagName
   -- xml tag names should not start with a number
   if char 1 of tagName is a number then
      put "node_" & tagName into tagName
   else
      put wiki_ConstructID(tagName) into tagName
   end if
end xml_NormalizeTagName

on xml_UnNormalizeTagName @tagName
   if char 1 to 5 of tagName = "node_" then
      delete char 1 to 5 of tagName
   end if
end xml_UnNormalizeTagName
