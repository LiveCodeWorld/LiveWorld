script "lib_MenuUtils"
--> MetaData
-
license: GPLv3
name: lib_MenuUtils
type: script library
copyright: David Bovill
licence:  GPLv3
version: 0.1


/* libOPN_MenuExtras
A dumping ground for old menu scripts which still may be used somewhere :)

We gradually check these and move them over to lib_Menu if they prove robust and useful.
*/


--> Menu | Target | Overide
-
/*
These handlers allow scripts to overlide the default technique of establishing a target (mTarget) for a menu, or menuItem.

You do this by issuing "menu_SetItemTargetOveride", or "menu_SetTitleTargetOveride". 
The latter applies to a whole menu specified by the mTitle, while the former applies to a specif menu item specifed by a path.

Both these matches depend on whether a single item is passes or a hieararchical path. 
If a single mItem of a full mPath is set using "menu_SetItemTargetOveride",
then a match anywhere for any item in the actual mPath will be good. 
If a path containing several items is passed in mPath, then anything but an exact match will return empty.

Similarly with "menu_SetTitleTargetOveride", a single item will match anywhere in mTitlePath, 
while multiple items specified in "menu_SetTitleTargetOveride matchTitlePath, mTarget" will only match,
if the hierachy of the full mTitlePath of the selected menu starts with matchTitlePath. 
This differs from the "menu_GetItemTargetOveride" match in that it seearches the full hierarchy, 
allowing a specific class of mTitlePath to be matched.
*/

function menu_GetTargetOveride mTitlePath, mPath
   put menu_GetItemTargetOveride (mPath) into mTarget
   if exists (mTarget) then return mTarget
   
   put menu_GetTitleTargetOveride (mTitlePath) into mTarget
   return mTarget
end menu_GetTargetOveride

function menu_GetTitleTargetOveride sentTitlePath
   global gTemp_ActiveMenuArray
   set the itemdelimiter to "/"
   
   -- if the overide is an exact path return any match immediately
   put gTemp_ActiveMenuArray ["overide"]["mTitle"][sentTitlePath]["mTarget"] into mTitleTarget
   if exists (mTitleTarget) then return mTitleTarget
   
   -- faster to search through any stored overides (as they are rare)
   put gTemp_ActiveMenuArray ["overide"]["mTitle"] into titleMatchArray
   repeat for each key mTitleToMatch in titleMatchArray
      if mTitleToMatch is among the items of sentTitlePath then
         put titleMatchArray [mTitleToMatch]["mTarget"] into mTitleTarget
         if exists (mTitleTarget) then return mTitleTarget
      end if
   end repeat
   return empty
end menu_GetTitleTargetOveride

command menu_SetTitleTargetOveride mTitleToMatch, mTarget
   global gTemp_ActiveMenuArray
   put mTarget into gTemp_ActiveMenuArray ["overide"]["mTitle"][mTitleToMatch]["mTarget"]
end menu_SetTitleTargetOveride

function menu_GetItemTargetOveride sentMenuItemPath
   -- search for exact match in each item of path
   -- will return empty if match does not exist perhaps because stack is not known.
   global gTemp_ActiveMenuArray
   
   -- if the overide is an exact path return any match immediately
   put gTemp_ActiveMenuArray ["overide"]["mItem"][sentMenuItemPath]["mTarget"] into mItemTarget
   if exists(mItemTarget) then return mItemTarget
   
   -- faster to search through any stored overides
   put gTemp_ActiveMenuArray ["overide"]["mItem"] into itemMatchArray
   set the itemdelimiter to "/"
   repeat for each key mItemToMatch in itemMatchArray
      if mItemToMatch is among the items of sentMenuItemPath then
         put itemMatchArray [mItemToMatch]["mTarget"] into mItemTarget
         if exists(mItemTarget) then return mItemTarget
      end if
   end repeat
   return empty
end menu_GetItemTargetOveride

command menu_SetItemTargetOveride mItemToMatch, mTarget
   global gTemp_ActiveMenuArray
   put mTarget into gTemp_ActiveMenuArray ["overide"]["mItem"][mItemToMatch]["mTarget"]
end menu_SetItemTargetOveride


--> Model | Title | Tables
-
/*
Menu Title Tables (mTitleTable) are tab delimited arrangements of multiple mTitles,
that can be combined to draw a composite menu.

mTitleTables default to simple indexes of global menus,
however the subsequent item mController should be included when the menu is not indexed as a global menu.
There is a notion of adding further metadata (mBeforeLineNum and mPassMouseDown) for advanced hacking of existing menus,
but these are nto currenlty tested or supported.

Internaly the data is now stared as arrays, however the table format has the advantage of speed,
as it is not necessary to re-index lines when the tables are combined.
*/

function menu_GetTextFromTitleTable mTitleTable, targetObject, pMenuTarget
   -- repeats over mTitles in table
   -- called by "menu_PullDown" etc to dynamically create and "set the menu_Text of pTargetObject"
   local mText, pTitlePath, mTopController, mTopTitle
   
   replace comma with tab in mTitleTable
   set the itemdelimiter to tab
   repeat for each line mTitleLine in mTitleTable
      put item 1 of mTitleLine into mTitle
      put item 2 of mTitleLine into mType
      put item 3 of mTitleLine into pTextPath
      
      if mTitleLine = "-" then
         put "-" & CR after mText
         next repeat
      end if
      
      global gTemp_ActiveMenuArray
      if gTemp_ActiveMenuArray ["recursion check"][mTitle][targetObject] is true then -- recursion check
         opn_Notify merge("Recursion in 'menu_GetTextFromTitleTable' for menu '[[mTitle]]'"), true
         -- would be nice to disable or indicate more clearly where the recursion is?
         return empty
      else
         put true into gTemp_ActiveMenuArray ["recursion check"][mTitle][targetObject]
      end if
      
      put the menu_Table [mTitle] of targetObject into mTable
      
      switch 
         case mType = "submenu"  
            if pTextPath is empty then put menu_MenuTextFromTitle (mTitle) into pTextPath -- old ?? Why not use "put mType into pTitlePath"
            
            put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into moreMenuText
            if moreMenuText is empty then
               -- submenu is empty
            else
               put pTextPath  & CR after mText
               put outline_IncreaseIndent (moreMenuText) & CR after mText
            end if
            break
         case mType is not empty
            put mType into pTitlePath
            put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into moreMenuText
            if moreMenuText is not empty then
               put moreMenuText & CR after mText
            end if
            break
         default
            put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into moreMenuText
            if moreMenuText is not empty then
               put moreMenuText & CR after mText
            end if
      end switch
   end repeat
   delete char -1 of mText
   return mText
end menu_GetTextFromTitleTable


--> Menu | Utitlites
-
command menu_SetFromMenuPick deleteName, pButton
   if exists(pButton) is false then put the long id of the target into pButton
   put the menu_PickConditions of pButton into mItems
   if the optionkey is down then line_Delete deleteName, mItems
   
   put lineOffset (deleteName, mItems) into lineNum
   if lineNum is not 0 then
      put CR & "-" after line lineNum of mItems
   end if
   set the text of pButton to mItems
   return mItems
end menu_SetFromMenuPick


--> Menu | Tests
-
command menu_StripDividers @mText
   -- filter mText without "*-"
   repeat with lineNum = the number of lines of mText down to 1
      if word 1 to -1 of line lineNum of mText = "-" then
         delete line lineNum of mText
      end if
   end repeat
end menu_StripDividers

command menu_ClearActiveArray
   global gTemp_ActiveMenuArray
   put empty into gTemp_ActiveMenuArray
end menu_ClearActiveArray

function menu_IsUnder mTitlePath, mStem
   get char 1 to (the number of chars of mStem) of mTitlePath
   return it = mStem
   
   set the itemDelimiter to "|"
   delete item -1 of mTitle
   delete item -1 of mStem
   
   put item 1 to (the number of items of mStem) of mTitle into testStem
   -- could normalize spaces
   return testStem = mStem
end menu_IsUnder

function menu_SortTitles mTitles
   -- it is not possible to do a proper sort with non-reverse polish notation naiming of menus
   -- without deleting last "Menu" bit for each line and then reconstructing then!
   
   set the itemdelimiter to "|"
   sort mTitles ascending by the number of items of each
   sort mTitles ascending by item 2 of each
   return mTitles
end menu_SortTitles

function menu_GlobalControllerOutline pObjectFormat
   put menu_ConstructGlobalControllerArray (pObjectFormat) into menuObjectArray
   put keys(menuObjectArray) into uniqueObjects
   sort uniqueObjects
   put object_OutlineFromIndex (uniqueObjects) into objectOutline
   return objectOutline
end menu_GlobalControllerOutline


--> Menu | Utilities
-
function menu_SuiteScript globalMenuTitle
   put menu_GetGlobalController(globalMenuTitle) into menuController
   if exists(menuController) is false then
      put the executioncontexts into logExecutionContexts
      log_Error globalMenuTitle, "Object does not exist for:", true, logExecutionContexts
      return empty
   end if
   put the script_Suite [globalMenuTitle] of menuController into menuSuiteScript
   return menuSuiteScript
end menu_SuiteScript

function menu_FromFolders someFolders
   replace "/" with "\/" in someFolders
   return someFolders
end menu_FromFolders

command menu_SetChoice menuChoice, @mainChoice, @secondChoice
   -- bug - needs to take account of quoted things like stack names with "|" in their name.
   text_StarQuoted menuChoice
   put the result into replacedArray
   put replacedArray ["original text"] into oText
   
   put line 1 of menuChoice into menuChoice
   set the itemdelimiter to "|"
   put the number of chars of item 1 of menuChoice into firstLength
   put char 1 to firstLength of oText into mainChoice
   
   put firstLength + 2 into secondStart
   put char secondStart to -1 of oText into secondChoice
end menu_SetChoice

-- function menu_CheckDisabledItem mFormatProp, mTarget, mController, menuIsDisabled
if menuIsDisabled is true then return true
if mFormatProp is empty then return false

try
   put mFormatProp & "[" & mTarget & "]" into mFormatProperty
   put the mFormatProperty of mController into itemIsDisabled
catch someError
   -- error_CheckDisabled mController, mTarget, mTitlePath, mTableLine, someError
end try
return itemIsDisabled
end menu_CheckDisabledItem

-- function menu_CheckDisabled mFormatProp, mTarget, mController
if mFormatProp is empty then return false

try
   put mFormatProp & "[" & mTarget & "]" into mFormatProperty
   put the mFormatProperty of mController into itemIsDisabled
   return itemIsDisabled
catch someError
   return someError
end try
end menu_CheckDisabled

function menu_ConvertTableArray mTableArray, mView, pTitlePath, pTextPath, pMenuTarget, pMenuIsDisabled
   -- need to fix to keep same logic as menu_ConvertTable (submenu title path fixes)
   global gTemp_ActiveMenuArray
   local mPath, mTitlePath, mController, pigeon, mTitle, mLine, mFormatProp, mType, submenuProp, paramProp   
   
   put item 2 of the extents of mTableArray into maxNum
   repeat with lineNum = 1 to maxNum
      put mTableArray [lineNum] into recordArray
      
      put recordArray ["mType"] into mType
      put recordArray ["mLine"] into mLine
      put recordArray ["mTitle"] into mTitle    
      
      if mType is "-" then
         put "-" & CR after mText
         next repeat
      end if
      
      try
         menu_IncrementPaths recordArray, mPath, mTitlePath, pTextPath, pTitlePath
         
         put recordArray ["mController"] into mController
         put recordArray ["pigeon"] into pigeon
         addToMenuActiveArray mPath, mTitlePath, pigeon, mController, mView, mType, pMenuTarget
         if exists (mController) is false then next repeat
         
         put menu_TargetFromGlobal (mPath) into mTarget -- mTarget must be same as what "menu_SendMessage does
         
         if pMenuIsDisabled is empty then
            -- first time (not used for recursive sub menus - these are already checked in the recursive handler)
            try
               put the menu_CheckTarget [mTarget] of mController into targetOK
            catch e
               put false into targetOK
            end try
            
            -- if targetOK is "delete" then next repeat
            -- put targetOK is false into menuIsDisabled
            
            switch targetOK
               case "delete"
                  next repeat
                  break
               case false
                  put targetOK is false into menuIsDisabled
                  break
               case true
                  put targetOK is false into menuIsDisabled
                  break
               default
                  -- could be used to swtich menus
                  put targetOK is false into menuIsDisabled
            end switch
         else
            -- allows override (but should false = empty = do another check for recursive menus?)
            put pMenuIsDisabled into menuIsDisabled
         end if
         
         put recordArray ["disabledProp"] into mFormatProp
         
         switch mType
            -- case mType = "inserted"
            case "insert"
               put recordArray ["submenu_Title"] into insertedMenuTitle
               put recordArray ["submenu_Controller"] into insertedMenuController
               menu_IncludeMenuText mText, insertedMenuTitle, mView, insertedMenuController, menuIsDisabled, mTitlePath, mPath, pMenuTarget
               break
            case "submenu"
               put recordArray ["submenu_Title"] into subMenuTitle
               put recordArray ["submenu_Controller"] into subMenuController  
               
               if menuIsDisabled is true then
                  put true into subMenuIsDisabled
               else
                  put mPath into subMenuPath
                  put mTitlePath & "/" & subMenuTitle into subMenuTitlePath
                  put menu_TargetFromGlobal (subMenuPath) into subMenuTarget -- mTarget must be same as what "menu_SendMessage does
                  
                  try
                     put the menu_CheckTarget [subMenuTarget] of subMenuController into targetOK
                  catch e
                     put false into targetOK
                  end try
                  
                  switch targetOK
                     case "delete"
                        next repeat
                        break
                     case false
                        put true into subMenuIsDisabled
                        break
                     case true
                        put menu_CheckDisabled (mFormatProp, mTarget, mController) into subMenuIsDisabled
                        break
                     default
                        -- could be used to replace a disabled menu with another menu
                        -- use to fix reason why menu is disabled for instance
                        put false into subMenuIsDisabled
                  end switch
               end if
               
               if subMenuIsDisabled is true then menu_DisableLine mLine
               
               menu_InsertSubMenu mText, mLine, subMenuTitle, mView, subMenuController, mTitlePath, mPath, pMenuTarget, subMenuIsDisabled
               break
            default -- it is not a recursively called menu insertion
               if menuIsDisabled is true then  -- lets check if menu item is disabled
                  put true into itemIsDisabled
               else
                  put menu_CheckDisabledItem (mFormatProp, mTarget, mController, false, mTitlePath, mTableLine) into itemIsDisabled
               end if
               
               put recordArray ["submenu_GetProp"] into submenuProp
               put recordArray ["submenu_CheckedProp"] into checkedProp
               
               switch
                  case itemIsDisabled = "delete"
                     -- dont add mLine
                     break
                  case itemIsDisabled =  true or menuIsDisabled is true
                     -- disable mLine
                     menu_DisableLine mLine
                     put mLine & CR after mText
                     break
                  case itemIsDisabled is not false and itemIsDisabled is not empty
                     -- replace mLine with substituted text
                     put itemIsDisabled & CR after mText
                     break
                  case mType = "boolean"
                     -- add check sub menu to mLine
                     menu_AddBooleanLine mText, mLine, checkedProp, mTarget, mController
                     break
                  case mType = "fixed"
                     -- fetch sub menu from custom property and add to mLine
                     menu_InsertFixed mText, mLine, pigeon, mController, submenuProp, mTarget, mType
                     break
                  case mType is among the items of "custom submenu,custom external"
                     -- fetch sub menu from getprop and add to mLine
                     menu_FetchCustomMenuItems mText, mLine, submenuProp, mController, checkedProp, mTarget, mType
                     break
                  default -- a plain menu item - just add to mLine
                     put mLine & CR after mText
               end switch
         end switch
      catch someError
         beep
         -- display_Text (mTableLine & CR & CR & someError), mTableLine
      end try
   end repeat
   menu_TidyText mText
   return mText
end menu_ConvertTableArray

command menu_IncrementPaths recordArray, @mPath, @mTitlePath, pTextPath, pTitlePath
   put recordArray ["mType"] into mType
   put recordArray ["mTitle"] into mTitle
   put recordArray ["mLine"] into mLine
   put menu_CleanLine (mLine) into mSendLine
   
   switch
      case mType = "insert"
         put pTextPath into mPath
         
         if pTitlePath is empty then
            put mTitle into mTitlePath
         else
            put pTitlePath & "/" & mTitle into mTitlePath     
         end if
         break
      case mType = "submenu"
         put recordArray ["submenu_Title"] into subMenuTitle
         
         if pTextPath is empty then
            put mSendLine into mPath
         else
            put pTextPath & "|" & mSendLine into mPath
         end if
         
         if pTitlePath is empty then
            put mTitle into mTitlePath
         else
            put pTitlePath & "/" & mTitle into mTitlePath     
         end if
         -- put "/" & subMenuTitle after mTitlePath
         break
      default
         if pTextPath is empty then
            put mSendLine into mPath
         else
            put pTextPath & "|" & mSendLine into mPath
         end if
         
         if pTitlePath is empty then
            put mTitle into mTitlePath
         else
            put pTitlePath & "/" & mTitle into mTitlePath
         end if
   end switch
end menu_IncrementPaths

function menu_GetGlobalText globalMenuTitles, mView
   local pTitlePath, pTextPath
   
   set the itemdelimiter to "|"
   repeat for each line globalMenuTitle in globalMenuTitles
      put menu_GetGlobalController (globalMenuTitle) into globalMenuController
      if exists(globalMenuController) is false then next repeat
      put the menu_Table [globalMenuTitle] of globalMenuController into mTable
      put menu_ConvertTable (mTable, mView, pTitlePath, pTextPath) into globalMenuText
      put globalMenuText & CR after mText
   end repeat
   delete char -1 of mText
   return mText
end menu_GetGlobalText

function menu_MenuTextFromTitle mTitle
   set the itemdelimiter to "|"
   delete item - 1 of mTitle
   if word 1 to -1 of item 1 of mTitle = "Global" then delete item 1 of mTitle
   
   replace " | " with " " in mTitle
   return word 1 to -1 of mTitle
end menu_MenuTextFromTitle


--> Menu | Send
-
command menu_DoPick menuChoice
   menu_SetChoice menuChoice, mainChoice, secondChoice
   put menu_CommandFromText (mainChoice) into mCommand
   dispatch mCommand to the target with secondChoice
end menu_DoPick

-- command menu_SendMessage mPath, pMenuTarget, pCreateActiveArray
   -- to avoid menuPick handler in front script calling this twice must return non-empty if the menu is handled
   if pCreateActiveArray is true then
      breakpoint
      get the menu_Text of the target -- will usually have already been constructed with dynamic menus on mouseDown
   end if
   
   menu_DeconstructPath mPath, foundPath, subMenuPath, pigeon, mController, mTitlePath, mItemType
   if the result is false then return empty  -- when frontscript is active will be called by every menu (even Rev Ide menus)
   
   if exists (pMenuTarget) then
      menu_SetItemTargetOveride mPath, pMenuTarget
      put pMenuTarget into mTarget
   else
      put menu_TargetFromGlobal (mPath) into mTarget  -- mTarget must be same as what "menu_SendMessage does
   end if
   
   menu_SetSentPath mPath -- everything can be derived from that
   menu_SetTitlePath mTitlePath
   
   if exists (mController) is false then
      -- something wrong
      breakPoint
   end if
   
   if the menu_OptionEdit of me is true and the optionkey is "Down" then
      dispatch "menu_EditMenuItem" to mController with pigeon,foundPath,subMenuPath,mController,mTarget
      return the result
   else
      put token 1 of pigeon into mCommand
      put token 2 of pigeon into firstParamName
      put token 4 of pigeon into secondParamName
      
      if the menu_Version of mController is empty then
         if firstParamName is "subMenuPath" then -- and secondParamName is "mTarget" then
            dispatch mCommand to mController with subMenuPath, mTarget
         else -- if firstParamName is "mTarget" and secondParamName is "subMenuPath" then
            -- not used at the moment - but would be consistent
            dispatch mCommand to mController with mTarget, subMenuPath
         end if
      else
         -- move over to a consistent param order
         dispatch mCommand to mController with mTarget, subMenuPath
      end if
      
      switch it
         case "handled"
            return it
         case "passed"
            return it
         case "not handled"
            -- menu_SendMessageError tError
            return it
      end switch
   end if
end menu_SendMessage

on menu_EditMenuItem pigeon, foundPath, subMenuPath, mController, sentMenuTarget
   -- this is the default which can be overridden in the menu.
   put "What would you like to do with the script of this menu item?" into someQuestion
   answer someQuestion with "Cancel" or "Export" or "Edit"
   if it = "Edit" then
      menu_EditMenuItemScript pigeon, mController, sentMenuTarget
   else if it = "Export" then
      menu_ExportMenuItemScript pigeon, mController
   end if
   return the result
end menu_EditMenuItem

command menu_SendMessageError tError
   -- seems to throw a recursive error with 'revSetActiveStacks"
   put merge("Error, there is no handler for '[[pigeon]]'... in the controller '[[mController]]'. The mPath was '[[mPath]]'") & CR & CR & tError into errorComment
   log_Error errorComment,  "menu_SendMessage", true, true
   
   display_ActiveMenuArray
   menu_ClearTargetGlobals
end menu_SendMessageError

-- command menu_DeconstructPath mPath, @foundPath, @foundParam, @pigeon, @mController, @mTitlePath, @mItemType
global gTemp_ActiveMenuArray

put empty into foundParam
put empty into pigeon
put empty into mController
put empty into mTitlePath
put empty into mItemType

-- lets search to see if there is a param being sent with the menu
-- pity menus don't use a different delimiter like tab
-- as the text of the menu item could include "|" we can't just check the first item
-- but should search back down through all items

set the itemdelimiter to "|"
put the number of items of mPath into maxNum
repeat with itemNum = maxNum down to 1
   put item 1 to itemNum of mPath into foundPath
   put gTemp_ActiveMenuArray ["mPath"][foundPath] into foundArray
   
   if foundArray is an array then
      -- found a mPath in active menu global
      
      put foundArray ["pigeon"] into pigeon
      put foundArray ["mController"] into mController
      put foundArray ["mItemType"] into mItemType
      put foundArray ["mTitlePath"] into mTitlePath
      
      put item (itemNum + 1) to maxNum of mPath into foundParam
      return true
   end if
end repeat

put empty into foundPath
return false
end menu_DeconstructPath

-- command menu_FetchCustomMenuItems @mText, mLine, submenuProp, mController, paramProp, mTarget, mItemType
try
   put mLine & CR after mText
   
   put submenuProp & "[" & mTarget & "]" into submenuProperty
   put the submenuProperty of mController into subMenu
   
   if subMenu is not empty then
      -- check submenu
      replace comma with CR in subMenu
      menu_CheckSub subMenu, paramProp, mController, mTarget, mItemType
      put outline_IncreaseIndent (subMenu, 1) into subMenu
      put subMenu & CR after mText
   end if
catch someError
   error_LogCustomMenuItems mController, submenuProperty, someError
end try
end menu_FetchCustomMenuItems

command menu_AddBooleanLine @mText, mLine, paramProp, topMenuTarget, mController
   put mLine & CR after mText
   
   if the number of tokens of paramProp = 1 then
      put paramProp & "[" & topMenuTarget & "]" into paramProperty
   else
      put paramProp into paramProperty
   end if
   try
      put the paramProperty of mController into someBoolean
      
      if someBoolean is true then
         put "!ctrue" & CR & "!nfalse" into subMenu
      else if someBoolean is false then
         put "!ntrue" & CR & "!cfalse" into subMenu
      else
         put "true" & CR & "false" into subMenu
      end if
      put outline_IncreaseIndent(subMenu) into subMenu
      put subMenu & CR after mText
      return empty
   catch tError
      put merge("Error: fetching boolean custom property '[[paramProperty]]' of mController") & CR into someError
      put CR after someError
      if exists(someError) then
         put "mController:" && the mobile_Name of mController after someError
      else
         put "mController:" && mController after someError
      end if
      -- error_LogBoolean mController, mTableLine, mTitle, mTitlePath, mLine, tError
      return someError
   end try
end menu_AddBooleanLine

-- command menu_InsertFixed @mText, mLine, pigeon, mController, paramProp, topMenuTarget, mItemType
put mLine & CR after mText
put word 1 of pigeon into mCommand
put the submenu_Fixed [mCommand] of mController into subMenu
if subMenu is not empty then
   menu_CheckSub subMenu, paramProp, mController, topMenuTarget, mItemType
   put outline_IncreaseIndent(subMenu) into subMenu
   put subMenu & CR after mText
end if
end menu_InsertFixed

command menu_InsertSubMenu @mText, mLine, subMenuTitle, mView, subMenuController, pTitlePath, pTextPath, pMenuTarget, pSubMenuIsDisabled
   global gTemp_ActiveMenuArray
   -- put gTemp_ActiveMenuArray ["mTitlePath"][pTitlePath] into testArray
   put gTemp_ActiveMenuArray ["mTitle"][pTextPath] into testArray
   if testArray is an array then
      breakpoint
      return empty -- recursion check
   end if
   
   put menu_GetTable (subMenuTitle, subMenuController) into mTable
   
   -- hack
   set the itemdelimiter to "/" 
   delete item -1 of pTitlePath
   put menu_ConvertTable (mTable, mView, pTitlePath, pTextPath, pMenuTarget, pSubMenuIsDisabled) into subMenu
   
   if subMenu is empty then
      -- don't do anything (ie also remove the submenu_Title "mLine"
   else
      put mLine & CR after mText
      put outline_IncreaseIndent (subMenu, 1) into subMenu
      put subMenu & CR after mText
   end if
end menu_InsertSubMenu

command menu_IncludeMenuText @mText, insertedMenuTitle, targetObject, insertedMenuController, menuIsDisabled, pTitlePath, pTextPath, pMenuTarget
   -- recursive handler so be careful here to avoid infinite loops
   put menu_GetTable (insertedMenuTitle, insertedMenuController) into insertedMenuTable
   -- set the itemdelimiter to "/"
   -- delete item - 1 of pTitlePath
   put menu_ConvertTable (insertedMenuTable, targetObject, pTitlePath, pTextPath, pMenuTarget, menuIsDisabled) into insertedMenu
   if insertedMenu is not empty then put insertedMenu & CR after mText
   return empty
end menu_IncludeMenuText

command menu_DisableLine @mLine
   if char 1 of word 1 of mLine is not "(" then put "(" before word 1 of mLine
end menu_DisableLine

command menu_TidyText @mText
   put word 1 to -1 of mText into mText
   
   -- remove double dividers
   replace (CR & "-" & CR & "-" & CR) with (CR & "-" & CR) in mText
   
   -- removes things like blank missing menu spaces
   repeat while (word 1 to -1 of line 1 of mText = "-")
      delete line 1 of mText
   end repeat
   repeat while (word 1 to -1 of line -1 of mText = "-")
      delete line -1 of mText
   end repeat
end menu_TidyText

-- command menu_CheckSub @subMenu, paramProp, mController, mTarget, mItemType
if paramProp is empty then return empty

-- passing parameter can cause a custom property to fail to return when no getprop is there.
put paramProp & "[" & mTarget & "]" into paramProperty
try
   put the paramProperty of mController into checkedItems
   if checkedItems is empty and mItemType is among the items of "custom,fixed" then
      -- a hack ???
      -- put the paramProp of mController into checkedItems
   end if
   
   replace comma with CR in checkedItems
   repeat for each line checkedItem in checkedItems
      menu_SetCheckedItem checkedItem, subMenu, true
   end repeat
catch tError
   if exists (mController) then put the mobile_Name of mController into mController
   put paramProperty & CR & mController into errorInfo
   display_Lines errorInfo, "menu_CheckSub - the paramProperty of"
   -- breakPoint
   if exists (mController) then edit the script of mController
end try
end menu_CheckSub


--> Menu | Controller | Global
-
function menu_MatchGlobalController globalMenuTitle
   menu_SearchGlobalObjectHierarchy globalMenuTitle, mController
   if exists(mController) is false then
      opn_Notify merge("Cannot find global menu '[[mTitle]]'!"), true
      return empty
   else
      return mController
   end if
end menu_MatchGlobalController

command menu_SearchGlobalObjectHierarchy @foundGlobalTitle, @foundMenuController
   -- get the executioncontexts
   put empty into foundMenuController
   put foundGlobalTitle into oTitle
   put script_ExtractGlobalSuiteArray ("Menu") into dataArray
   set the itemdelimiter to "|"
   repeat (the number of items of foundGlobalTitle - 2)
      put dataArray [foundGlobalTitle] into foundMenuController
      if exists(foundMenuController) then return foundMenuController
      delete item - 2 of foundGlobalTitle
   end repeat
   put oTitle into foundGlobalTitle
   put empty into foundMenuController
end menu_SearchGlobalObjectHierarchy

command menu_EditScript mTitle
   put menu_GetGlobalController (mTitle) into someObject
   if exists (someObject) then
      edit the script of someObject
   end if
end menu_EditScript

function menu_GetScript mTitle, targetObject
   put the menu_Controller [mTitle] of targetObject into mController
   put the script of mController into someScript
   put script_GetSuite (mTitle, someScript) into scriptSuite
   
   put mTitle && "| Props" into scriptMenuPropsTitle
   put script_GetSuite (scriptMenuPropsTitle, someScript) into scriptPropsSuite
   if scriptPropsSuite is not empty then
      put CR & CR & scriptPropsSuite after scriptSuite
   end if
   return scriptSuite
end menu_GetScript

command menu_InitialiseTopController @mTopController, mTopTitle, targetObject
   -- used by front scripts
   -- put the menu_LocalController [mTopTitle] of targetObject into mTopController
   put the menu_Controller [mTopTitle] of targetObject into mTopController
   -- error_InitialseTopController mTopController, targetObject
   menu_SetTopController mTopController
end menu_InitialiseTopController

function menu_ConstructHkey mItemName, mName, pMenuController
   if pMenuController is empty then
      put menu_GetGlobalController (mName) into pMenuController
   end if
   put hkey_Construct (mItemName, "c", pMenuController, 1) into hKey
   return hKey
end menu_ConstructHkey


--> Menu | Title
-
/*
A menu_Title is the title of a "script menu".  It is the link between the target and the menu_Controller.

The menu_Title can be set to change wich menu is displayed, but this is not usually needed
as the default value (menu_DefautTitle) is taken from the stem of the views owner.

These properties are defined globally so that they can be overridden locally. 
Usually a title_View will not have menu_Title properites.

A title view in this way does not have its own menu, but draws the menu linked to its owner.
Therefore a title_View in a tree_View draws a "Tree | Menu", 
while the same title_View in a table_View would draw a "Tree | Menu"
This allows a title to be changed and the default title remain the same.

There can be different controllers for different mTitles, allowing menus to be switched by changing the mTitle
It is equivalent to the title of the script_Suite that contains the menu code.
*/

function menu_GetToolTitle targetObject
   put the long id of the target into targetObject
   put the view_Object of targetObject into viewObject
   if exists(viewObject) is false then put targetObject into viewObject
   
   -- put the menu_BurntToolTitle of someView into mTitle
   lock messages
   put the menu_ToolTitle of viewObject into mTitle
   unlock messages
   if mTitle is not empty then return mTitle
   
   put the view_Name of viewObject into viewName
   if viewName is empty then return empty
   put "Global |" && menu_TitleFromViewName (viewName) into globalMenuTitle
   return globalMenuTitle
   
   -- not sure if we should also search?
   local testController
   put the menu_DefaultToolTitle of targetObject into globalMenuTitle
   menu_SearchGlobalObjectHierarchy globalMenuTitle, testController
   return globalMenuTitle
end menu_GetToolTitle

command menu_DeleteTitle mTitle, targetObject
   set the view_Value ["menu_Title"] of targetObject to empty
end menu_DeleteTitle

function menu_GlobalTitleFromViewName vName
   put "Global |" && menu_TitleFromViewName (vName) into globalMenuTitle
   return globalMenuTitle
end menu_GlobalTitleFromViewName

function menu_TitleFromViewName viewName, levelAbove
   set the itemdelimiter to "|"
   delete item 1 of viewName
   if levelAbove is a number then
      delete item -1 to -levelAbove of viewName
   end if
   replace "|" with " | " in viewName
   
   put viewName && "| Menu" into mTitle
   return mTitle
end menu_TitleFromViewName

function menu_ViewNameFromTitle mTitle
   replace " | " with "|" in mTitle
   set the itemdelimiter to "|"
   if word 1 to -1 of item 1 of mTitle = "Global" then
      put "View" into item 1 of mTitle
   else
      put "View|" before mTitle
   end if
   delete item -1 of mTitle
   return mTitle
end menu_ViewNameFromTitle

function menu_CheckTitleController mTitle, mController
   put menu_GetTableTitles (mController) into mTitles
   return mTitle is among the lines of mTitles
end menu_CheckTitleController

command menu_FindTitle mTitle, targetObject, @mController, pWhichHierarchy
   -- put the view_Hierarchy of the target into testControllers
   if pWhichHierarchy is empty then put "stack" into pWhichHierarchy -- or maybe use "development" as default ?
   put the hkey_SearchHierarchy [pWhichHierarchy] of targetObject into testControllers
   
   set the itemdelimiter to "|"
   set the wholematches to true
   repeat for each line mController in testControllers
      put menu_CheckTitleController (mTitle, mController) into isThere
      if isThere is true then return true
   end repeat
   put empty into mController
   return false
end menu_FindTitle

command menu_SearchViewHierarchy someView, @mTitle, @mController, pSearchScript
   -- slow and very sticky / fuzzy
   put the view_Hierarchy of someView into testControllers
   if testControllers is empty then
      put someView into testControllers  -- fix in case it is nto a view
   end if
   put the card_Object of someView into cardObject
   line_Add cardObject, testControllers 
   
   set the itemdelimiter to "|"
   repeat the number of items of mTitle
      repeat for each line mController in testControllers
         if pSearchScript is true then
            put the menu_ScriptTitles of mController into mTitles
         else
            put menu_GetTableTitles (mController) into mTitles
         end if
         if mTitle is among the lines of mTitles then return true
      end repeat
      delete item -2 of mTitle
      put word 1 to -1 of mTitle into mTitle
   end repeat
   put empty into mTitle
   put empty into mController
   return false
end menu_SearchViewHierarchy


--> Menu | Target
-
/*
All temporary menu data is stored in the global gTemp_ActiveMenuArray

gOPN_MenuArray is where the long term dictionary is stored.
*/

function menu_TargetFromGlobal mPath
   put menu_TitlePathFromPath (mPath) into mTitlePath
   
   -- used by "menu_ConvertTable" and "menu_SendMessage"
   -- this is the logic for getting the menu_Target
   -- first the override, then the mController (card) then the view, finally a sensible default
   -- this means a card script will override the views script (which is an unusual but useful message hierarchy)
   
   -- first lets see if there is an overide by using pMenuTarget
   put menu_GetTargetOveride (mTitlePath, mPath) into mTargetOveride
   -- if exists (mTargetOveride) then return addThenReturn (mTargetOveride)
   if mTargetOveride is not empty or mTargetOveride is an array then return addThenReturn (mTargetOveride)
   
   -- then check the mTopController (often the card with the menu)
   put menu_GetTopController() into mTopController
   
   try
      put the menu_Target [mTitlePath] of mTopController into mTarget
   catch mTargetError
      -- bug: mTopController is empty on first call ????
      -- breakPoint
   end try
   if mTarget is not empty or mTarget is an array then
      return addThenReturn (mTarget)
   end if
   
   -- so go get a default!
   put menu_GetTargetObject() into targetObject
   put _GetDefaultMenuTarget (mPath, mTitlePath, targetObject) into mTarget
   return addThenReturn (mTarget)
end menu_TargetFromGlobal


--> Menu | | Title | Translation
-
function menu_TitlePathToView mTitlePath, topView
   set the itemdelimiter to "/"
   repeat for each item mTitle in mTitlePath
      put menu_TitleToViewName(mTitle) into viewName
      put viewName & CR after viewNames
   end repeat
   return viewNames
end menu_TitlePathToView

function menu_TitleToViewName mTitle
   set the itemdelimiter to "|"
   replace " | " with "|" in mTitle
   delete item -1 of mTitle
   if word 1 to -1 of item 1 of mTitle = "Global" then
      put "View" into item 1 of mTitle
   else
      put "View|" before mTitle
   end if
   return mTitle
end menu_TitleToViewName

function menu_FindAssociatedViewNames mTitle
   put menu_ViewNameFromTitle(mTitle) into viewStem
   put view_FilteredPaths(viewStem, true) into viewNames
   return viewNames
end menu_FindAssociatedViewNames

function menu_FindAssociatedLibraryObject mTitle
   put menu_ViewNameFromTitle(mTitle) into viewName
   put view_GetTemplateObject (viewName) into libraryObject
   if exists(libraryObject) is true then return libraryObject
   
   put menu_FindAssociatedViewNames(mTitle) into viewNames
   repeat for each line viewName in viewNames
      put view_GetTemplateObject (viewName) into libraryObject
      if exists(libraryObject) is true then return libraryObject
   end repeat
   return empty
end menu_FindAssociatedLibraryObject

function menu_ViewReferenceFromTitle mTitle
   put menu_ViewNameFromTitle(mTitle) into viewName
   put view_GetTemplateObject (viewName) into libraryObject
   if exists(libraryObject) is true then return libraryObject
   
   put menu_FindAssociatedViewNames(mTitle) into viewNames
   repeat for each line viewName in viewNames
      put view_GetTemplateObject (viewName) into libraryObject
      if exists(libraryObject) is true then
         put the view_Reference of libraryObject into viewReference
         if viewReference is not empty then
            return viewReference
         end if
      end if
   end repeat
   return empty
end menu_ViewReferenceFromTitle


--> Menu | Table
-
/*
For some reason "menu_Table"s are different from the more general "controller_Tables".
The reason is to be able to include formatting data for the display of menus.

"menu_Table"s are accessed by fetching the custom property menu_Table" of hte menu_Controller,
which by default refers to a stored  custom property the menu_Controller (usually the current card).
*/


--> Menu | Table | Utilities
-
function menu_ConstructTableLine mController, pigeon, mTitle, mLine, mFormatProp, mItemType, submenuProp, paramProp
   set the itemdelimiter to tab
   
   put mLine into item 1 of mTableLine
   put pigeon into item 2 of mTableLine
   if exists(mController) is false then
      -- could have a menu without a defined inserted Global menu?
      put empty into item 3 of mTableLine
   else
      put the rugged_ID of mController into item 3 of mTableLine
      -- put mController into item 3 of mTableLine
   end if
   put mTitle into item 4 of mTableLine
   put mFormatProp into item 5 of mTableLine
   put mItemType into item 6 of mTableLine
   put submenuProp into item 7 of mTableLine
   put paramProp into item 8 of mTableLine
   
   put menu_CleanLine (mLine) into mSendLine
   put mSendLine into item 9 of mTableLine
   
   return mTableLine
end menu_ConstructTableLine

command menu_DeconstructTableLine mTableLine, @mController, @pigeon, @mTitle, @mLine, @mFormatProp, @mItemType, @submenuProp, @paramProp, @mSendLine
   set the itemdelimiter to tab
   
   put item 1 of mTableLine into mLine
   put item 2 of mTableLine into pigeon
   put item 3 of mTableLine into mController
   put item 4 of mTableLine into mTitle
   put item 5 of mTableLine into mFormatProp
   put item 6 of mTableLine into mItemType
   put item 7 of mTableLine into submenuProp
   put item 8 of mTableLine into paramProp
   
   put item 9 of mTableLine into mSendLine
   if mSendLine is empty then
      put menu_CleanLine (mLine) into mSendLine -- for now while the mTables have not all been updated
      
      -- could update menu table here
   end if
end menu_DeconstructTableLine

function menu_CleanLine mLine  
   if char 1 to 2 of mLine is among the items of "!c,!n" then delete char 1 to 2 of mLine
   if char 1 of mLine = "(" then delete char 1 of mLine
   -- replace "(" with empty in someMenu	# only at start!
   -- put replacetext (mLine, "/.*", empty) into mLine
   
   -- accelerator keys
   set the itemdelimiter to "/"
   put item 1 of mLine into mSendLine
   
   if mLine is not mSendLine then breakpoint
   return mSendLine
end menu_CleanLine

function menu_CleanLines mLines
   -- this works on a whole table
   
   -- consider speeding up
   replace "!c" with empty in mLines
   replace "!n" with empty in mLines
   
   -- replace "(" with empty in someMenu	# only at start!
   put replacetext (mLines, "(?m)^\(", empty) into mLines
   put replacetext (mLines, "/.*", empty) into mLines
   
   return mLines
   
   return table_GetColumn (mLine, 1, "/")
end menu_CleanLines


--> Menu | Table | Command Lines
-
function menu_CommandToText handlerName
   -- was "menu_TextFromCommand"
   set the itemdelimiter to "_"
   -- put item 1 of handlerName into mPrefix
   put item 2 of handlerName into mSuffix
   put text_SplitCaps(mSuffix) into mLine
   return mLine
end menu_CommandToText

function menu_CommandFromText someText
   replace space with empty in someText
   return "menu_" & someText
end menu_CommandFromText


--> Menu | Action
-
command menu_SetText pMenuTitle, pClearMenuGlobal
   -- a simple utility (not same as old "menu_SetText")
   -- to allow changing "menu_PopUp pMenuTitle" to "menu_SetText pMenuTitle" in option buttons
   -- replace ",-," with CR in pMenuTitle -- so multiple titles can be put on one line
   replace comma with CR in pMenuTitle -- so multiple titles can be put on one line
   
   put the long id of the target into pTargetObject
   if pMenuTitle is empty then put the menu_ToolOrTitle of pTargetObject into pMenuTitle
   if pMenuTitle is empty then put "Menu" into pMenuTitle
   
   set the menu_TextFromTitle of pTargetObject to pMenuTitle
   put the result into mText
   if pClearMenuGlobal is true then menu_ClearTargetGlobals
   return mText
end menu_SetText

command menu_SelfEdit
   menu_Edit
end menu_SelfEdit

command menu_EditMenuScript pMenuTitle
   menu_Edit pMenuTitle
end menu_EditMenuScript


--> Menu | Initialise | Wrappers
-
command menu_MouseDown pMenuTitleTable, pTargetObject
   if exists(pTargetObject) is false then put the long id of the target into pTargetObject
   if pMenuTitleTable is empty then put the menu_Title of pTargetObject into pMenuTitleTable
   set the menu_TextFromTitle of pTargetObject to pMenuTitleTable
   put the result into mText
   if mText is empty then return "false"
end menu_MouseDown

command menu_InitialiseMouseDownGlobals @pMenuTopTitle, @pTargetObject, @mTopController
   menu_ClearTargetGlobals -- disable for easier debugging
   
   if exists(pTargetObject) is false then put the long id of the target into pTargetObject
   menu_SetTargetObject pTargetObject
   
   menu_InitialiseTopTitle pMenuTopTitle, pTargetObject
   menu_InitialiseTopController mTopController, pMenuTopTitle, pTargetObject
end menu_InitialiseMouseDownGlobals

command menu_InitialiseTopTitle @mTopTitle, targetObject
   -- used by front scripts
   if mTopTitle is empty then
      if the controlkey is "Down" then
         put the menu_ToolTitle of targetObject into mTopTitle
      else
         put the menu_Title of targetObject into mTopTitle
         -- menu_SearchViewHierarchy targetObject, mTopTitle, mController
      end if
   end if
   menu_SetTopTitle mTopTitle
end menu_InitialiseTopTitle

command menu_ClearTargetGlobals
   global gTemp_ActiveMenuArray
   put empty into gTemp_ActiveMenuArray
end menu_ClearTargetGlobals


--> Menu | Messages
-
function menu_ConstructPigeonHkey mPath, pigeon, mController, subTitlePath
   -- a recursive function
   global gTemp_ActiveMenuArray
   
   menu_DeconstructPath mPath, foundPath, foundParam, pigeon, mController, mTitlePath, mItemType
   -- menu_DeconstructPath subPath, subPigeon, subController, subTitlePath, subSubType
   put word 1 of subPigeon into subHandlerName
   if subSubType = "submenu" then
      return menu_ConstructPigeonHkey (mPath, subPigeon, subController, subTitlePath)
   else
      set the itemdelimiter to "/"
      put item -1 of subTitlePath into mTitle
      put the menu_Controller [mTitle] of mController into subController
   end if
   put hkey_Construct(subHandlerName, "c", subController) into hKey
   return hKey
end menu_ConstructPigeonHkey

command menu_DoGlobal mPath, globalMenuTitle, targetObject
   -- try not to use???
   global gTemp_ActiveMenuArray
   
   if exists(targetObject) is false then
      put menu_GetTargetObject() into targetObject
      if exists(targetObject) is false then
         breakpoint
         put the long id of the target into targetObject
      end if
   else
      menu_SetTargetObject targetObject
   end if
   
   try
      -- a crude way to load global gTemp_ActiveMenuArray 
      put menu_MatchGlobalController (globalMenuTitle) into mTopController
      
      -- get menu_GetText (globalMenuTitle, targetObject, mTopController)
      put menu_GetTable (globalMenuTitle, mTopController) into mTable
      local pTitlePath, pTextPath, pMenuTarget
      put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into insertedMenu
      
      menu_SendMessage mPath
      return the result
   catch someError
      put CR & the params after someError
      log_Error someError, "menu_DoGlobal", true
   end try
end menu_DoGlobal


--> Menu | Format
-
function menu_CleanMarks someMenu  
   replace "!c" with empty in someMenu
   replace "!n" with empty in someMenu
   -- replace "(" with empty in someMenu	# only at start!
   put replacetext(someMenu, "(?m)^\(", empty) into someMenu
   put replacetext(someMenu, "/.*", empty) into someMenu
end menu_CleanMarks

function menu_GetLineNum someMenuItem, someMenu
   set the itemdelimiter to tab
   repeat with lineNum = 1 to the number of lines of someMenu
      put item -1 of line lineNum of someMenu into lastItem
      
      if char 1 of lastItem = "!" then delete char 1 to 2 of lastItem
      if char 1 of lastItem = "(" then delete char 1 of lastItem
      if lastItem = someMenuItem then
         return lineNum
      end if
   end repeat
   return 0
   
   replace "/" with "\/" in someMenuItem
   put menu_CleanMarks (someMenu) into testMenu
   
   -- does not return the title with the greatest indent
   -- and so does not deal with titles which include subtitles of the same name ie colour names
   -- return outline_LineOffset(someMenuItem, testMenu)
   
   -- needs to be fast (repeats are)
   set the itemdelimiter to tab
   repeat with lineNum = the number of lines of someMenu down to 1
      get item -1 of line lineNum of someMenu
      if it = someMenuItem then
         return lineNum
      end if
   end repeat
   return 0
end menu_GetLineNum

command menu_SetCheckedItem someMenuItem, @someMenu, someBoolean
   put someBoolean is not false into someBoolean
   put menu_GetLineNum (someMenuItem, someMenu) into lineNum
   if lineNum = 0 then return someMenu
   
   put menu_SetCheckedLine(lineNum, someMenu, someBoolean) into someMenu
end menu_SetCheckedItem

command menu_SetDisabledItem someMenuItem, @someMenu, someBoolean
   put someBoolean is not false into someBoolean
   put menu_GetLineNum(someMenuItem, someMenu) into lineNum
   if lineNum = 0 then return someMenu
   
   put line lineNum of someMenu into menuLine
   if char 1 of word 1 of menuLine is "(" then delete char 1 of menuLine
   if someBoolean is true then put "(" before word 1 of menuLine
   put menuLine into line lineNum of someMenu
end menu_SetDisabledItem

function menu_CheckLineFromPath mPath, someMenu, someBoolean, pathDelim
   if pathDelim is empty then put "|" into pathDelim
   put outline_PathOffset (mPath, someMenu, pathDelim)into lineNum
   if lineNum = 0 then return someMenu
   
   put menu_SetCheckedLine(lineNum, someMenu, someBoolean) into newMenu
   return newMenu
end menu_CheckLineFromPath

function menu_SetCheckedLine lineNum, someMenuText, someBoolean
   -- replace (return & "!c") with (return & "!n") in 
   
   put line lineNum of someMenuText into menuLine
   if someBoolean is true then 
      put "c" into checkValue
   else 
      put "n" into checkValue
   end if
   
   if char 1 of word 1 of menuLine is "!" then
      if char 2 of word 1 of menuLine is "n" then
         put checkValue into char 2 of word 1 of menuLine 
      else if char 2 of word 1 of menuLine is "c" then
         put checkValue into char 2 of word 1 of menuLine 
      else
         -- put checkValue into char 2 of word 1 of menuLine -- not sure
      end if
   else
      put "!" & checkValue before of word 1 menuLine 
   end if    
   put menuLine into line lineNum of someMenuText
   return someMenuText
end menu_SetCheckedLine


--> Menu | MouseDown Hacks
-
/*
Does not seem to be used (very much), 
but was an important hack for globally intercepting other peoples mouseDown menus?
*/

command menu_AddMouseDownBlock someObject
   global gOPN_MenuArray
   
   put gOPN_MenuArray ["mouseDownBlocks"] into mouseDownBlocks
   get the mobile_Name of someObject
   line_Add it, mouseDownBlocks
   put mouseDownBlocks into gOPN_MenuArray ["mouseDownBlocks"]
   return gOPN_MenuArray ["mouseDownBlocks"]
end menu_AddMouseDownBlock

command menu_DeleteMouseDownBlock someObject
   global gOPN_MenuArray
   
   put gOPN_MenuArray ["mouseDownBlocks"] into mouseDownBlocks
   get the mobile_Name of someObject
   line_Delete it, mouseDownBlocks
   put mouseDownBlocks into gOPN_MenuArray ["mouseDownBlocks"]
   return gOPN_MenuArray ["mouseDownBlocks"]
end menu_DeleteMouseDownBlock

function menu_GetMouseDownBlocks
   global gOPN_MenuArray
   -- display_Array gOPN_MenuArray
   return gOPN_MenuArray ["mouseDownBlocks"]
end menu_GetMouseDownBlocks

command menu_SetMouseDownBlocks someObjects
   global gOPN_MenuArray
   
   put someObjects into gOPN_MenuArray ["mouseDownBlocks"]
end menu_SetMouseDownBlocks


--> Temp
-
command menu_ConvertArrayToRecord @mRecordArray
   if mRecordArray is not an array then return false
   set the itemdelimiter to tab
   put mRecordArray ["mTitle"] into item 1 of mRecord
   put mRecordArray ["mController"] into item 2 of mRecord
   put mRecordArray ["mBeforeLineNum"] into item 3 of mRecord
   put mRecordArray ["mPassMouseDown"] into item 4 of mRecord
   put mRecord into mRecordArray
   return true
end menu_ConvertArrayToRecord

command menu_DeconstructPluginRecord menuRecord, @menuController, @mTitle, @beforeLineNum, @passMouseDown
   -- was "menu_DeconstructNamedRecord"
   set the itemdelimiter to tab
   put item 1 of menuRecord into mTitle
   put item 2 of menuRecord into mController
   put item 3 of menuRecord into beforeLineNum
   put item 4 of menuRecord into passMouseDown
end menu_DeconstructPluginRecord

command menu_ExportMenuItemScript pigeon, mController
   put word 1 of pigeon into handlerName
   put hkey_Construct (handlerName, "c", mController) into hKey
   -- hkey_CreateTest hKey
end menu_ExportMenuItemScript

-- function menu_GetDefaultController mTitle, targetObject, pSearchScript
-- careful to avoid recursion 
-- called repeatedly on menu draw (consider speeding up by using caching / and / or using menu_TitleBurn)

-- check if it is global
set the itemdelimiter to "|"
put word 1 to -1 of item 1 of mTitle into mTitleStem
if mTitleStem is "Global" then
   menu_SearchGlobalObjectHierarchy mTitle, mController
   if exists (mController) is true then
      return mController
   end if
end if

-- here we allow sub stack cards to override defaults
put the menu_SubStackCard [mTitle] of targetObject into mController
if exists (mController) then return mController

-- here are the best guess defaults
put the view_Object of targetObject into someView
switch
   case word 1 of targetObject = "card"
      -- even when there is a backgound view
      -- the default controller of a menus card script is the card not the card_Object of the view
      return targetObject
   case exists(someView) is false
      -- the default menu_Controller of anything other than a view is the target itself
      return the rugged_Id of the target
   case mTitle is empty
      -- for views the default controller is the card
      -- can be unreliable in the case of backgound views (will take the card that is showing)
      put the card_Object of someView into cardObject
      return cardObject
   default
      -- if pSearchScript is true then 
      -- does not refer to default values via menu_Table but uses script
      -- used by menu_CreateOnCompile to construct menu_Tables (so the menu_Table is empty)
      -- else
      -- lets search for a possible controller which has the right mTitle
      -- we can use the menu_Table (a bit faster)
      menu_SearchViewHierarchy someView, mTitle, mController, pSearchScript
      if mController is not empty then return mController
      
      put the card_Object of someView into cardObject
      return cardObject
end switch
end menu_GetDefaultController

function menu_GetTableTitles mController
   put menu_GetDataArray (mController) into menuTableArray
   put keys(menuTableArray) into tableTitles
   return tableTitles
end menu_GetTableTitles

function menu_ModifierKeys toolModeKey
    -- was "menu_ToolMode"
    put toolModeKey & space into toolMode
    if the optionkey is "Down" then put "option" & space after toolMode
    if the shiftkey is "Down" then put "shift" & space after toolMode
    if the commandkey is "Down" then put "command" & space after toolMode
    if the controlkey is "Down" then put "control" & space after toolMode
    put word 1 to -1 of toolMode into toolMode
    return toolMode
end menu_ModifierKeys


--> Menu | Construct | Utilities
-
function menu_ConstructCaseStatement menuPath, someMenuButton
    -- was "menu_GetCaseStatement"
    
    set the itemdelimiter to "|"
    put the number of items of menuPath into maxItem
    if maxItem is 1 then
        return empty
    else
        if word 1 of someMenuButton is not "button" then return empty
        
        put the text of someMenuButton into menuText
        -- put the menuHistory of someMenuButton into osLineNum
        put outline_PathOffset(menuPath, menuText) into osLineNum
        put line osLineNum of menuText into test
        put outline_ExtractMainHierarchySection(osLineNum, menuText) into mainMenuSection
        put menu_StripDividerLines(mainMenuSection) into mainMenuSection
        put outline_ToPathIndex(mainMenuSection) into subSectionPaths
        delete line 1 of subSectionPaths
        
        put "    " into indentSpacer
        put indentSpacer & "switch subMenuPath" into caseStatement
        repeat for each line subMenuPath in subSectionPaths
            delete item 1 of subMenuPath
            put cr & indentSpacer & "case" && kwote(subMenuPath) after caseStatement
            put cr & indentSpacer & indentSpacer after caseStatement
            put cr & indentSpacer & indentSpacer & "break" after caseStatement
        end repeat
        delete last line of caseStatement
        put cr & indentSpacer & "default" after caseStatement
        put cr & indentSpacer after caseStatement
        put cr & indentSpacer & "end switch" after caseStatement
        return caseStatement
    end if
end menu_ConstructCaseStatement

function menu_GetToggleSubmenu subMenuProperty, menuCommandName, menuController
    put the script_Command [menuCommandName] of menuController into someHandler
    put script_ExtractCaseConditions(someHandler) into someMenu
    line_Delete "default", someMenu
    
    put the subMenuProperty of menuController into popertyValue
    if popertyValue is empty then
        return someMenu
    else
        menu_SetCheckedItem popertyValue, someMenu, true
        return someMenu
        -- return menu_SetCheckedItem(popertyValue, someMenu, true)
    end if
end menu_GetToggleSubmenu


--> Menu | Sections
-
on menu_ReplaceSubOfButton sectionNameList, newSubMenu, btnName
    /*
    Given a list of section titles,
    This command replaces a (sub) section of a buttons menu text.
    */
    
    if btnName is empty then 
        put the long id of the target into buttonMenu
    else
        put the long id of btn btnName into buttonMenu
    end if
    
    put the text of buttonMenu into oldMenu
    put makeContainer(newSubMenu) into newSubMenu
    put menu_ReplaceSection(sectionNameList, oldMenu, newSubMenu) into newMenu
    set the text of buttonMenu to newMenu
end menu_ReplaceSubOfButton

function menu_ReplaceSection sectionNameList, oldMenu, newSubMenu
    if newSubMenu is empty then return oldMenu
     
    repeat for each item sectionName in sectionNameList
        put outline_LineOffset(sectionName, oldMenu) into lineNum
        put sectionName & return & outline_IncreaseIndent(newSubMenu, 1) into newMenuSection
        put outline_ReplaceSection(lineNum, oldMenu, newMenuSection, oldOsLength) into newMenu
        put newMenu into oldMenu
    end repeat
    return newMenu
end menu_ReplaceSection

on menu_AddToSection subMenu, mainMenu, btnObject
    put the text of btnObject into myMenu
    put outline_LineOffset(mainMenu, myMenu) into lineNum
     
    put outline_ExtractSection(lineNum, myMenu) into oldSimplMenu
    put outline_LineOffset(line 1 of newOS, oldSimplMenu) into osLineNum
    -- <patch> for bug in outline_ReplaceSection </patch>
    if osLineNum is 0 then
        put oldSimplMenu & return & outline_IncreaseIndent(subMenu, 1) into newSimplMenu
    else
        put outline_ReplaceSection(osLineNum, oldSimplMenu, subMenu, oldOsLength) into newSimplMenu
    end if
     
    put outline_ReplaceSection(lineNum, myMenu, newSimplMenu, oldOsLength) into newMenu
    set the text of btnObject to newMenu
end menu_AddToSection


--> Menu | Sections | Dividers
-
function menu_GetDividerSection dividerTitle, someMenu
    put menu_GetDividerArray(someMenu) into dividerArray
    put dividerArray[dividerTitle] into dividerInfo
    if dividerInfo is empty then return empty
    _menu_DeconstructDividerInfo dividerInfo, startLineNum, endLineNum, dividerMenuText
    return dividerMenuText
end menu_GetDividerSection

function menu_DeleteDividerSection dividerTitle, someMenu
    put menu_GetDividerArray(someMenu) into dividerArray
    put dividerArray[dividerTitle] into dividerInfo
    if dividerInfo is empty then
        return someMenu
    else
        _menu_DeconstructDividerInfo dividerInfo, startLineNum, endLineNum, dividerMenuText
        delete line startLineNum to endLineNum of someMenu
        return someMenu
    end if
end menu_DeleteDividerSection

function menu_ReplaceDividerSection dividerTitle, someMenu, newMenuSection
    put menu_GetDividerArray(someMenu) into dividerArray
    put dividerArray[dividerTitle] into dividerInfo
    if dividerInfo is empty then
        -- return someMenu
        
        -- add to end
        put dividerTitle & cr & newMenuSection into newPara
        
        if someMenu is empty then
            put newPara into newMenu
        else
            put someMenu & cr & "-" & cr & newPara into newMenu
        end if
        return newMenu
    else
        _menu_DeconstructDividerInfo dividerInfo, startLineNum, endLineNum, dividerMenuText
        put newMenuSection into line (startLineNum+1) to (endLineNum - 1) of someMenu
        return someMenu
    end if
end menu_ReplaceDividerSection

function menu_DeleteSection sectionList, someMenu
    -- put someMenu
    put menu_ConstructDividerIndex(someMenu) into dividerIndex
    if dividerIndex is empty then return someMenu
     
    put 0 into lessDeleted
    repeat with itemNum = the number of items of sectionList down to 1
        put item itemNum of sectionList into sectionNum
        if sectionNum = 1 then
            put 1 into start_DeleteLineNum
        else
            put line (sectionNum - 1) of dividerIndex into start_DividerLineNum
            put start_DividerLineNum + 1 - lessDeleted into start_DeleteLineNum
        end if
         
        put line sectionNum of dividerIndex into end_DividerLineNum
        if end_DividerLineNum = empty then
            put the number of lines of someMenu - lessDeleted into end_DeleteLineNum
        else
            put line sectionNum of dividerIndex into end_DividerLineNum
            put end_DividerLineNum - lessDeleted into end_DeleteLineNum
        end if
         
        delete line start_DeleteLineNum to end_DeleteLineNum of someMenu
    end repeat
    return someMenu
end menu_DeleteSection

function menu_GetDividerArray someMenu
    set the wholematches to true
    put empty into dividerIndex
    put 0 into skipLines
    repeat
        get lineoffset("-", someMenu, skipLines)
        if it = 0 then exit repeat
        put it + skipLines into lineNum
        
        put lineNum & return after dividerIndex
        put lineNum into skipLines
    end repeat
    put the number of lines of someMenu + 1 into lastLineNum
    put lastLineNum after dividerIndex
    
    put 1 into startSectionNum
    repeat with lineNum = 1 to the number of lines of dividerIndex
        put line lineNum of dividerIndex into endSectionNum
        
        put line startSectionNum of someMenu into dividerTitle
        put line startSectionNum to (endSectionNum - 1) of someMenu into dividerText
        put startSectionNum && endSectionNum & return & dividerText into dividerTitleArray[dividerTitle]
         
        put endSectionNum + 1 into startSectionNum
    end repeat
    return dividerTitleArray
end menu_GetDividerArray

function menu_ConstructDividerIndex someMenu
    set the wholematches to true
    put empty into dividerIndex
    put 0 into skipLines
    repeat
        get lineoffset("-", someMenu, skipLines)
        if it = 0 then exit repeat
         
        put it + skipLines into lineNum
        put lineNum & return after dividerIndex
        put lineNum into skipLines
    end repeat
    delete last char of dividerIndex
    return dividerIndex
end menu_ConstructDividerIndex

function menu_StripDividerLines menuText
    put menu_CleanMarks(menuText) into cleanMenu
    put 0 into menuLineNum
    repeat
        put lineoffset("-", cleanMenu, menuLineNum) into lineNum
        if lineNum is 0 then return menuText
        put lineNum + menuLineNum into menuLineNum
        delete line menuLineNum of cleanMenu
        delete line menuLineNum of menuText
    end repeat
end menu_StripDividerLines


--> Menu | Format
-
function menu_ConstructHtmlOutline mText
    repeat for each line someLine in mText
        if char -2 of word -1 of someLine is "/" then
            put "" into char -2 to -1 of someLine
        end if
        
        if char 1 of word 1 of someLine is "(" then
            delete char 1 of word 1 of someLine
            menu_ConvertMarksToHtml someLine
            put xml_Tag(someLine, "i") into someLine
        else
            menu_ConvertMarksToHtml someLine
        end if
         
        if matchchunk(someLine, ".*(&.).*", startChar, endChar) then
            -- answer char startChar to endChar of someLine
            put "</u>" after char endChar of someLine
            put "<u>" into char startChar to startChar of someLine
        end if
        
        put someLine & CR after newHtmlOutline
    end repeat
    return word 1 to -1 of newHtmlOutline
end menu_ConstructHtmlOutline

on menu_ConvertMarksToHtml @someLine
    switch char 1 to 2 word 1 someLine
        case "!c"
            put "" into char 1 to 2 word 1 someLine
            break
        case "!n"
            put "" into char 1 to 2 word 1 someLine
            break
        case "!u"
            put "" into char 1 to 2 word 1 someLine
            break
    end switch
end menu_ConvertMarksToHtml


--> Menu | Format | Replace
-
function menu_ReplaceItem someMenuPath, newItem, someMenu
    -- way slower than needed!
    
    replace "|" with return in someMenuPath
    put menu_CleanMarks(someMenu) into cleanMenu
    put outline_PathOffset(someMenuPath, cleanMenu) into chosenLineNum
    if chosenLineNum = 0 then return someMenu
    put newItem into line chosenLineNum of someMenu
    return someMenu
end menu_ReplaceItem


--> Menu | Format | Check and uncheck
-
on menu_SetChecked someMenuItem, someBoolean, someObject
    -- works for main and one indented menu
    if someObject is empty then put the long id of the target into someObject
    put the menu_Text of someObject into someMenu
    menu_SetCheckedItem someMenuItem, someMenu, someBoolean
    set the menu_Text of someObject to someMenu
    return someMenu
end menu_SetChecked

function menu_GetChecked someMenuItem, someObject
   -- works for main and one indented menu
   if someObject is empty then put the long id of the target into someObject
   put the menu_Text of someObject into someMenu
   put menu_GetCheckedItem(someMenuItem, someMenu) into someBoolean
   return someBoolean
end menu_GetChecked

function menu_GetCheckedItem someMenuItem, someMenu
   -- was menu_CheckItem
   put menu_GetLineNum (someMenuItem, someMenu) into lineNum
   if lineNum = 0 then return false
   put menu_GetCheckedLine (lineNum, someMenu) into isChecked
   return isChecked
end menu_GetCheckedItem

function menu_GetCheckedLine lineNum, someMenuText
    put line lineNum of someMenuText into menuLine
    return menu_LineIsChecked(menuLine)
end menu_GetCheckedLine

function menu_LineIsChecked menuLine
   put word 1 to -1 of menuLine into menuLine
    if char 1 of menuLine is "!" then
        if char 2  of menuLine is "n" then
            return false
        else if char 2  of menuLine is "c" then
            return true
        else
            return false
        end if
    else
        return false
    end if    
end menu_LineIsChecked


--> Menu | Format | Toggles
-
function menu_CheckOne chosenLineNum, someMenu
    repeat with osLineNum = 1 to the number of lines of someMenu
        if osLineNum is chosenLineNum then
            put menu_SetCheckedLine(chosenLineNum, someMenu, true) into someMenu
        else
            put menu_SetCheckedLine(osLineNum, someMenu, false) into someMenu
        end if
    end repeat
    return someMenu
end menu_CheckOne

on menu_RadioCheck someMenuPath, someObject
    -- way slower than needed!
    
    if someObject is empty then put the long id of the target into someObject
    put the text of someObject into someMenu
     
    put menu_CleanMarks(someMenu) into cleanMenu
    put outline_PathOffset(someMenuPath, cleanMenu, "|") into chosenLineNum
    if chosenLineNum = 0 then return empty
    
    if menu_GetCheckedLine(chosenLineNum, someMenu) is false then
        put outline_LineParent(chosenLineNum, cleanMenu, startSection) into parentTitle
        put outline_NextSameLevel(startSection, cleanMenu) into endSection
        repeat with osLineNum = (startSection + 1) to (endSection- 1)
            if osLineNum is chosenLineNum then
                put menu_SetCheckedLine(chosenLineNum, someMenu, true) into someMenu
            else
                put menu_SetCheckedLine(osLineNum, someMenu, false) into someMenu
            end if
        end repeat
        set the menu_Text of someObject to someMenu
        -- put someMenu
    end if
end menu_RadioCheck

on menu_ToggledChecked someMenuItem, someObject
    -- was a function "menu_ReturnToggledChecked"
    -- works for main and one indented menu
    if someObject is empty then put the long id of the target into someObject
    
    put the menu_Text of someObject into someMenu
    put menu_GetToggleChecked(someMenuItem, someMenu, isChecked) into newMenu
    set the menu_Text of someObject to newMenu
    return isChecked
end menu_ToggledChecked

function menu_GetToggleChecked someMenuItem, someMenu, @isChecked
    -- was "menu_ToggleMainMenu"
    if someMenuItem contains "|" then
        put the itemdelimiter into oDelim
        set the itemdelimiter to "|"
        put item 1 of someMenuItem into mainMenu
        put item 2 of someMenuItem into subMenu
        put line_FindInIndex(mainMenu, someMenu) into startOsLineNum
        
        put 0 into checkedLine
        set the itemdelimiter to tab
        repeat with lineNum = (startOsLineNum + 1) to the number of lines of someMenu
            put line lineNum of someMenu into someLine
            if char 1 of someLine is tab then
                if item 2 of someLine is subMenu then
                    put "!c" before line lineNum of someMenu
                else
                    next repeat
                end if
            else
                put char 1 to 3 of line lineNum of someMenu into checkChars
                if checkChars is ("!c" & tab) then
                    -- put lineNum into checkedLine
                    delete char 1 to 2 of line lineNum of someMenu
                else
                    exit repeat
                end if
            end if
        end repeat
    else  
        put someMenuItem into plainLine
        put "!c" & someMenuItem into checkedLine 
         
        put lineoffset(checkedLine, someMenu) into lineNum
        if lineNum = 0 then
            put lineoffset(plainLine, someMenu) into lineNum
            if lineNum = 0 then
                return someMenu -- menuItem not present
            else
                put true into isChecked
                put checkedLine into line lineNum of someMenu
            end if
        else
            put false into isChecked
            put plainLine into line lineNum of someMenu
        end if
    end if
    return someMenu
end menu_GetToggleChecked

function menu_ToggleSubMenu someMenuItem, isChecked, someMenu
    -- used bi wiki_Storm
    put tab & someMenuItem into plainLine
    put "!c" & tab & someMenuItem into checkedLine
     
    if isChecked is true then
        put lineoffset(checkedLine, someMenu) into lineNum
        put plainLine into line lineNum of someMenu
    else
        put lineoffset(plainLine, someMenu) into lineNum
        put checkedLine into line lineNum of someMenu
    end if
    return someMenu
end menu_ToggleSubMenu


--> Menu | Creation
-
on menu_SetTemplateButton newMenuName, newMenuItems
    if newMenuItems is empty then put "Item 1" into newMenuItems
    
    -- basic properties    
    set the name of the templatebutton to newMenuName
    set the label of the templatebutton to newMenuName
    set the text of the templatebutton to newMenuItems
     
    set the lockloc of the templatebutton to true
    set the showborder of the templatebutton to false
    
    -- set some properties to make the button behave as a menu
    set the style of the templatebutton to "menu"
    set the menumode of the templatebutton to "pulldown"
    set the opaque of the templatebutton to true
    set the autohilite of the templatebutton to true
    set the hiliteborder of the templatebutton to true
    set the armborder of the templatebutton to true
    set the traversalon of the templatebutton to false
    set the showborder of the templatebutton to false
end menu_SetTemplateButton


--> Menu | Search and Find
-
/*
This suite is a set of experiments in searching the Global Menu hierarchy, and the message path, 
to automatically find an appropriate menu. The general experience was this was cool, but prone to mistakes.
They need tidying.
*/

getprop menu_ScriptTitles
   put the long id of the target into mController
   put the script of mController into someScript
   put script_ExtractMenuSuiteTitles (someScript) into scriptMenuTitles
   return scriptMenuTitles
end menu_ScriptTitles

command menu_FindTitle mTitle, targetObject, @mController, pWhichHierarchy
   -- put the view_Hierarchy of the target into testControllers
   if pWhichHierarchy is empty then put "stack" into pWhichHierarchy -- or maybe use "development" as default ?
   put the hkey_SearchHierarchy [pWhichHierarchy] of targetObject into testControllers
   
   set the itemdelimiter to "|"
   set the wholematches to true
   repeat for each line mController in testControllers
      put menu_CheckTitleController (mTitle, mController) into isThere
      if isThere is true then return true
   end repeat
   put empty into mController
   return false
end menu_FindTitle

setprop menu_HierarchyTitle [whichHierarchy] mTitle
   put the long id of the target into targetObject
   menu_FindTitle mTitle, targetObject, mController, whichHierarchy
   if the result is false then
      -- can't find mTitle in hierarchy
      set the menu_Title of targetObject to empty
      set the menu_Controller [mTitle] of targetObject to empty
      return false
   else
      set the menu_Title of targetObject to mTitle
      set the menu_Controller [mTitle] of targetObject to mController
      return true
   end if
end menu_HierarchyTitle


--> Private
-
function script_ParamToHandlerName customParam
   put word 1 of customParam into customParam
   put tolower(char 1 of customParam) into char 1 of customParam
   
   repeat with charNum = 1 to the number of chars of customParam
      if text_StartsWithCaps(char charNum of customParam) is true then
         put "_" before char charNum of customParam
         return customParam
      end if
   end repeat
   return customParam
end script_ParamToHandlerName

private command _menu_DeconstructDividerInfo dividerInfo, @startLineNum, @endLineNum, @dividerMenuText
    put line 1 of dividerInfo into lineNumInfo
    put word 1 of lineNumInfo into startLineNum
    put word 2 of lineNumInfo into endLineNum
    
    put dividerInfo into dividerMenuText
    delete line 1 of dividerMenuText
end _menu_DeconstructDividerInfo

function param_IsObject someParam
   if char -4 to -1 of someParam = "View" then return true
   if char -5 to -1 of someParam = "Field" then return true
   if char -6 to -1 of someParam is among the items of "Object,Target,Button" then return true
   return false
   
   get "targetObject,treeField,treeView,mTarget,menuTarget,someView,someObject,someField,someButton,menuButton,cardObject,stackObject"
   set the wholematches to true
   return someParam is among the items of it
   
   repeat for each item testString in "object,target,view,field,button,card,stack"
      if someParam contains testString then return true
   end repeat
   return false
end param_IsObject

function param_IsBoolean customParam
   return customParam is among the items of "boolean,someBoolean,isBoolean"
end param_IsBoolean

function object_IsType mTarget, mTargetType
   switch
      case mTargetType = empty
         return true
      case mTargetType = "view"
         if exists(mTarget) is false then return false
         return the object_IsView of mTarget
      case mTargetType contains "|"
         if exists(mTarget) is false then return false
         put mTargetType into viewName
         return the view_IsClass [viewName] of mTarget
      default
         -- mTargetType = "field,button,graphic,scrollbar,player,image,group,background,card,stack
         return word 1 of mTarget = mTargetType
   end switch
end object_IsType

function script_OrderedMenuTitles someScript
   put script_MenuToolModeArray(someScript) into menuToolModeArray
   put menuToolModeArray ["OrderedMenuTitles"] into menuTitles
   return menuTitles
end script_OrderedMenuTitles


--> Private ?
-
command addToMenuActiveArray mPath, mTitlePath, pigeon, mController, mView, mItemType, pMenuTarget
   if mPath is empty then return empty -- an insert?
   global gTemp_ActiveMenuArray
   
   if mItemType is among the items of "insert" then
      -- may need to disable a submenu, and need gTemp_ActiveMenuArray to work out mTarget
      return empty
   end if
   if pMenuTarget is not empty then
      menu_SetItemTargetOveride mPath, pMenuTarget
   end if
   
   -- lets set work in progress mPath, mTitlePath so that submenus etc can use them to automatically gather context
   menu_SetTitlePath mTitlePath
   menu_SetSentPath mPath
   
   put pigeon into gTemp_ActiveMenuArray ["mPath"][mPath]["pigeon"]
   put mController into gTemp_ActiveMenuArray ["mPath"][mPath]["mController"]
   put mItemType into gTemp_ActiveMenuArray ["mPath"][mPath]["mItemType"]
   put mTitlePath into gTemp_ActiveMenuArray ["mPath"][mPath]["mTitlePath"]
   
   put mController into gTemp_ActiveMenuArray ["mTitlePath"][mTitlePath]["mController"]
   return empty
   
   put gTemp_ActiveMenuArray ["mTitlePath"][mTitlePath]["mPath"] into mPaths
   line_Insert mPath, mPaths
   put mPaths into gTemp_ActiveMenuArray ["mTitlePath"][mTitlePath]["mPath"]
   
   put gTemp_ActiveMenuArray ["mTitlePath"][mTitlePath]["pigeon"] into menuCommands
   line_Insert pigeon, menuCommands
   put menuCommands into gTemp_ActiveMenuArray ["mTitlePath"][mTitlePath]["pigeon"]
end addToMenuActiveArray

-- function _GetDefaultMenuTarget mPath, mTitlePath, targetObject
-- ignoreCall:  menu_Target,g
-- default steps below are needed when menu_Target in the controller is not specified

-- a default can be dynamic and defined in the view using a "getprop menu_Target" handler
put the menu_Target [mTitlePath] of targetObject into mTarget
-- if exists(mTarget) then return addThenReturn (mTarget)
if mTarget is not empty then return addThenReturn (mTarget) -- could be something other than an object

/*
-- this authoring version guesses a default based on mPath (from which it gets mTitles)
-- look at mTitles associated with mPath and then work out for views with corresponding names.

put menu_TitlePathFromPath (mPath) into mTitlePath
put menu_TitlePathToView (mTitlePath) into viewNames
if viewNames is not empty then
   -- this looks for the top view
   put the card_View [viewNames] of targetObject into linkedView
   if exists(linkedView) is true then
      return linkedView
   end if
end if
*/

-- Finally if all else fails it returns the view or the target object.
put the view_Object of targetObject into someView
if exists(someView) is false then put targetObject into someView
return someView
end _GetDefaultMenuTarget

function addThenReturn mTarget
   -- simply adds mTarget to global before returning
   global gTemp_ActiveMenuArray
   if exists (mTarget) then
      put the mobile_Name of mTarget into gTemp_ActiveMenuArray ["top"]["mTarget"]
   else
      put mTarget into gTemp_ActiveMenuArray ["top"]["mTarget"]
   end if
   return mTarget
end addThenReturn

command extractInsertedTitle mCommand, mController, someScript, @insertedMenuTitle, @customControllerParam, @dynamicTitleProp, @mLine, @pigeon, mItemType
   -- ignoreCall: mCommand,c
   
   if mItemType = "insert" then -- inserted version
      -- this is a single menu script item!
      -- should be the same structure as an mvc controller
      -- "Global | Library | Menu,menu_StartupLibrary sillyChoice, mTarget"
      -- with the first item refering to the controller object (or named shortcut), and the second the command
      
      try
         send mCommand to mController
         put the result into insertedInfo
      catch someError -- often a compile error
         return empty
      end try
      
      put item 1 of insertedInfo into insertedMenuTitle
      put item 2 to -1 of insertedInfo into pigeon
      put menu_CommandToText (word 1 of pigeon) into mLine
      
      put empty into customControllerParam
      put empty into dynamicTitleProp
   else if mItemType = "submenu" then -- submenu version
      
      put empty into mLine
      put script_GetCommand (mCommand, someScript) into menuHandler
      
      set the wholematches to true
      put wordoffset ("menu_DoSub", menuHandler) into wordNum
      if wordNum = 0 then
         -- now lets try the return technique used by "insert"
         try
            send mCommand to mController
            put the result into insertedInfo
            put item 1 of insertedInfo into insertedMenuTitle
            put item 2 of insertedInfo into customControllerParam
         catch someError -- often a compile error
            put empty into insertedMenuTitle
            put empty into customControllerParam
            return empty
         end try
      else
         delete word 1 to wordNum of menuHandler
         put token 1 of line 1 of menuHandler into insertedMenuTitle
         put token 3 of line 1 of menuHandler into customControllerParam
      end if
      
      -- no longer stores pigeon to send, but calculates from subMenuTitle + scriptObject
      -- put mCommand && "subMenuPath, mTarget" into pigeon
      put empty into pigeon
      put empty into dynamicTitleProp
   end if
end extractInsertedTitle


--> Menu | Error
-
function error_CheckMenuController mController
   if exists (mController) is false then
      put "menu_ConvertTable:  mController" && kwote(mController) && "does not exist" into someError
      -- log_Error someError, "menu_ConvertTable", false
      return false
   else
      return true
   end if
end error_CheckMenuController

command error_CheckDisabled mController, mTarget, mTitlePath, mTableLine, someError
   put the mobile_Name of mController into mobileController
   if exists(mTarget) then put the mobile_Name of mTarget into mTarget
   
   put mFormatProp & "[" & mTarget & "]" into mobileFormatProperty
   put "disabled menu format Error:" && mobileFormatProperty & CR after errorComment
   put "of mController:" && mobileController & CR after errorComment
   
   -- put "for mTitle:" && kwote(mTitle) & CR after errorComment
   put "for mTitlePath:" && kwote (mTitlePath) & CR after errorComment
   put CR after errorComment
   
   put mTableLine & CR after errorComment
   put CR after errorComment
   
   put someError & CR after errorComment
   log_Error errorComment, "menu_ConvertTable", true
end error_CheckDisabled

command error_LogBoolean mController, mTableLine, mTitle, mTitlePath, mLine, tError
   put merge("Error: fetching boolean custom property '[[paramProperty]]' of mController") & CR into someError
   put CR after someError
   if exists(someError) then
      put "mController:" && the mobile_Name of mController after someError
   else
      put "mController:" && mController after someError
   end if
   put "mTableLine:" && mTableLine & CR after someError
   put "mTitle:" && mTitle & CR after someError
   put "mTitlePath:" && mTitlePath & CR after someError
   put "mLine:" && mLine & CR after someError
   put CR after someError
   put tError & CR after someError
   log_Error someError, "menu_ConvertTable", true, true
end error_LogBoolean

command error_LogCustomMenuItems mController, submenuProperty, someError
   put "mTopTitle:" && menu_GetTopTitle() & CR into errorText
   put "Error: with submenu property handler" && kwote (submenuProperty) & CR after errorText
   put "of mController:" && the mobile_Name of mController & CR after errorText
   
   put CR & CR & someError after errorText
   
   display_Lines errorText, "menu_FetchCustomMenuItems error", "Global | Menu | Error | Menu"
   put the result into displayView
   put token 1 of submenuProperty & comma & "g" & comma & mController  into hKey
   set the hkey_Error of displayView to hKey
   -- log_Error errorText, "menu_FetchCustomMenuItems"
end error_LogCustomMenuItems

command error_CheckSub paramProp, mController, paramProperty, mTarget, tError
   put "Error: with menu property handler" && kwote(paramProp) & CR after errorInfo
   put "mController:" && mController & CR after errorInfo
   put "paramProperty:" && paramProperty & CR after errorInfo
   put "mTarget:" && mTarget & CR after errorInfo
   log_Error errorInfo, "menu_CheckSub", true, true
end error_CheckSub

command error_InitialseTopController mTopController, targetObject
   if exists(mTopController) is false then
      put menu_GetTopTitle() into mTopTitle
      put merge("mTopTitle: '[[mTopTitle]]'") & CR after someError
      put "put the menu_LocalController [mTopTitle] of targetObject into mTopController" & CR after someError
      put "targetObject:" && the mobile_Name of targetObject & CR after someError
      
      log_Error someError, ("menu_InitialiseTopController: mController does not exist for" && mTopTitle), true
      put targetObject into mTopController
   end if
end error_InitialseTopController
