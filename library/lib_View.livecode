script "lib_View"
--> MetaData
-
license: GPLv3
name: lib_View
type: script library
version: 0.8


--> View | Props | Back Property
-
/*
These handlers implement back behavior like properties that can be overidden by props placed higher up the hierarchy
*/

getprop back_Property [propName]
   put the long id of the target into tObject
   
   put the customproperties of tObject into propArray
   put propArray [propName] into titlePosistion
   if titlePosistion is empty then
      put object_GetOwner (tObject) into tOwner
      put the propName of tOwner into propValue
   end if
   return propValue
end back_Property

setprop back_Property [propName] someValue
   -- place in behavior (references "me")
   set the view_DisplayProperty [propName] of the target to someValue
   -- dispatch "LayoutControl" to me -- changes the target (allowing lower level control use)
   return the result
end back_Property


--> View | Swap
-
getprop title_ViewName
   put the title_View of the target into titleView
   put the view_Name of titleView into vName
   return vName
end title_ViewName
 
setprop title_ViewName vName
   put the title_View of the target into titleView
   set the view_Swap of titleView to vName
   return the result
end title_ViewName

getprop body_ViewName
   put the body_View of the target into bodyView
   put the view_Name of bodyView into vName
   return vName
end body_ViewName
 
setprop body_ViewName vName
   put the body_View of the target into bodyView
   set the view_Swap of bodyView to vName
   return the result
end body_ViewName

--> View | Hierarchy
-
getprop object_Views
   local vObjects
   put the long id of the target into targetObject
   
   put the view_Name of targetObject into vName
   if vName is not empty then put targetObject & CR after vObjects
   
   repeat with cNum = 1 to the number of controls of targetObject
      put the long id of control cNum of targetObject into innerObject
      put the view_Name of innerObject into vName
      if vName is not empty then
         put innerObject & CR after vObjects
      end if
   end repeat
   delete char -1 of vObjects
   return vObjects
end object_Views

getprop object_ViewNames
   local objectViews
   put the long id of the target into targetObject
   
   put the view_Name of targetObject into vName
   if vName is not empty then put vName & CR after vNames
   
   repeat with cNum = 1 to the number of controls of targetObject
      put the view_Name of control cNum of targetObject into vName
      if vName is not empty then
         put vName & CR after vNames
      end if
   end repeat
   delete char -1 of vNames
   return vNames
end object_ViewNames

getprop view_Object
   return the view_AboveTarget of the target
end view_Object

getprop view_OrCard
   -- searches for a view in the objects hierarchy
   -- considers a view to be either something markey with either:
   -- uRIP "view", a group with the selectGroupedControls on, or the card
   put the long id of the target into targetObject
   repeat
      switch word 1 of targetObject
         case "card"
            return targetObject
         case "stack"
            return empty
         case empty
            return empty
         default
            if the uRIP ["type"] of targetObject is "view" then return targetObject
            if word 1 of targetObject = "group" and the selectGroupedControls of targetObject then return targetObject 
            
            delete word 1 to 4 of targetObject -- does not work for substacks
      end switch
   end repeat
end view_OrCard

getprop locked_View
   put the view_Object of the target into targetView
   if exists(targetView) is false then return false
   
   repeat
      put the view_AboveTarget of the owner of targetView into viewAbove
      if exists(viewAbove) is false or word 1 of viewAbove = "card" then exit repeat
      if the selectGroupedControls of viewAbove is false then
         -- view above does not allow visible inner views
         put viewAbove into targetView
      else
         exit repeat
      end if
   end repeat
   return targetView
end locked_View

function view_GetStackBackgroundID vName, stackName
   put the backgroundids of stack stackName into bgIDs
   repeat for each line bgID in bgIDs
      put the view_Name of bg id bgID of stack stackName into testViewName
      if testViewName is empty then next repeat
      
      if testViewName = vName then
         return bgID
      end if
   end repeat
   return empty
end view_GetStackBackgroundID

getprop view_AboveTarget
   -- use when you don't want a "view_Object" to trap things
   -- like when a datagrid is within a view object
   -- works even for datagrids, and objects without "view_Object" handlers
   put the long id of the target into targetObject
   repeat
      if the uRIP ["type"] of targetObject is "view" then return targetObject
      if word 1 of targetObject = "group" and the selectGroupedControls of targetObject then return targetObject 
      if word 1 of targetObject = "stack" or targetObject = empty then return empty
      
      delete word 1 to 4 of targetObject -- does not work for substacks
   end repeat
end view_AboveTarget

getprop view_TopObject
   -- which is the top (highest) someView in the current layout
   put the long id of the target into testGroup
   put view_ConstructHierarchy(testGroup) into viewHierarchy
   return line 1 of viewHierarchy
end view_TopObject

getprop view_Parent
   -- was "view_Above" and "view_Owner"
   put the long id of the target into someObject
   if word 1 of someObject is "stack" then
      -- a stack cant be a view?
      return empty
   else
      delete word 1 to 4 of someObject
      put the view_Object of someObject into someView
      return someView
   end if
end view_Parent

getprop view_HierarchyPath
   /*
   ??? not really working as a class hierarchy!
   A path is constructed based on the object hierarchy of the views.
   */
   
   put the long id of the target into someView
   put view_ConstructHierarchy(someView) into viewHierarchy
   
   set the itemdelimiter to "|"
   put line -1 of viewHierarchy into bottomView
   put item -1 of the uRIP ["name"] of bottomView into bottomViewShortName
   
   put "View" into nestedPath
   repeat for each line hierarchyView in viewHierarchy
      put the uRIP ["name"] of hierarchyView into hierarchyViewPath
      if item 1 of hierarchyViewPath is "View" then delete item 1 of hierarchyViewPath
      delete item -1 of hierarchyViewPath
      if hierarchyViewPath is not empty then
         put "|" & hierarchyViewPath after nestedPath
      end if
   end repeat
   get nestedPath & "|" & bottomViewShortName
   return it
end view_HierarchyPath

getprop view_Hierarchy
   put the long id of the target into targetObject
   put view_ConstructHierarchy (targetObject) into viewObjects
   return viewObjects
end view_Hierarchy

function view_ConstructHierarchy targetObject
   -- ignoreCall: view_Object,g
   local groupHierarchy
   repeat
      if word 1 of targetObject is "card" then
         -- background groups can cause infinite loops
         -- so have to stop hierarchy check at the card level
         -- which means this will not work for views etc which are at the card level or above!
         return word 1 to -1 of groupHierarchy
      else
         put the view_Object of targetObject into someView
         if someView is empty then return word 1 to -1 of groupHierarchy
         
         put someView & CR before groupHierarchy
         
         put someView into targetObject
         delete word 1 to 4 of targetObject
         if targetObject is empty then return word 1 to -1 of groupHierarchy
      end if
   end repeat
   return groupHierarchy
end view_ConstructHierarchy


--> View | Hierarchy | Children
-
/*
Returns the nested views referenced by the containing views script.
This default script can be over-ridden by a local script in the view.
Depends on a well structured script using a "View | Object | Children" script suite
to list the getprop references to the child views.
*/

getprop view_Children
   put the view_Object of the target into someView
   if exists(someView) is false then return empty
   
   put the view_ChildReferences of someView into childReferences
   put empty into viewChildren
   repeat for each line childReference in childReferences
      put the childReference of someView & CR after viewChildren
   end repeat
   delete char -1 of viewChildren
   return viewChildren
end view_Children

setprop view_Children newViews
   put view_GetTemplateObject ("View|Layout|Placeholder") into placeHolderView
   
   put the view_Children of the target into viewChildren
   repeat with viewNum = 1 to the number of lines of viewChildren
      put line viewNum of viewChildren into childView
      put line viewNum of newViews into newView
      if newView is empty then put placeHolderView into newView
      
      if exists(childView) and exists(newView) then
         set the view_Replacement of childView to newView
      else
         breakpoint
      end if
   end repeat
end view_Children

getprop view_ChildReferences
   -- put the script_Suite ["View | Object | Children"] of the target into suiteScript
   
   put the script_AndBehavior of the target into someScript
   put script_GetSuiteTitles(someScript) into suiteTitles
   filter suiteTitles with "View * Children"
   put line 1 of suiteTitles into suiteTitle
   if suiteTitle is empty then return empty
   put script_GetSuite(suiteTitle, someScript) into suiteScript
   
   put script_ExtractGetPropHandlers(suiteScript) into objectPropertyNames
   return objectPropertyNames
end view_ChildReferences


--> View
-
command view_NormalizeName @viewPath
   if viewPath is empty then return empty
   put word 1 to -1 of viewPath into viewPath
   
   set the itemdelimiter to "|"
   repeat with itemNum = 1 to the number of items of viewPath
      put word 1 to -1 of item itemNum of viewPath into someItem
      put someItem into item itemNum of viewPath
   end repeat
   if item 1 of viewPath is not "View" then put "View|" before viewPath
   return viewPath
end view_NormalizeName


--> View | Menu
-
getprop view_ToolMenu [pItems]
   put the long id of the target into targetObject
   put the view_Object of targetObject into someView
   if exists(someView) is false then put targetObject into someView
   
   put the menu_ToolTitle of targetObject into mTitle -- searches so more danger of recursion   
   put menu_GetTextFromTitleTable (mTitle, targetObject) into mText
   return mText
end view_ToolMenu

getprop view_ChildToolMenus
   global gTemp_ActiveMenuArray
   put the long id of the target into targetObject
   put the mobile_Name of targetObject into targetObject
   
   put menu_GetSentPath() into oTextPath
   put menu_GetSentTitlePath() into oTitlePath
   
   set the itemdelimiter to tab
   put the view_Children of targetObject into viewChildren
   repeat for each line viewChild in viewChildren
      put the mobile_Name of viewChild into viewChild
      put the menu_ToolTitle of viewChild into mTitle
      
      put menu_MenuTextFromTitle (mTitle) into subPathBit
      put oTextPath & "/" & subPathBit into mTextPath
      put oTitlePath into mTitlePath
      
      put the menu_Table [mTitle] of viewChild into mTable
      put menu_ConvertTable (mTable, viewChild, mTitlePath, mTextPath, viewChild) into mText
      
      put subPathBit & CR & outline_IncreaseIndent (mText) into mText
      
      put mText & CR & "-" & CR after someMenu
   end repeat
   delete line -2 to -1 of someMenu
   put word 1 to -1 of someMenu into someMenu
   return someMenu
end view_ChildToolMenus

command view_DoParamProp someView, publicProp, publicParam
   put publicProp & "[" & publicParam & "]" into cProp
   put the cProp of someView into oldValue
   
   put "Change public property" && cProp & "?" into someQuestion
   put view_AskPublicValue (cProp, someView, someQuestion) into publicValue
   
   set the cProp of someView to publicValue
end view_DoParamProp

function view_AskPublicValue someProp, someView, pQuestion
   if pQuestion is empty then put merge ("Change public property '[[someProp]]'?") into pQuestion
   switch
      case someProp contains "file"
         answer file "Choose a file..."
         return it
      case someProp contains "colour" or someProp contains "color"
         put the someProp of someView into oldColour
         answer color with oldColour
         return it
      default
         put the someProp of someView into oldValue
         ask pQuestion with oldValue
         if the result is "Cancel" then exit to top
         put it into publicValue
   end switch
   return publicValue
end view_AskPublicValue


--> View | Hierarchy | Class
-
getprop view_IsTemplate [vName]
   put the long id of the target into targetObject
   if vName is empty then
      put the view_Template of targetObject into templateObject
   else
      put view_GetTemplateObject (vName) templateObject
   end if
   return templateObject = targetObject
end view_IsTemplate

getprop view_IsClass [classPath]
   put the view_Name of the target into viewName
   put view_IsMemberOfClass (viewName, classPath) into someBoolean
   return someBoolean
end view_IsClass

function view_InheritsClass viewName, classPath
   view_NormalizeName classPath
   return viewName begins with viewName
end view_InheritsClass

function view_IsMemberOfClass viewName, classPath
   view_NormalizeName classPath
   set the itemdelimiter to "|"
   if viewName is empty then return false
   if char -1 of classPath = "|" then delete char -1 of classPath
   get item 1 to (the number of items of classPath) of viewName -- no "|" on the end
   return it = classPath
end view_IsMemberOfClass


--> View | Hierarchy
-
getprop view_Objects
   put the view_Object of the target into someView
   if someView is empty then return empty
   
   put object_SearchGroup(someView, "object_IsView", true) into searchArray
   put empty into viewObjects
   repeat for each key someObject in searchArray
      if searchArray [someObject] is true then
         put someObject & CR after viewObjects
      end if
   end repeat
   delete last char of viewObjects
   return viewObjects
end view_Objects

getprop rugged_Views
   put the view_NestedArray of the target into viewOutlineArray
   put viewOutlineArray ["@prop"] into ruggedArray
   put keys (ruggedArray) into ruggedViews
   return ruggedViews
end rugged_Views

getprop view_NestedArray
   local propertyArray
   put the long id of the target into targetObject
   view_SearchNested targetObject, propertyArray, someOutline, 0
   delete char -1 of someOutline
   put the result into objectArray
   put objectArray into nestedArray ["manifest"]
   put propertyArray into nestedArray ["@prop"]
   return nestedArray
end view_NestedArray

command view_SearchNested targetObject, @propertyArray, @someOutline, indentNum
   local objectArray  
   
   put text_RepeatString (tab, indentNum) into someIndent
   -- add 1 to indentNum
   put the view_Name of targetObject into vName
   put the abbreviated id of targetObject into containerKey
   
   if vName is not empty then
      add 1 to indentNum
      
      put vName into propertyArray [containerKey]
      put empty into objectArray [containerKey]
      put the rugged_ID of targetObject into ruggedObject
      put someIndent & html_ConstructNameLink (vName, ruggedObject) & CR after someOutline
   end if
   
   put the number of controls in targetObject into maxNum
   repeat with controlNum = 1 to maxNum -- look at contents
      put the long id of of control controlNum of targetObject into subObject
      
      put the abbreviated id of subObject into subKey
      if word 1 of subKey = "group" then
         -- recurse
         view_SearchNested subObject, propertyArray, someOutline, indentNum
         put the result into subArray -- will be a nested array
         if subArray is an array then
            put subArray [subKey] into objectArray [containerKey][subKey]
            get the extents of objectArray
         end if
         add the number of layers in subObject to controlNum
      else
         -- add plain
         put the view_Name of subObject into subViewName
         if subViewName is not empty then
            put empty into objectArray [subKey]
            put subViewName into propertyArray [subKey]
            put the rugged_ID of subObject into ruggedSubObject
            put tab & someIndent & html_ConstructNameLink (subViewName, ruggedSubObject) & CR after someOutline
         end if
      end if
   end repeat
   return objectArray
end view_SearchNested

getprop view_Outline
   local propertyArray, someOutline
   
   put the long id of the target into targetObject
   view_SearchNested targetObject, propertyArray, someOutline, 0
   delete char -1 of someOutline
   return someOutline
end view_Outline

private function _ViewOutlineBit someView, outlineType, vName, someIndent
   switch outlineType 
      case "names"
         put someIndent & the short name of someView into osLine
         break
      case "view names"
         if vName is not empty then
            put someIndent & vName into osLine
         end if
         break
      case "name links"
         put the short name of someView into shortName
         put someIndent & html_ConstructNameLink (shortName, ruggedID) into osLine
         break
      default --case "view name links"
         if viewName is not empty then
            put someIndent & html_ConstructNameLink (vName, ruggedID) into osLine
         end if
         break
   end switch
   return osLine
end _ViewOutlineBit

getprop view_Above
    put the long id of the target into someObject
    delete word 1 to 4 of someObject
    if exists(someObject) is false then return empty
    put the view_Object of someObject into someView
    return someView
end view_Above
 
getprop view_TopObject
    -- this is the default value for a view
    -- which is the top (highest) someView in the current layout
    
    put the long id of the target into testGroup
    put view_HierarchyObjects(testGroup) into groupHierarchy
    put line 1 of groupHierarchy into topView
    return topView
end view_TopObject

getprop view_Hierarchy
    -- was "view_GroupHierarchy"
    put the long id of the target into testGroup
    put view_HierarchyObjects(testGroup) into groupHierarchy
    return groupHierarchy
end view_Hierarchy

getprop view_HierarchyPath
    /*
    script and possibly "concept" is a bit of an ugly  hack - improve!
    
    This property acts like a class reference.
    A path is constructed based on the object hierarchy of the views.
    */
    
    put the long id of the target into someView
    put view_HierarchyObjects(someView) into viewHierarchy
    
    set the itemdelimiter to "|"
    put line -1 of viewHierarchy into bottomView
    put item -1 of the object_Name of bottomView into bottomViewShortName
     
    put "View" into nestedPath
    repeat for each line hierarchyView in viewHierarchy
        put the object_Name of hierarchyView into hierarchyViewPath
        if item 1 of hierarchyViewPath is "View" then delete item 1 of hierarchyViewPath
        delete item -1 of hierarchyViewPath
        if hierarchyViewPath is not empty then
            put "|" & hierarchyViewPath after nestedPath
        end if
    end repeat
    get nestedPath & "|" & bottomViewShortName
    return it
end view_HierarchyPath

function view_HierarchyObjects testGroup
    put empty into groupHierarchy
    repeat
        -- background groups can cause infinite loops
        -- so have to stop hierarchy check at the card level
        -- which means this will not work for views etc which are at the card level or above!
         
        if word 1 of testGroup is "card" then
            return word 1 to -1 of groupHierarchy
        else
            put the view_Object of testGroup into someView
            put someView & CR before groupHierarchy
            
             put someView into testGroup
            delete word 1 to 4 of testGroup
            if testGroup is empty then
                return word 1 to -1 of groupHierarchy
            end if
        end if
    end repeat
end view_HierarchyObjects


--> View | Geometry
-
/*
getprop view_Height
   -- dangerous to put in a library in this general way
   -- allow views to define them
   -- returning empty is the same as undefined.
   return the height of the target	# a default (can over-ride locally)
end view_Height

setprop view_Height someHeight
   set the height of the target to someHeight	# a default (can over-ride locally)
   return the result
end view_Height

getprop view_Width
   return the width of the target	# a defaults  (can over-ride locally)
end view_Width

setprop view_Width someWidth
   set the width of the target to someWidth	# a defaults  (can over-ride locally)
   return the result
end view_Width

getprop view_Height
    return the height of the target	# a default (can over-ride locally)
end view_Height

getprop view_Width
    return the width of the target	# a defaults  (can over-ride locally)
end view_Width

getprop formatted_Width
    -- defaults to formattedWidth (can over-ride locally)
    return the formattedwidth of the target
end formatted_Width

-- getprop view_Spacing
    -- defaults to the "view_StackPadding" of the target
    -- which in turn defaults to the value below!
    
    put the long id of the target into targetObject
    return the view_StackPadding of targetObject
end view_Spacing
*/

getprop view_Rect
   -- a simple default (override locally)
   if word 1 of the target is among the items of "field,button,image,player,graphic,scrollbar" then
      return the rect of the target
   else
      return empty
   end if
end view_Rect

setprop view_Rect someRect
   -- a simple default (override locally)
   if word 1 of the target is among the items of "field,button,image,player,graphic,scrollbar" and someRect is a rect then
      set the rect of the target to someRect
   end if
end view_Rect

getprop view_StackPadding
    -- a default
    return 20
end view_StackPadding

setprop view_StackMinMaxHeight minMaxList
    put item 1 of minMaxList into maxStackHeight
    if maxStackHeight is empty then put 65535 into maxStackHeight
    
    put item 2 of minMaxList into minStackHeight
    if minStackHeight is empty then put 32 into minStackHeight
    
    set the maxheight of this stack to maxStackHeight
    set the minheight of this stack to minStackHeight
end view_StackMinMaxHeight

getprop view_StackHeight [someView]
    put the long id of the target into targetObject
    if someView is empty then
        put object_ExtractStack(targetObject) into stackObject
        if exists(group 1 of stackObject) then 
            put the long id of group 1 of stackObject into someView
        else
            return empty
        end if
    end if
    put the view_StackPadding of someView into stackPadding
    put (the formattedheight of someView) + 2 * stackPadding into goodHeight
    return goodHeight
end view_StackHeight

getprop view_IsResizeable
    put the long id of the target into targetObject
    put the script_SetPropHandlers of targetObject into setPropHandlerIndex
    set the wholematches to true
    return "view_Rect" is among the lines of setPropHandlerIndex
end view_IsResizeable

command view_ResizeToCard pMargin, pName
   if pName is empty then put 1 into pName
   
   put the card_Object of the target into cardObject
   if pName is empty then put 1 into pName
   if exists (control pName of cardObject) is false then
      return empty -- could look for card_View
   end if
   
   if pMargin is empty then
      put the card_Margin of cardObject into pMargin
   else
      set the card_Margin of cardObject to pMargin
      -- set the uOPN ["card_Margin"] of cardObject to pMargin -- only needed for authoring
   end if
   
   put the rect of cardObject into someRect
   if pMargin is not 0 then put rect_SubtractMargin (pMargin, someRect) into someRect
   
   put the long id of control pName of cardObject into someView
   -- set the rect of someView to someRect
   dispatch "LayoutControl" to someView with someRect
   return someView
end view_ResizeToCard

on object_ResizeToCard pMargin, pResizeObject, pDimensions
   -- if the object_ContainsMessageHandler ["resizeControl"] of pResizeObject is true then
   put the card_ViewRect [pMargin] of pResizeObject into someRect
   switch
      case pDimensions is empty
         set the rect of pResizeObject to someRect
         break
      default
         set the media_Rect [pDimensions] of pResizeObject to someRect
         break
   end switch
   return the result
end object_ResizeToCard

getprop formatted_Width
   -- default (can over-ride locally)
   if word 1 of the target is not among the items of "button,field,image,player,group,card" then return empty
   return the formattedwidth of the target
end formatted_Width

getprop formatted_Height
   -- default (can over-ride locally)
   if word 1 of the target is not among the items of "button,field,image,player,group,card" then return empty
   return the formattedheight of the target
end formatted_Height

getprop view_ChildRect [shortID]
    -- a default
    -- can override at card level for specific viewNames
    -- also just use "card_Margin"
    -- viewResize sent to the card so the target is usually the card
    put the long id of the target into cardObject
    
    -- could return different rects for different views
    -- put the long id of control id shortID into childView
     
    -- can use the card_margin
    put the card_Margin [shortID] of cardObject into someMargin
    put the rect of cardObject into someRect
    return rect_SubtractMargin(someMargin, someRect)
end view_ChildRect

getprop card_ViewRect [someMargin]
    -- a default
    put the card_Object of the target into cardObject
    if exists(cardObject) is false then return empty
    
    if someMargin is empty then
        put the card_Margin of cardObject into someMargin
        if not(someMargin is a number or someMargin is a rect) then
            --  put the opn_Error ["The stored card margin is not a number or rect!"] of me
            put 0 into someMargin
            set the card_Margin of cardObject to 0
        end if
    else if someMargin is a number or someMargin is a rect then
        -- lets store it
        set the card_Margin of cardObject to someMargin
    else
        put the opn_Error ["Margin is not a number or rect!"] of me
        put 0 into someMargin
    end if
    
    put the rect of cardObject into someRect
    put rect_SubtractMargin(someMargin, someRect) into viewRect
    return viewRect
end card_ViewRect

getprop card_Margin
   put the card_Object of the target into cardObject
   if exists(cardObject) is false then return empty
   
   put the uOPN ["card_Margin"] of cardObject into cardMargin
   return cardMargin
end card_Margin

setprop card_Margin cardMargin
   put the card_Object of the target into cardObject
   if exists(cardObject) is false then return empty
   
   set the uOPN ["card_Margin"] of cardObject to cardMargin
end card_Margin

getprop view_StackHeight [someView]
    put the long id of the target into targetObject
    if someView is empty then
        put object_ExtractStack(targetObject) into stackObject
        if exists(group 1 of stackObject) then 
            put the long id of group 1 of stackObject into someView
        else
            return empty
        end if
    end if
    put the card_Margin of someView into stackPadding
    put (the formattedheight of someView) + 2 * stackPadding into goodHeight
    return goodHeight
end view_StackHeight

getprop view_ResizeStackScript [viewName]
    if viewName is empty then put "default" into viewName
    put the uOPN["ViewResizeStack_Script"] of me into templateScript
    put merge(templateScript) into newScript
    return newScript
end view_ResizeStackScript


--> View | Props | Default
-
getprop view_Text
   if word 1 of the target is "field" then
      return the text of the target
   else
      return the uOPN ["text"] of the target
   end if
end view_Text

setprop view_Text [someTitle] someText
   if word 1 of the target is "field" then
      set the text of the target to someText
   else
      set the uOPN ["text"] of the target to someText
   end if
end view_Text

getprop view_Html
   if word 1 of the target is "field" then
      return the htmltext of the target
   else
      return the uOPN ["html"] of the target
   end if
end view_Html

setprop view_Html [someTitle] someHtml
   if word 1 of the target is "field" then
      set the htmltext of the target to someHtml
   else
      set the uOPN ["html"] of the target to someHtml
   end if
end view_Html

getprop view_Utf8 [someTitle]
   if word 1 of the target is "field" then
      put the unicodetext of the target into someU16
      put unidecode(someU16, "UTF8") into someUtf8
   else
      return the uOPN ["utf8"] of the target
   end if
end view_Utf8

setprop view_Utf8 [someTitle] someUtf8
   if word 1 of the target is "field" then
      put uniencode(someUtf8, "UTF8") into someU16
      set the unicodetext of the target to someU16
   else
      set the uOPN ["utf8"] of the target to someUtf8
   end if
end view_Utf8

getprop view_Colour
   put the view_Object of the target into someView
   if exists(someView) is false then return empty
   return the effective backgroundcolor of someView
end view_Colour

getprop view_TextColour
   return "black"
end view_TextColour


--> View | Name
-
/*
Properties of all views.

Views are uniquely named in a way in which they can be orgaised into a hierarchy.
These names are stored as custom properties of the view.

Views are also usually associated with 2 models, the "data model" and the "display model".
By default both models are named according to the views "stem name".

For example a "tree" view has the stem "Tree",
the (data) model_Name "uOPN_DisplayTable" and
the view_DisplayModelName "uOPN_TreeDisplayTable".

This hierarchy allows the view to not only be displayed as part of a hierarchy,
but for generic scripts to use this hierarchical information to simulate "inheretance".
*/

getprop view_Name
   put the object_MetaData of the target into mData
   put mData ["type"] into oType
   if oType is not "View" then return empty
   return mData ["name"]
end view_Name

getprop component_Name [pComponentType]
   put the uRIP ["name"] of the target into vName
   if the dgProps ["style"] of the target is among the items of "table,form" then -- it is a datagrid
      if vName is empty then -- in case it is not named (ie a vanilla Rev control)
         return "View|Rev|Datagrid"
      else
         return vName
      end if
   else if pComponentType is empty then
      return vName
   else if the uRIP ["type"] of the target is not pComponentType then
      return empty
   else
      return vName
   end if
end component_Name

setprop component_Name [pComponentType] uRipName
   -- same as "view_Name"
   put the long id of the target into tObject
   component_SetName tObject, uripName, pComponentType
   put the result into someScript
   return someScript
end component_Name

setprop view_Name [pComponentType] viewName
   put the long id of the target into tObject
   component_SetName tObject, viewName, pComponentType
   put the result into someScript
   return someScript
end view_Name

command component_SetName tObject, uripName, pComponentType
   if pComponentType is empty then put "view" into pComponentType
   
   put the script of tObject into someScript
   
   put the script_MetaData of tObject into uRipArray
   put uripName into uRipArray ["name"]
   put pComponentType into uRipArray ["type"]
   set the script_MetaData of tObject to uRipArray
   put the result into someScript
   return someScript
end component_SetName


--> View | Behaviors
-
getprop object_ViewBehavior
   -- this assumes that the behavior has a custom property uRIP ["name']
   -- which is the same as the view_Name
   
   put the behavior of the target into someBehavior
   return the view_Name of someBehavior
end object_ViewBehavior

setprop object_ViewBehavior viewName
   put view_GetTemplateBehavior (viewName) into templateBehavior
   return templateBehavior
end object_ViewBehavior

function view_GetTemplateBehavior viewName
   put view_GetTemplateObject (viewName) into templateObject
   if exists (templateObject) is false then return empty
   put the behavior of templateObject into templateBehavior
   return templateBehavior
end view_GetTemplateBehavior

getprop view_Alternatives [viewName]
   -- a default in cases whem it is not intercepted by the view
   if viewName is empty then
      put the view_Name of the target into viewName
      if viewName is empty then return empty
      set the itemdelimiter to "|"
      delete item -1 of viewName
   end if
   
   put view_FilteredPaths (viewName) into viewNames
   return viewNames
end view_Alternatives

getprop view_Behavior
   put the view_Object of the target into someView
   if exists(someView) then 
      return the behavior of someView
   else
      return empty
   end if
end view_Behavior

getprop template_Behavior
   put the view_Name of the target into vName
   put view_GetBehavior (vName) into bObject
   return bObject
end template_Behavior

function view_GetBehavior vName
   -- first line will be the top view behavior if it has one
   put view_GetTemplateObject (vName) into templateObject
   put the behavior of templateObject into vBehavior
   return vBehavior
end view_GetBehavior

function view_ListBehaviors vName
   -- first line will be the top view behavior if it has one
   put view_GetTemplateObject (vName) into templateObject
   put the object_Behaviors of templateObject into vBehaviors
   return vBehaviors
end view_ListBehaviors

getprop view_BehaviorScript [whichScripts]
   -- combines, the view, behavior and library scripts (if they exist)
   put the long id of the target into someView
   
   put the script of someView into someScript
   if whichScripts is not "view" then
      put the behavior of someView into someBehavior
      if exists(someBehavior) then put CR & CR & the script of someBehavior after someScript
   end if
   
   if whichScripts is not among the items of "view,behavior" then
      put the view_TemplateStack of someView into someLibrary
      if exists(someLibrary) then put CR & CR & the script of someLibrary after someScript
   end if
   return someScript
end view_BehaviorScript


--> View | Tests
-
getprop view_IsResizeable
   put the long id of the target into targetObject
   put the script_SetPropHandlers of targetObject into setPropHandlerIndex
   set the wholematches to true
   return "view_Rect" is among the lines of setPropHandlerIndex
end view_IsResizeable

getprop view_IsOld
   put the long id of the target into someView
   
   put the object_Version of someView into thisVersion
   put the view_Template of someView into libraryObject
   if exists (libraryObject) is false then return "Error: library object does not exist. Maybe target is not a view?"
   
   put the object_Version of libraryObject into libraryVersion
   if thisVersion > libraryVersion then
      return false
   else if thisVersion = libraryVersion then
      return empty
   else
      return true
   end if
end view_IsOld


--> View | Name | References
-
-- getprop datagrid_View
   return the long id of me
end datagrid_View

getprop view_InsideViews [viewStem]
   put the long id of the target into containerObject
   put the number of chars of viewStem into maxNum
   repeat with controlNum = 1 to the number of controls in containerObject
      put the long id of control controlNum of containerObject into testObject
      if char 1 to maxNum of the view_Name of testObject =  viewStem then
         put testObject & CR after foundObjects
      end if
   end repeat
   delete char -1 of foundObjects
   return foundObjects
end view_InsideViews

getprop view_Reference
   -- assumes a view has a behavior, and an object reference is in the Metadata suite.
   put the view_Object of the target into someView
   if exists(someView) is false then return empty
   put the behavior of someView into viewBehavior
   if exists(viewBehavior) is false then put someView into viewBehavior
   put the script of viewBehavior into someScript
   
   put script_GetSuite("Metadata", someScript) into suiteScript
   put script_ExtractGetPropHandlers(suiteScript) into viewReferences
   line_Delete "view_Object", viewReferences
   return viewReferences
end view_Reference

getprop view_DisplayModelName
   -- the default based on the views stem
   -- return "uOPN_TreeDisplayTable"
   
   put the view_Object of the target into someView
   put the view_Stem of someView into viewStem
   put toupper(char 1 of viewStem) into char 1 of viewStem
   put "uOPN_" & viewStem & "DisplayTable" into modelName
   return modelName
end view_DisplayModelName

getprop view_Stem
   put the view_Object of the target into someView
   -- put the long id of the target into someView
   if exists(someView) is false then return empty
   
   put the uOPN ["view_Stem"] of someView into viewStem
   if viewStem is not empty then
      return viewStem
   else
      put the uRIP ["name"] of someView into viewName
      put view_StemFromName(viewName) into viewStem 
      set the view_Stem of someView to viewStem
      return viewStem
   end if
end view_Stem

function view_StemFromName viewName
   if viewName is empty then return "event"
   
   set the itemdelimiter to "|"
   put word 1 to -1 of item 2 of viewName into viewStem 
   replace space with empty in viewStem
   put tolower(viewStem) into viewStem
   return viewStem
end view_StemFromName

setprop view_Stem viewStem
   put the long id of the target into someView
   set the uOPN ["view_Stem"] of someView to viewStem
end view_Stem


--> View | Top
-
/*
A number of similar scripts here - needs rationalising.
*/

getprop top_View
   return the card_View of the target
end top_View

getprop top_CardView
   return the card_View of the target
end top_CardView

on card_SpaceControls someRect, viewSpacer
   if someRect is empty then put the the rect of me into someRect
   lock screen 
   
   if viewSpacer is empty then put 4 into viewSpacer
   put rect_SubtractMargin (viewSpacer, someRect) into innerRect
   
   put item 1 of innerRect into innerLeft
   put item 2 of innerRect into lastTop
   put item 3 of innerRect into innerRight
   put item 4 of innerRect into innerBottom
   
   put 0 into rowHeight
   put innerLeft into lastLeft
   put item 3 of innerRect - item 1 of innerRect into innerWidth
   put the top_Controls of this card into topControls
   repeat for each line topControl in topControls      
      put the formatted_Width of topControl into fWidth
      if fWidth is empty then put the formattedWidth of topControl into fWidth
      if fWidth is empty then put the width of topControl into fWidth
      
      put the formattedHeight of topControl into fHeight
      if fHeight is empty then put the formatted_Height of topControl into fHeight
      if fHeight is empty then put the height of topControl into fHeight
     
      put lastLeft + fWidth into imageRight
      
      if imageRight > innerRight then
         -- lets move it down a row
         add rowHeight + viewSpacer to lastTop
         put 0 into rowHeight
         put innerLeft into lastLeft
         put lastLeft + fWidth into imageRight
      end if
      
      put lastLeft,lastTop into cRect
      put imageRight into item 3 of cRect
      put lastTop + fHeight into lastBottom
      put lastBottom into item 4 of cRect
      put rect_AddMargin (4, cRect) into cRect
        
      set the rect of topControl to cRect
      
      put max (rowHeight, fHeight) into rowHeight
      add fWidth + viewSpacer to lastLeft
   end repeat
   unlock screen
end card_SpaceControls

getprop card_ViewOutline [withLinks]
   put withLinks is true into withLinks
   put the card_TopViews of the target into cardViews
   repeat for each line cardView in cardViews
      put the view_NameOutline [withLinks] of cardView & CR after cardViewOutline
      -- put the view_ReferenceOutline [onlyViewNames] of cardView & CR after cardViewOutline
   end repeat
   delete char -1 of cardViewOutline
   return cardViewOutline
end card_ViewOutline

getprop card_TopView
   -- return the card if there are no top views, or more than 1 top view
   put the long id of the target into targetObject
   put the card_Object of targetObject into cardObject
   put the card_TopViews of cardObject into topViews
   if the number of lines of topViews = 1 then
      return topViews
   else
      return cardObject
   end if
end card_TopView

function card_GetTopView
   return the card_TopView of the topstack
end card_GetTopView

function card_ListOtherViews cardObject, pNotTheseViewNames
   local foundObjects
   view_NormalizeName viewName
   repeat with cNum = 1 to the number of controls in cardObject
      put the long id of control cNum of cardObject into testObject
      put the view_Name of testObject into testViewName
      if testViewName is empty then next repeat
      
      if testViewName is not among the items of pNotTheseViewNames then
         put testObject & CR after foundObjects
      end if
   end repeat
   return foundObjects
end card_ListOtherViews

function card_ListViews cardObject, pViewName
   local foundObjects
   view_NormalizeName viewName
   repeat with cNum = 1 to the number of controls in cardObject
      put the long id of control cNum of cardObject into testObject
      put the view_Name of testObject into testViewName
      if pViewName is empty or testViewName is pViewName then
         put testObject & CR after foundObjects
      end if
   end repeat
   return foundObjects
end card_ListViews

getprop card_Views
   -- in any order
   put the card_Object of the target into cardObject
   repeat with controlNum = 1 to the number of controls in cardObject
      put the long id of control controlNum of cardObject into someControl
      put the view_Name of someControl into vName
      if vName is empty then next repeat
      put someControl & CR after cardViews
   end repeat
   delete char -1 of cardViews
   return cardViews
end card_Views

getprop card_TopViews [viewName]
   put the card_Object of the target into cardObject
   put the object_TopControls of cardObject into topControls
   repeat for each line someControl in topControls
      put the view_Name of someControl into testViewName
      if viewName is empty and testViewName is not empty then
         put someControl & CR after topCardViews
      else if viewName = testViewName then
         put someControl & CR after topCardViews
      end if
   end repeat
   delete char -1 of topCardViews
   return topCardViews
end card_TopViews


--> View | Find
-
getprop card_View [vNames]
   -- a guess (makes views "sticky")
   -- first it looks "inside" the target view
   -- next it looks "up" the target view hirarchy
   -- then it looks down from the card view
   
   if vNames is empty then
      return line 1 of the card_TopViews of the target
   else
      put the long id of the target into targetObject
      
      if word 1 of targetObject is not "card" then
         -- first search inside the target view
         put the view_LazyFindInside [vNames] of targetObject into foundView
         if exists(foundView) then return foundView
         
         -- next search up from the target view
         put the view_Above [vNames] of targetObject into foundView
         if exists(foundView) then return foundView
         
      end if
      
      put the card_Object of targetObject into cardObject
      
      -- lets do a strict match for each vName in turn for every view from the card down
      put the card_ViewMatch [vNames] of cardObject into foundView
      if exists(foundView) then return foundView
      
      -- finally lets search lazily from the card down
      put the view_LazyFindInside [vNames] of cardObject into foundView
      if exists(foundView) then
         return foundView
      else
         return empty
         
         get the card_TopViews of the target
         return line 1 of it
      end if
   end if
end card_View

getprop card_ViewMatch [vNames]
   -- maybe change for "view_Match"
   put the card_Object of the target into cardObject
   put the view_Match [vNames] of cardObject into cardViewMatch
   return cardViewMatch
end card_ViewMatch

getprop view_Match [vNames]
   -- lets do a strict match for each vName in turn for every view from the card down
   -- does not search top to bottom but in control order
   -- consider changeing to top down search (slower)
   put the long id of the target into targetObject
   if word 1 of targetObject is not among the items of "card,stack" then
      put the view_Name of targetObject into vName
      if vName is not empty and strictViewNameMatch (matchName, vName) is true then
         return targetObject
      end if
   end if
   
   -- should go down from the top (most unusual match)
   repeat for each line matchName in vNames
      repeat with controlNum = 1 to the number of controls in targetObject
         put the long id of control controlNum of targetObject into someControl
         put the view_Name of someControl into vName
         if vName is empty then next repeat
         if strictViewNameMatch (matchName, vName) is true then
            return someControl
         end if
      end repeat
   end repeat
   return empty
end view_Match

getprop view_FindInside [vNames]
   replace "/" with CR in vNames
   put line 1 of vNames into vName
   put the view_Inside [vName] of the target into foundView
   if exists(foundView) is false then return empty
   put the view_MatchInside [vNames] of foundView into matchedView
   return matchedView
end view_FindInside

getprop view_Inside [vNameOrStem]
   -- works with any control or card
   put the long id of the target into targetObject
   
   -- first lets check the target to see if there is a match
   put the view_Name of targetObject into vName
   if lazyViewNameMatch (vNameOrStem, vName) is true then return targetObject
   
   -- now lets recurse the children
   put the object_TopControls of targetObject into topControls
   repeat for each line topControl in topControls
      put the view_Inside [vNameOrStem] of topControl into foundView
      if exists(foundView) then return foundView
   end repeat
   return empty
end view_Inside

getprop view_LazyFindInside [vNames]
   replace "/" with CR in vNames
   put line 1 of vNames into vName
   put the view_Inside [vName] of the target into foundView
   if exists(foundView) is false then return empty
   
   put the view_SlightlyLazyMatchInside [vNames] of foundView into matchedView
   return matchedView
end view_LazyFindInside

getprop view_SlightlyLazyMatchInside [vNames]
   -- first lets look for a strict match
   put the view_MatchInside [vNames] of the target into strictMatch
   if exists(strictMatch) then return strictMatch
   
   -- then get slightly lazy
   repeat (the number of lines of vNames - 1)
      put the view_LazyMatchInside [vNames] of the target into lazyMatch
      if exists(lazyMatch) then return lazyMatch
      delete line -1 of vNames
   end repeat
   return empty
end view_SlightlyLazyMatchInside
   
getprop view_VeryLazyMatchInside [vNames]
   repeat the number of lines of vNames
      put the view_LazyMatchInside [vNames] of the target into lazyMatch
      if exists(lazyMatch) then return lazyMatch
      delete line -1 of vNames
   end repeat
   return empty
end view_VeryLazyMatchInside

getprop view_LazyMatchInside [vNames]
   -- a recursive function
   -- a match where if the target is matched by the top vName
   -- then it looks for a match for the next vName in the index among the top controls (one level down)
   -- and continues for all lines of vNames
   -- any mismatch and it returns the last (deepest) match found
   -- calling this property on a control which has no view_Name or the wrong view_Name returns empty
   
   put the long id of the target into targetObject
   replace "/" with CR in vNames   
   put line 1 of vNames into viewNameOrStem
   
   -- first lets check the top level object
   put the view_Name of targetObject into vName
   if vName is empty then return empty
   if lazyViewNameMatch(viewNameOrStem, vName) is true then
      -- found a match so lets move down a view and a vName
      delete line 1 of vNames
      if vNames is empty then
         -- no more vNames to search so lets return the found object
         return targetObject
      else
         put the object_TopControls of targetObject into topControls
         repeat for each line testControl in topControls
            put the view_LazyMatchInside [vNames] of testControl into foundView
            if exists(foundView) then return foundView
         end repeat
         return empty
      end if
   end if
end view_LazyMatchInside

getprop view_MatchInside [vNames]
   -- a recursive function
   -- a strict match where if the target is matched by the top vName
   -- then it looks for a match for the next vName in the index among the top controls (one level down)
   -- and continues for all lines of vNames
   -- any mismatch and it returns false (stem matches are allowed)
   -- calling this property on a control which has no view_Name or the wrong view_Name returns empty
   
   put the long id of the target into targetObject
   replace "/" with CR in vNames
   put line 1 of vNames into viewNameOrStem
   
   -- first lets check the top level object
   put the view_Name of targetObject into vName
   if vName is empty then return empty
   if strictViewNameMatch(viewNameOrStem, vName) is true then
      -- found a match
      delete line 1 of vNames
      if vNames is empty then
         -- no more vNames to search so lets return the found object
         return targetObject
      else
         put the object_TopControls of targetObject into topControls
         repeat for each line testControl in topControls
            put the view_MatchInside [vNames] of testControl into foundView
            if exists(foundView) then return foundView
         end repeat
         return empty
      end if
   end if
end view_MatchInside

getprop view_Above [vNameOrStem]
   -- search for a named view in the hierarchy above the target
   -- including the target itself
   
   put the long id of the target into targetObject
   if vNameOrStem is empty then
      delete word 1 to 4 of targetObject
      if exists(targetObject) is false then return empty
      put the view_Object of targetObject into viewAbove
      return viewAbove
   end if
   
   repeat
      if word 1 of targetObject is "card" then
         return empty
      else
         put the view_Object of targetObject into someView
         if exists (someView) is false then return empty
         
         -- lets check for a match
         put the view_Name of someView into vName
         if lazyViewNameMatch (vNameOrStem, vName) is true then
            return someView
         else
            -- return empty here forces a match only if the named view is one level up
            -- doing nothing allows the named view to be several levels up
         end if
         
         -- go up one level and try again
         put someView into targetObject
         delete word 1 to 4 of targetObject
         if targetObject is empty then return empty
      end if
   end repeat
   return empty
end view_Above

private function lazyViewNameMatch vNameOrStem, vName
   -- test to see if a view_Name is a lazy match with a vNameOrStem
   -- as long as vNameOrStem is an item within the view_Name it returns true
   view_NormalizeName vNameOrStem
   view_NormalizeName vName
   
   set the itemdelimiter to "|"
   delete item 1 of vName
   delete item 1 of vNameOrStem
   if char -1 of vNameOrStem = "|" then delete char -1 of vNameOrStem
   return vNameOrStem is among the items of vName
   
   --old
   -- if the last match fails the match chops of last item and tries again until a match succeeds
   -- so "Tree" will match the vName "View|Tree|Simple Tree"
   repeat the number of items of vName
      if vName = vNameOrStem then
         return true
      end if
      delete item - 1 of vName
   end repeat
   return false
end lazyViewNameMatch

private function strictViewNameMatch vNameOrStem, vName
   if char -1 of vNameOrStem is "|" then
      put true into isStem
      delete char -1 of vNameOrStem
   else
      put false into isStem
   end if
   view_NormalizeName vNameOrStem
   view_NormalizeName vName
   
   set the itemdelimiter to "|"
   delete item 1 of vName
   delete item 1 of vNameOrStem
   
   switch
      case vNameOrStem is empty
         -- return the first named view
         return true
      case isStem is true and (item 1 to (the number of items of vNameOrStem) of vName = vNameOrStem)
         -- stem match
         return true
      case isStem is false and vName = vNameOrStem
         -- exact match
         return true
      default
         -- no match (so lets try recursing)
         return false
   end switch
end strictViewNameMatch
