script "lib_HandlerCalls"
--> MetaData
-
license: GPLv3
name: lib_HandlerCalls
type: script library
version: 0.1

/*
This library is the central place to organise all code that deals with extracting script calls from a handler.
It was taken from "libOPN_Calls".

There are several ways to refer to handlers:
-  as a handler of a sript object "handler"
-  using an hKey reference
-  using the global hArray database

Call links in the library are stored a simple short hkeys.
They are stored in two places, a a simple link.txt file with a list of CR separated short hKeys,
and in the projects metadata array file as metadataArray ["filteredCalls"], and metadataArray ["allCalls"].

Eventually should decide which to use (probably get rid of links.txt, and maybe loose both and replace with an sqLite db.
*/


--> Calls | Props
-
getprop hkey_Calls [shortHkey]
   put the object_Hkey [shortHkey] of the target into hKey
   return hkey_FetchShortCalls (hKey)
end hkey_Calls

getprop script_HkeyArrayFromExportedCalls [pSetName]
   local hkeyArray
   put the script_Hkeys of the target into hKeys
   repeat for each line hKey in hKeys
      hkey_RecurseLongCallArrayFromExported hKey, hkeyArray, pSetName
   end repeat
   return hkeyArray
end script_HkeyArrayFromExportedCalls


--> Calls
-
function library_FetchHkeyCalls shortHkey
   -- could also get from "library_FetchHandlerMetadata"
   put library_CallsFile (shortHkey) into someFile
   if there is not a file someFile then return empty
   put url ("binfile:" & someFile) into hKeyCalls
   hack_UpdateBinFile hKeyCalls, someFile
   return hKeyCalls
end library_FetchHkeyCalls

command library_StoreHkeyCalls hKey, hKeyCalls
   put library_CallsFile (hKey, false) into someFile
   if hKeyCalls is empty then
      delete file someFile
      return empty
   else
      put hKeyCalls into url ("binfile:" & someFile)
      return someFile
   end if
end library_StoreHkeyCalls

function library_GetFilteredCalls hKey
   put library_FetchHandlerMetadata (hKey) into metadataArray
   put metadataArray ["filteredCalls"] into filteredCalls
   return filteredCalls
end library_GetFilteredCalls

command library_SetFilteredCalls hKey, filteredCalls
   put library_FetchHandlerMetadata (hKey) into metadataArray
   put filteredCalls into metadataArray ["filteredCalls"]
   library_FetchHandlerMetadata hKey, metadataArray
   return metadataArray
end library_SetFilteredCalls

function library_GetCalls hKey
   put library_FetchHandlerMetadata (hKey) into metadataArray
   put metadataArray ["hKeyCalls"] into hKeyCalls
   return hKeyCalls
end library_GetCalls

command library_SetCalls hKey, hKeyCalls
   put library_FetchHandlerMetadata (hKey) into metadataArray
   put hKeyCalls into metadataArray ["hKeyCalls"]
   library_FetchHandlerMetadata hKey, metadataArray
   return metadataArray
end library_SetCalls

command hkey_StoreCalls hKey, hKeyCalls
   put hkey_CallsFile (hKey, false) into someFile
   if hKeyCalls is empty then
      delete file someFile
      return empty
   else
      put hKeyCalls into url ("binfile:" & someFile)
      return someFile
   end if
end hkey_StoreCalls


--> Library | Handler | DatabaseArray
-
function library_FetchHandlerMetadata hKey
   put item 1 to 2 of hKey into shortHkey
   put library_FetchHandlerDatabaseArray() into hKeyData
   return hKeyData [shortHkey]
end library_FetchHandlerMetadata

command library_StoreHandlerMetadata hKey, handlerMetadata
   put item 1 to 2 of hKey into shortHkey
   put library_FetchHandlerDatabaseArray() into hKeyData
   put handlerMetadata into hKeyData [shortHkey]
   library_StoreHandlerDatabaseArray hkeyData
end library_StoreHandlerMetadata

function library_GetHandlerDatabaseMetadata
   put library_FetchHandlerDatabaseArray() into handlerDatabaseArray
   put handlerDatabaseArray ["metadata"] into dbMetaData
   return dbMetaData
end library_GetHandlerDatabaseMetadata

command library_SetHandlerDatabaseMetadata dbMetaData
   put library_FetchHandlerDatabaseArray() into handlerDatabaseArray
   put dbMetaData into handlerDatabaseArray ["metadata"]
   library_StoreHandlerDatabaseArray handlerDatabaseArray
   return handlerDatabaseArray
end library_SetHandlerDatabaseMetadata

function library_ListHkeys
   put library_FetchHandlerDatabaseArray() into handlerDatabaseArray
   put keys (handlerDatabaseArray) into hkeys
   sort hKeys by item 1 of each
   return hKeys
end library_ListHkeys

function library_FetchHandlerDatabaseArray
   put library_FetchArray ("Hkey_Library") into handlerDatabaseArray
   return handlerDatabaseArray
end library_FetchHandlerDatabaseArray

command library_StoreHandlerDatabaseArray handlerDatabaseArray
   library_StoreArray "Hkey_Library", handlerDatabaseArray
end library_StoreHandlerDatabaseArray


--> Hkey Calls | Harray
-
function hkey_GetCalls hKey, pSetName, pAllCalls
   put project_GetHkeyDeps (hKey, false, pSetName, pAllCalls) into hkeyCalls
   return hkeyCalls
end hkey_GetCalls

function hkey_GetCallsFromObject hKey, pSetName, pAllCalls
   put project_GetHkeyDeps (hKey, true, pSetName, pAllCalls) into hkeyCalls
   return hkeyCalls
end hkey_GetCallsFromObject

function hkey_FetchShortCalls hKey, pReindex
   -- first lets fetch a mainstack hArray
   put item 3 of hKey into hObject
   put the textStack_Folder of hObject into mainStackFolder
   put mainStack_FetchHarray (mainStackFolder) into hArray
   
   if hArray is not an array and pReindex is not false then
      mainStack_ExportAsFiles hObject -- fix:  should just redo hArray here
      put the result into mainStackMetaArray
      put mainStackMetaArray ["hArray"] into hArray
      -- put mainStack_FetchHarray (mainStackFolder) into hArray
   end if
   
   -- found on disk from stack export
   put hArray_GetCalls (hKey, hArray) into shortCalls
   return shortCalls
end hkey_FetchShortCalls

function hArray_GetCalls hKey, hArray
   put hArray_GetHandlerHash (hKey, hArray) into handlerHash
   put hArray ["handlerHashArray"]["cached"][handlerHash]["shortCalls"] into shortCalls
   return shortCalls
end hArray_GetCalls

function hkey_ExtractShortCalls hKey
   put hArray_GetHandler (hKey) into callHandler
   put handler_ExtractCalls (callHandler) into shortCalls
   return shortCalls
end hkey_ExtractShortCalls

function hArray_GetShortCalls hKey, pHArray
   /* or another ways
   put hArray_GetHandler (hKey, hArray) into callHandler
   put sha1_Hash (callHandler) into handlerHash
   */
   put hArray_GetHandlerHash (hKey, pHArray) into handlerHash
   if pHArray is empty then
      -- not sure this option should be in this handler
      return hkey_FetchShortCalls (hKey)
   else
      put pHArray ["handlerHashArray"]["cached"][handlerHash]["shortCalls"] into shortCalls
   end if
   return shortCalls
end hArray_GetShortCalls

command hArray_SetShortCalls hkey, hArray, shortCalls
   put hArray_GetHandlerHash (hKey, hArray) into handlerHash
   if shortCalls is empty then
      delete variable hArray ["handlerHashArray"]["cached"][handlerHash]["shortCalls"]
   else
      put shortCalls into hArray ["handlerHashArray"]["cached"][handlerHash]["shortCalls"]
   end if
   return shortCalls
end hArray_SetShortCalls


--> hKey  | Calls | Model
-
/*
Use these handlers to interface with handler calls stored as text files with the handler.
*/

function hArray_GetHkeyCalls hKey
   -- ugly, use hkey_Calls, or hKey_GetCalls, or hKey_FetchCalls
   
   put hArray_GetHkeyDataArray (hKey) into handlerArray
   put handlerArray ["sha1"] into handlerHash
   
   if handlerHash is empty then
      -- maybe the index is old?
      -- could check scripts sha1?
      put item 3 of hKey into hObject
      object_AddToGlobalArray hObject 
      put hArray_GetHandlerHash (hKey) into handlerHash
      if handlerHash is empty then
         -- it's not there
         return empty
      end if
   end if
   
   put library_FetchHandler (hKey) into someHandler
   if someHandler is empty then
      -- handler has not been exported
      put hArray_GetHandler (hKey) into someHandler
      put handler_ExtractCalls (someHandler) into hkeyCalls
      hkey_StoreCallsAndHandler hkey, someHandler, hKeyCalls
      return hkeyCalls
   else if sha1_Hash (someHandler) = handlerHash then
      return hkey_FetchShortCalls (hKey)
   else
      -- the exported handler is different
      -- let's return a value derived from the actual handler
      -- but not export
      put hArray_GetHandler (hKey) into someHandler
      put handler_ExtractCalls (someHandler) into hkeyCalls
      return hkeyCalls
   end if
end harray_GetHkeyCalls

command hkey_DeleteFolder hKey
   put hkey_Folder (hKey) into hkeyFolder
   revDeleteFolder hkeyFolder
end hkey_DeleteFolder

function handler_ConstructMetadataArray hKey, pHandler, pSkipHkeyComponents, pSkipHkeyProps
   if pHandler is empty then
      if the number of items of hKey = 2 then
         put library_FetchHandler (hKey) into pHandler
      else
         put hkey_ExtractHandlerFromObject (hKey) into pHandler
      end if
   end if
   put handler_ConstructCallArray (pHandler) into metadataArray
   hkey_AddToKeyWordArray metadataArray, hKey, handlerHash
   return metadataArray
end handler_ConstructMetadataArray

function handler_ConstructCallArray someHandler, pSkipHkeyComponents, pSkipHkeyProps
   -- this is slow, and needs to be as fast as possible as we want to call it on every script compile!
   -- should be modified to include "pass"
   
   local allCalls
   
   put library_ListForgetHkeys() into forgetHkeys
   
   put word 1 to -1 of someHandler into someHandler
   delete line 1 of someHandler
   delete line -1 of someHandler
   
   put false into repeatUntilEndOfComment
   repeat for each line someLine in someHandler
      if repeatUntilEndOfComment is true then
         put char -2 to -1 of someLine into endCommentBit
         if endCommentBit = "*/" then
            put false into repeatUntilEndOfComment
         end if
         next repeat
      else if char 1 to 2 of word 1 of someLine = "/*" then
         put true into repeatUntilEndOfComment
         next repeat
      else
         -- first lt's deal with single line comments
         repeat for each item commentBlock in "--,#"
            if someLine contains commentBlock then
               put text_StripQuoted (someLine) into commentLine
               
               put wordOffset (commentBlock, commentLine) into wordNum
               if wordNum > 0 then
                  put word wordNum to -1 of commentLine into someComment
                  
                  if char -1 of word 2 of someComment = ":" then
                     set the itemdelimiter to ":"
                     put word 2 of item 1 of someComment into someKey
                     put word 1 to -1 of item 2 of commentLine into someValue
                     set the itemdelimiter to ","
                     
                     put metadataArray [someKey] into someIndex
                     line_Add someValue, someIndex
                     put someIndex into metadataArray [someKey]
                  end if
                  
                  -- delete the comments part
                  delete word wordNum to -1 of someLine
               end if
            end if
         end repeat
         
         if the number of words of someLine = 0 then next repeat
         
         put someLine into testLine
         replace " then " with CR in testLine
         replace " else " with CR in testLine
         repeat for each line testBit in testLine
            put token 1 of testBit into testComand
            if testComand is empty then next repeat
            
            switch
               case testComand = "dispatch"
                  put token 2 of testBit into dispatchCommand
                  if dispatchCommand is among the items of "function,command" then
                     put token 3 of testBit into dispatchCommand
                  end if
                  put dispatchCommand,"c" into shortHKey
                  
                  handler_AddToCallArray tempArray, shortHKey, metadataArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, forgetHkeys
                  
                  delete token 1 to 3 of someLine  -- let's look at the rest of the line
                  break
               case testComand is among the items of "send,call"
                  put token 2 of testBit into sendMessage
                  put token 1 of sendMessage into sendComand
                  if sendComand is among the items of "function.command" then
                     breakpoint -- is this right?
                     put token 3 of testBit into sendMessage
                     put token 2 of sendMessage into sendComand
                  end if
                  put sendComand,"c" into shortHKey
                  
                  handler_AddToCallArray tempArray, shortHKey, metadataArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, forgetHkeys
                  
                  delete token 1 to 3 of someLine  -- let's look at the rest of the line
                  break
               case script_DictionaryTerm (testComand) is true
                  break
               default
                  -- first word and not a LiveCode term
                  put testComand,"c" into shortHKey
                  
                  handler_AddToCallArray tempArray, shortHKey, metadataArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, forgetHkeys
                  
                  delete token 1 of someLine  -- let's look at the rest of the line
            end switch
         end repeat
         
         put script_ExtractFunctionCalls (someLine, false) into fNames
         repeat for each line fName in fNames
            put fName,"f" into shortHKey
            
            handler_AddToCallArray tempArray, shortHKey, metadataArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, forgetHkeys
         end repeat
         
         -- could still have other stuff on line
         set the wholematches to true
         put wordoffset ("the", someLine) into theWordNum
         if theWordNum is 0 then next repeat
         
         put theWordNum - 1 into setGetPutWordNum
         put word setGetPutWordNum to -1 of someLine into testLineBit
         
         put 3 into handlerTokenNum
         put token handlerTokenNum of testLineBit into handlerName
         if script_DictionaryTerm (handlerName) is true then next repeat
         
         -- now check getprop / setprop calls ("the xxx [zzz] of")
         
         put handlerTokenNum + 1 into ofTokenNum
         get token ofTokenNum of testLineBit
         if it is "[" then
            put handlerTokenNum + 4 into ofTokenNum
            get token ofTokenNum of testLineBit
         end if
         
         if it is "of" then
            put token 1 of testLineBit into setGetPut
            if setGetPut is "set" and "to" is among the words of someLine then
               put handlerName,"s" into shortHKey
               
               handler_AddToCallArray tempArray, shortHKey, metadataArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, forgetHkeys
            else -- if setGetPut is among the items of "case,if,get,put" then
               put handlerName,"g" into shortHKey
               
               handler_AddToCallArray tempArray, shortHKey, metadataArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, forgetHkeys
            end if
         end if
      end if
   end repeat
   
   put tempArray ["hkeyCalls"] into someArray
   put keys (someArray) into metadataArray ["hkeyCalls"]
   put tempArray ["filteredCalls"] into someArray
   put keys (someArray) into metadataArray ["filteredCalls"]
   
   put sha1_Hash (someHandler) into handlerHash
   put handlerHash into metadataArray ["sha1"]
   -- hkey_AddToKeyWordArray metadataArray, hKey, handlerHash
   
   return metadataArray
end handler_ConstructCallArray

private command handler_AddToCallArray @tempArray, shortHKey, handlerArray, someHandler, pSkipHkeyComponents, pSkipHkeyProps, pForgetHkeys  
   put empty into tempArray ["hkeyCalls"][shortHKey]
   put handlerArray ["addCall"] into tempArray ["hkeyCalls"][shortHKey]
   
   if handlerArray ["component"] is true then return false
   
   -- don't index rev handler calls (assume they are IDE handlers)
   put item 1 of shortHKey into hName
   if char 1 to 3 of hName = "rev" and char 4 of hName is not "_" then return false
   
   put handlerArray ["ignoreCall"] into ignoreCalls
   if shortHkey is among the lines of ignoreCalls then return false
   
   set the wholematches to true
   if shortHkey is among the lines of pForgetHkeys then return false
   
   -- if hkey_TestShortDeps (shortHKey, someHandler, pSkipHkeyComponents, pSkipHkeyProps) is false then return false
   
   put empty into tempArray ["filteredCalls"][shortHKey]
end handler_AddToCallArray

function handler_ExtractCalls someHandler, pSkipHkeyComponents, pSkipHkeyProps
   put handler_ConstructCallArray (someHandler, pSkipHkeyComponents, pSkipHkeyProps) into metadataArray 
   return metadataArray ["hkeyCalls"]
end handler_ExtractCalls

function handler_ExtractFilteredCalls someHandler, pSkipHkeyComponents, pSkipHkeyProps
   put handler_ConstructCallArray (someHandler, pSkipHkeyComponents, pSkipHkeyProps) into metadataArray 
   return metadataArray ["filteredCalls"]
end handler_ExtractFilteredCalls

function script_ExtractFunctionCalls scriptLine, pIncludeBuiltinFunctions
   local fNames
   
   put text_StripQuoted (scriptLine) into scriptLine
   -- put "(\w+)\s*" & "\((.*)\)" into greedyExpression -- error with handlers that use "." notation
   -- if matchtext(scriptLine, greedyExpression, wordBefore, bracketedStuff) is true then
   
   put "\((.*)\)" into bracketExpression
   if matchchunk (scriptLine, bracketExpression, startBracketedStuff, endBracketedStuff) is true then
      put char startBracketedStuff to endBracketedStuff of scriptLine into bracketedStuff
      get char 1 to (startBracketedStuff - 1) of scriptLine
      put token -2 of it into wordBefore
      if wordBefore is among the chars of "[()]" then
         -- hack
         put empty into wordBefore
      end if
      
      if bracketedStuff contains "(" then
         put script_ExtractFunctionCalls (bracketedStuff, pIncludeBuiltinFunctions) into innerFunctions
         
         if pIncludeBuiltinFunctions is true then
            repeat for each line innerFunction in innerFunctions
               line_Add innerFunction, fNames
            end repeat
         else
            repeat for each line innerFunction in innerFunctions
               if script_DictionaryTerm(innerFunction) is false then
                  line_Add innerFunction, fNames
               end if
            end repeat
         end if
      end if
      
      if wordBefore is not empty then
         if pIncludeBuiltinFunctions is true then
            line_Add wordBefore, fNames
         else
            if script_DictionaryTerm (wordBefore) is false then
               line_Add wordBefore, fNames
            end if
         end if
      end if
      return word 1 to -1 of fNames
   else
      return empty
   end if
end script_ExtractFunctionCalls


--> Hkey | MetaData | Array
-
function hkey_GetMetadataArray hKey
   put hkey_GetOverlayData (hKey) into overlayData
   put overlayData ["metadata"] into metadataArray
   return metadataArray
end hkey_GetMetadataArray

command hkey_SetMetadataArray hKey, metadataArray
   put hkey_GetOverlayData (hKey) into overlayData
   put metadataArray into overlayData ["metadata"]
   hkey_SetOverlayData hKey, overlayData
   return overlayData
end hkey_SetMetadataArray


--> Old Mixed | Hkey | Deps
-
function hkey_ConstructCallArray hKey, pFetchHow
   -- fetch from "links.txt" file recursively
   local hkeyArray
   hkey_RecurseCallArray hKey, hkeyArray, pFetchHow
   return hkeyArray
end hkey_ConstructCallArray

function scriptArray_ConstructShortHkeyArray dataArray
   -- fetch from "links.txt" for all hKeys in the scriptArray "dataArray"
   local hkeyArray
   repeat for each element recordArray in dataArray
      set the cursor to busy
      put recordArray ["hkey"] into hkey
      if hKey is empty then next repeat
      if hKey is among the keys of hkeyArray then next repeat
      
      hkey_RecurseCallArray hKey, hkeyArray
   end repeat
   return hkeyArray
end scriptArray_ConstructShortHkeyArray

function hkey_CallArrayFromExported hKey, pSetName
   local hkeyArray
   hkey_RecurseLongCallArrayFromExported hKey, hkeyArray, pSetName
   return hkeyArray
end hkey_CallArrayFromExported

command hkey_RecurseLongCallArrayFromExported hKey, @hkeyArray, pSetName
   -- fetch from "links.txt" file recursively
   local foundHkey, foundHandler
   if hKey is among the keys of hkeyArray then return "Already indexed! Skipping to avoid recursion."
   
   put item 3 of hKey into hObject
   put hkey_GetCalls (hKey) into shortCalls
   repeat for each line shortCall in shortCalls
      put item 1 of shortCall into cName
      put item 2 of shortCall into cType
      put hkey_FindAndIndex (cName, cType, hObject, pSetName) into foundHkey
      put foundHkey & CR after longCalls
   end repeat
   delete char -1 of longCalls
   put longCalls into hkeyArray [hKey]
   
   repeat for each line longCall in longCalls
      -- hkey_RecurseShortCallArrayFromExported longCall, hkeyArray, pSetName
   end repeat
end hkey_RecurseLongCallArrayFromExported

function script_ExtractSubGraphArray shortHkey, scriptHkey, pSetName, pTestExceptions
   put hkey_GetLinkArray (scriptHkey) into scriptHkeyArray
   put hkeyArray_ExtractSubArray (shortHkey, hkeyArray) into hKeySubGraphArray
   return hKeySubGraphArray
end script_ExtractSubGraphArray

function hkey_ConstructShortKeyArray hKeys
   repeat for each line hKey in hKeys
      hkey_Deconstruct hKey, hName, hType, hObject, hNum
      put hName,hType into shortHkey
      put empty into shortHkeyArray [shortHkey][hKey]
   end repeat
   return shortHkeyArray
end hkey_ConstructShortKeyArray
