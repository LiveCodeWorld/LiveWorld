script "lib_HkeyArray"
--> MetaData
-
license: GPLv3
name: lib_HkeyArray
type: script library
version: 0.1


/* libOPN_Hkey
A library for script analysis using hKeys.

An hKey is a unique reference to a handler. It is constructed as follows:
--    handlerName,scriptObject,handlerNum,handlerType

The handlers in this library are gradually being moved over from the older script libraries,
with the "script_" extension being replaces by "hkey_"
*/

--> Currently Working On
-


--> HkeyArray | Objects
-
function hkeyArray_ConstructTreeArray hKeyArray
   local treeArray
   
   put keys (hKeyArray) into sortedHkeys
   sort sortedHkeys by item 1 of each
   
   repeat for each line sortedHkey in sortedHkeys
     _addToDepKeyArray treeArray, sortedHkey, hKeyArray
   end repeat
   return treeArray
end hkeyArray_ConstructTreeArray

function hkeyArray_ConstructObjectTreeArray objectHKeyArray
   put keys (objectHKeyArray) into sortedObjects
   sort sortedObjects
   
   repeat for each line sortedObject in sortedObjects
      put objectHKeyArray [sortedObject] into depHkeys
      sort depHkeys by item 1 of each
      put empty into depKeyArray
      repeat for each line depHkey in depHkeys
         -- put empty into parentHkey -- here we should dig into reversed array
         put item 1 of depHkey into hName
         put item 2 of depHkey into hType
         put hName & "_" & hType into displayName
         
         put hName into depKeyArray [displayName]["hName"]
         put hType into depKeyArray [displayName]["hType"]
         put item 3 of depHkey into depKeyArray [displayName]["hObject"]
         put item 4 of depHkey into depKeyArray [displayName]["hNum"]
      end repeat
      put depKeyArray into prettyObjectArray [sortedObject]
   end repeat
   return prettyObjectArray
end hkeyArray_ConstructObjectTreeArray

function hkeyArray_ConstructObjectArray hkeyArray, pPretty
   put array_AllNodes (hkeyArray) into allCalls
   
   repeat for each line hKey in allCalls
      put item 3 of hKey into someObject
      if pPretty is not false then
         if exists (someObject) then put the mobile_Name of someObject into someObject
      end if
      
      put objectArray [someObject] into hKeys
      line_Add hKey, hKeys
      put hKeys into objectArray [someObject]
   end repeat
   return objectArray
end hkeyArray_ConstructObjectArray


--> HkeyArray | Props
-
getprop hKeyArray_ConstructNodeSection [hKey]
   put the long id of the target into graphController
   
   put hkey_GetOverlayData (hKey) into graphData
   linkArray_DeconstructDataArray graphData, hLinkArray, hIdLinkArray, hIdArray, reversedIdArray
   put graphData ["geometry"] into geometryArray
   
   put the node_TypeArray of graphController into nodeTypeArray
   put hKeyArray_ConstructNodeSection (hIdArray, hLinkArray, graphController, nodeTypeArray) into nodeSection
   return nodeSection
end hKeyArray_ConstructNodeSection

function hkey_LinkTypeArray idArray
   -- this is what splits the nodes into types
   repeat for each key nodeID in idArray
      put idArray [nodeID] into hKey
      hkey_Deconstruct hKey, handlerName, handlerType, scriptObject, handlerNum
      array_AddToIndex nodeID, handlerType, IdTypeArray
   end repeat
   return IdTypeArray
end hkey_LinkTypeArray


--> HkeyArray
-
function hkeyArray_DepSuite hkeyArray, scriptObject, pStripProps, pStripObjects, pNotifyMissing
   hkeyArray_ConstructDependencySuite hkeyArray, scriptObject, depSuite, pStripObjects, pStripProps, pNotifyMissing
   return depSuite
end hkeyArray_DepSuite


--> HkeyArray | Convert
-
function hkeyArray_ConstructLongArray hKey, shortHkeyArray, pSetName
   local longHkeyArray
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   put hName,hType into shortHKey
   
   hkeyArray_ConstructLongSubArray shortHKey, hObject, shortHkeyArray, longHkeyArray, pSetName
   return longHkeyArray
end hkeyArray_ConstructLongArray

command hkeyArray_ConstructLongSubArray shortHKey, hObject, shortHkeyArray, @longHkeyArray, pSetName
   /*
   This is a better more readable format than the one generated by the simple walk.
   Hkeys without children are listed as keys, so you can see them.
   Also array_AllNodes (hkeyArray) = keys (hkeyArray) which makes things faster
   They shoudlgraph the same.
   */
   local longChildKeys
   
   put item 1 of shortHKey into callName
   put item 2 of shortHKey into callType
   
   put hkey_Construct (callName, callType, hObject, 1) into longHkey
   
   if longHkey is among the keys of longHkeyArray then
      -- already indexed (don't recurse)
      return empty
   end if
   
   put shortHkeyArray [shortHKey] into shortChildKeys
   put hkey_ShortToLongCalls (shortChildKey, hObject, pSetName) into longChildKeys
   put longChildKeys into longHkeyArray [longHkey]
   
   -- now recurse
   repeat for each line childHkey in longChildKeys
      hkey_Deconstruct childHkey, childName, childType, childObject, childNum
      put childName,childType into shortChildKey
      hkeyArray_ConstructLongSubArray shortChildKey, childObject, shortHkeyArray, longHkeyArray, pSetName
   end repeat
end hkeyArray_ConstructLongSubArray

function hkey_ShortToLongCalls shortKeys, hObject, pSetName
   repeat for each line shortKey in shortKeys
      
      put item 1 of shortKey into callName
      put item 2 of shortKey into callType
      
      if exists (hObject) is false then
         put hkey_Construct (callName, callType, "missing", 1) into foundCall
      else
         put the hkey_SearchHierarchy [pSetName] of hObject into scriptHierarchy
         hkey_AddDevelopmentHierarchy scriptHierarchy
         hkey_FindHandlerInHierarchy callName, callType, hObject, scriptHierarchy, foundHkey, callHandler
         if foundHkey is empty then
            if hkey_MissingHandlerIsNotImportant (callName, callType) is true then
               -- it is missing but prob a get/setprop so don't bother graphing
               next repeat
            else
               put hkey_Construct (callName, callType, "missing", 1) into foundHkey
            end if
         end if
      end if
      put foundHkey & CR after foundHkeys
   end repeat
   delete char -1 of foundHkeys
   return foundHkeys
end hkey_ShortToLongCalls       


--> HkeyArray | children
-
function hkeyArray_ExtractParentKeys hKey, hKeyArray
   repeat for each key parentKey in hKeyArray
      if hkey is among the lines of hKeyArray [parentKey] then
         put parentKey & CR after parentKeys
      end if
   end repeat
   delete char -1 of parentKeys
   return parentKeys
end hkeyArray_ExtractParentKeys

function hkeyArray_ExtractSubArray hKey, hkeyArray
   local subArray
   hkeyArray_ConstructSubArray hKey, hkeyArray, subArray
   return subArray
end hkeyArray_ExtractSubArray

function hkeyArray_ExtractParentHkeys hKey, hkeyArray
   repeat for each key parentHkey in hkeyArray
      put hkeyArray [parentHkey] into childHkeys
      if hKey is among the lines of childHkeys then
         put parentHkey & CR after parentHkeys
      end if
   end repeat
   delete char -1 of parentHkeys
   return parentHkeys
end hkeyArray_ExtractParentHkeys

function hkeyArray_ExtractParentsAndChildrenArray hKey, hkeyArray
   local subArray
   hkeyArray_ConstructSubArray hKey, hkeyArray, subArray
   hkeyArray_ConstructParentArray hKey, hkeyArray, subArray
   return subArray
end hkeyArray_ExtractParentsAndChildrenArray

function hkeyArray_ExtractParentArray hKey, hkeyArray
   local parentArray
   hkeyArray_ConstructParentArray hKey, hkeyArray, parentArray
   return parentArray
end hkeyArray_ExtractParentArray

command hkeyArray_ConstructParentArray hKey, hkeyArray, @parentArray
   set the wholematches to true
   repeat for each key maybeParentKey in hkeyArray 
      put hkeyArray [maybeParentKey] into childKeys
      if hKey is among the lines of childKeys then
         -- beware circular recursion (has hKey already been indexed?)
         if maybeParentKey is among the keys of parentArray then
            next repeat
         end if
         
         array_AddToIndex hKey, maybeParentKey, parentArray
         hkeyArray_ConstructParentArray maybeParentKey, hkeyArray, parentArray
      end if
   end repeat
end hkeyArray_ConstructParentArray

command hkeyArray_ConstructSubArray hKey, hkeyArray, @subArray
   -- see also "linkArray_WalkKeys"
   put hkeyArray [hKey] into childKeys
   if childKeys is empty then return hkeyArray
   
   put childKeys into subArray [hKey]
   
   repeat for each line childKey in childKeys
      put keys(subArray) into indexedSoFar
      if childKey is among the lines of indexedSoFar then
         next repeat -- a recursive hKey that is already added to subArray
      end if
      hkeyArray_ConstructSubArray childKey, hkeyArray, subArray
   end repeat
end hkeyArray_ConstructSubArray


--> HkeyArray | Objects
-
function hKeyArray_ExtractObjectArray someObject, hKeyLinkArray, pIncludeParents
   if pIncludeParents is true then
      put hKeyArray_ObjectAndParentArray (someObject, hKeyLinkArray) into objectArray
   else
      put hKeyArray_ObjectArray (someObject, hKeyLinkArray) into objectArray
   end if
   return objectArray
end hKeyArray_ExtractObjectArray

function hKeyArray_ObjectArray someObject, hKeyLinkArray
   local objectArray
   put the rugged_Id of someObject into someObject
   repeat for each key hKey in hKeyLinkArray  
      hkey_Deconstruct hKey, handlerName, handlerType, keyObject, handlerNum
      if exists(keyObject) is false then next repeat
      put hKeyLinkArray [hKey] into keyLinks
      
      put empty into insideObjectLinks
      repeat for each line hkeyLink in keyLinks
         if item 3 of hkeyLink = someObject then
            put hkeyLink & CR after insideObjectLinks
         end if
      end repeat
      delete char -1 of insideObjectLinks
      
      if insideObjectLinks is empty then
         if keyObject = someObject and hkey is not among the keys of objectArray then
            -- may be no internal links, but could be a link from outside
            put empty into objectArray [hKey]
         end if
      else if keyObject = someObject then
         put insideObjectLinks into objectArray [hKey]
      else
         repeat for each line insideObjectLink in insideObjectLinks
            if insideObjectLink is not among the keys of objectArray then
               -- may be no internal links, but could be a link from outside
               put empty into objectArray [insideObjectLink]
            end if
         end repeat
      end if
   end repeat
   return objectArray
end hKeyArray_ObjectArray

function hKeyArray_ObjectAndParentArray someObject, hKeyLinkArray
   -- extracts all object hKeys and their parents outside the object.
   local objectArray
   put the rugged_Id of someObject into someObject
   repeat for each key hKey in hKeyLinkArray  
      hkey_Deconstruct hKey, handlerName, handlerType, keyObject, handlerNum
      if exists(keyObject) is false then next repeat
      put hKeyLinkArray [hKey] into keyLinks
      
      put empty into insideObjectLinks
      repeat for each line hkeyLink in keyLinks
         if item 3 of hkeyLink = someObject then
            put hkeyLink & CR after insideObjectLinks
         end if
      end repeat
      delete char -1 of insideObjectLinks
      
      if insideObjectLinks is empty then
         if keyObject = someObject and hkey is not among the keys of objectArray then
            -- may be no internal links, but could be a link from outside
            put empty into objectArray [hKey]
         end if
      else
         put insideObjectLinks into objectArray [hKey]
      end if
   end repeat
   return objectArray
end hKeyArray_ObjectAndParentArray


--> hkeyArray | Object | Delete
-
command hkeyArray_RemoveObjectLinks @hkeyArray, objectToRemove
   -- assumes all objects in hkeyArray are rugged ids
   -- may need to check long ids?
   put the rugged_ID of objectToRemove into objectToRemove
   
   put array_AllNodes (hkeyArray) into hkeysToStrip
   filter hkeysToStrip with ("*," & objectToRemove & ",*")
   
   local alreadyDeleted
   repeat for each line stripKey in hkeysToStrip
      linkArray_DeleteNode hkeyArray, stripKey, alreadyDeleted
   end repeat
   put array_AllNodes (hkeyArray) into keysLeft
   return keysLeft
end hkeyArray_RemoveObjectLinks

private command hkeyArray_RemoveObjectLinksBit @hkeyArray, fromKey, objectToRemove
   put hkeyArray [fromKey] into toKeys
   repeat for each line toKey in toKeys
      hkey_Deconstruct toKey, toName, toType, toObject, toNum
      if exists (toObject) then
         if the long id of toObject is not objectToRemove then
            put toKey & CR after newToKeys
         end if
      end if
   end repeat
   delete char -1 of newToKeys
   put newToKeys into hkeyArray [fromKey]
end hkeyArray_RemoveObjectLinksBit

function hkeyArray_DeleteObject someObject, hkeyArray
    set the wholematches to true
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        if exists(scriptObject) is false then
            if someObject is scriptObject then
                -- Missing
                delete local hkeyArray [hKey]
                next repeat
            else
                next repeat
            end if
        end if
         
        if the long id of someObject = the long id of scriptObject then
            delete local hkeyArray [hKey]
            next repeat
        end if
        
        put hkeyArray [hKey] into handlerCalls
        put empty into filteredCalls
        repeat for each line callKey in handlerCalls
            script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
            if exists(callObject) is false then
                if someObject is callObject then
                    -- Missing
                    next repeat
                else
                    put callKey & CR after filteredCalls
                    next repeat
                end if
            end if
            if the long id of callObject is not the long id of scriptObject then
                put callKey & CR after filteredCalls
            end if
        end repeat
        delete last char of filteredCalls
        put filteredCalls into hkeyArray [hKey]
    end repeat
    return hkeyArray
end hkeyArray_DeleteObject


--> hkeyArray | Object | Replace
-
function hkeyArray_HandlerLinkToObjectLink someObject, hkeyArray
    set the wholematches to true
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        if exists(scriptObject) is false then
            if someObject is scriptObject then
                -- Missing
                put hkey_Construct ("Missing", handlerType, scriptObject, handlerNum) into generalKey
                put generalKey into hkeyArray [hKey]
                next repeat
            else
                next repeat
            end if
        end if
         
        if the long id of someObject = the long id of scriptObject then
            put hkey_Construct ("General", handlerType, scriptObject, handlerNum) into generalKey
            put generalKey into hkeyArray [hKey]
            next repeat
        end if
        
        put hkeyArray [hKey] into handlerCalls
        put empty into filteredCalls
        repeat for each line callKey in handlerCalls
            script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
            if exists(callObject) is false then
                if someObject is callObject then
                    -- Missing
                    put hkey_Construct ("Missing", handlerType, callObject, handlerNum) into generalKey
                    put generalKey & CR after filteredCalls
                    next repeat
                else
                    put callKey & CR after filteredCalls
                    next repeat
                end if
             end if
             
            if the long id of callObject is not the long id of scriptObject then
                put hkey_Construct ("General", handlerType, callObject, handlerNum) into generalKey
                put generalKey & CR after filteredCalls
            end if
        end repeat
        delete last char of filteredCalls
        put filteredCalls into hkeyArray [hKey]
    end repeat
    return hkeyArray
end hkeyArray_HandlerLinkToObjectLink

command hkeyArray_ReplaceWithObject stackObject, @hkeyArray
   -- seems like an old version of "hkeyArray_HandlerLinkToObjectLink"???
   repeat for each key hKey in hkeyArray
      script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
      
      put hkeyArray [hKey] into hKeyLinks
      put empty into newLinks
      repeat for each line hKeyLink in hKeyLinks
         script_DeconstructHkey hKeyLink, linkName, linkType, linkNum, linkObject
         if exists (linkObject) is false then
            line_Insert hKeyLink, newLinks
         else
            get the stack_Object of linkObject
            if it is stackObject then
               line_Insert hKeyLink, newLinks
            else if linkObject = scriptObject then
               -- actually anywhere in the path
               next repeat
            else
               line_Add linkObject, newLinks
            end if
         end if
      end repeat
      
      if exists(scriptObject) is false then
         put newLinks into hkeyArray [hKey]
      else
         get the stack_Object of scriptObject
         if it is stackObject then
            put newLinks into hkeyArray [hKey]
         else
            put newLinks into hkeyArray [scriptObject]
         end if
      end if
   end repeat
end hkeyArray_ReplaceWithObject


--> hkeyArray | Object | Filter
-
command hkeyArray_FilterOutExternalObjects @hKeyArray, scriptObject, pIncludeSecondGen
   -- does not work ???
   -- think this may be as simple as only taking firstkeys! (ie no need to recurse and check :)
   local filteredLinkArray
   put keys (hKeyArray) into firstKeys
   repeat for each line firstKey in firstKeys
      hkey_Deconstruct firstKey, handlerName, firstType, firstScriptObject, firstNum
      if exists(firstScriptObject) is not true then next repeat
      if the long id of firstScriptObject = the long id of scriptObject then
         recurse_FilterOutExternalObjects firstKey, hKeyArray, scriptObject, filteredLinkArray, pIncludeSecondGen
      end if
   end repeat
   put filteredLinkArray into hKeyArray
end hkeyArray_FilterOutExternalObjects

private command recurse_FilterOutExternalObjects hKey, hKeyArray, originalObject, @filteredLinkArray, pIncludeSecondGen
   set the cursor to busy
   hkey_Deconstruct hKey, handlerName, handlerType, scriptObject, handlerNum
   if exists(scriptObject) is true then
      if the long id of scriptObject = the long id of originalObject then
         -- allways add internal calls
         put hKeyArray [hKey] into hKeyChildren  
         put hKeyChildren into filteredLinkArray [hKey]
         repeat for each line hKeyChild in hKeyChildren
            if hkeyChild is among the keys of filteredLinkArray then
               next repeat
            end if
            recurse_FilterOutExternalObjects hKeyChild, hKeyArray, originalObject, filteredLinkArray, pIncludeSecondGen
         end repeat
      else
         -- hKey is outside of originalObject
         -- if it is first time => not added to filteredLinkArray (yet)
         -- if it is first level recursion => hKey has been already added as a child to filteredLinkArray
         -- don't recurse
         if pIncludeSecondGen is true then
            put hKeyArray [hKey] into externalChildren
            if externalChildren is not empty then
               put externalChildren into filteredLinkArray [hKey]
            end if
         end if
      end if
   else
      -- script object is missing
      -- put empty into filteredLinkArray [hKey]
   end if
end recurse_FilterOutExternalObjects

function hkeyArray_ExtractObjects hkeyArray
    local arrayObjects
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        line_Add scriptObject, arrayObjects
        
        put hkeyArray [hKey] into handlerCalls
        repeat for each line callKey in handlerCalls
            script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
            line_Add callObject, arrayObjects
        end repeat
    end repeat
    return arrayObjects
end hkeyArray_ExtractObjects

function hkeyArray_ExtractObject someObject, hkeyArray
    local filteredHkeys
    
    set the wholematches to true
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        if exists(scriptObject) is false then
            -- skip "missing"
            next repeat
        else if the long id of someObject is the long id of scriptObject then
            line_Add hKey, filteredHkeys
        else
            put hkeyArray [hKey] into handlerCalls
            repeat for each line callKey in handlerCalls
                script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
                if exists(callObject) is false then
                    -- skip Missing
                    next repeat
                else if the long id of someObject = the long id of callObject then
                    line_Add callKey, filteredHkeys
                end if
            end repeat
        end if
    end repeat
    return filteredHkeys
end hkeyArray_ExtractObject

command hKeyArray_SetWithinObject @hKeyLinkArray, withinObject
   put the long id of withinObject into withinObject
   put "handlers" into withinObjectKey
   
   repeat for each key hKey in hKeyLinkArray
      put hKeyLinkArray [hKey] into keyLinks
      hkey_Deconstruct hKey, handlerName, handlerType, keyObject, handlerNum
      if exists(keyObject) is true then put the long id of keyObject into keyObject
      
      if keyObject contains withinObject then
         put withinObjectKey into fromKey -- keyObject is within withinObject
      else
         put hKey into fromKey
      end if
      
      -- lets work out new links
      put empty into newKeyLinks
      repeat for each line keyLink in keyLinks
         hkey_Deconstruct keyLink, handlerName, handlerType, keyLinkObject, handlerNum
         if exists(keyLinkObject) is true then put the long id of keyLinkObject into keyLinkObject
         
         if keyLinkObject contains withinObject then
            -- line_Add withinObjectKey, newKeyLinks
            -- put CR after newKeyLinks
         else
            put keyLink & CR after newKeyLinks
         end if
      end repeat
      put word 1 to -1 of newKeyLinks into newKeyLinks
      
      put newLinkArray [fromKey] into oldLinks
      line_Add oldLinks, newKeyLinks
      put newKeyLinks into newLinkArray [fromKey]
   end repeat
   put newLinkArray into hKeyLinkArray
end hKeyArray_SetWithinObject

function hKeyArray_InsideAndOut hKeyLinkArray, withinObject
   put the long id of withinObject into withinObject
   repeat for each key hKey in hKeyLinkArray
      hkey_Deconstruct hKey, handlerName, handlerType, keyObject, handlerNum
      if exists(keyObject) is false then
         put empty into insideOutArray ["missing"][hKey]
      else
         put the long id of keyObject into keyObject
         if keyObject contains withinObject then
            put empty into insideOutArray ["inside"][hKey]
         else
            put empty into insideOutArray ["outside"][hKey]
         end if
      end if
      
      -- lets work out new links
      put empty into newKeyLinks
      put hKeyLinkArray [hKey] into keyLinks
      repeat for each line keyLink in keyLinks
         hkey_Deconstruct keyLink, handlerName, handlerType, keyLinkObject, handlerNum
         if exists(keyLinkObject) is false then 
            put empty into insideOutArray ["missing"][keyLink]
            next repeat
         end if
         
         put the long id of keyLinkObject into keyLinkObject
         if keyLinkObject contains withinObject then
            put empty into insideOutArray ["inside"][keyLink]
         else
            put empty into insideOutArray ["outside"][keyLink]
         end if
      end repeat
   end repeat
   return insideOutArray
end hKeyArray_InsideAndOut

function hKeyArray_NodeIdsInObject someObject, hIdArray
   -- was "hKeyArray_NodeIdsInObject"
   if exists(someObject) then
      put the long id of someObject into objectTest
   else
      put someObject into objectTest
   end if
   repeat for each key hId in hIdArray
      put hIdArray [hID] into hKey
      hkey_Deconstruct hKey, handlerName, handlerType, scriptObject, handlerNum
      if exists(scriptObject) then
         put the long id of scriptObject into scriptTest
      else
         put scriptObject into scriptTest
      end if
      put scriptTest = objectTest into insideObject
      if insideObject is true then
         put hID & CR after hIDs
      end if
   end repeat
   delete char -1 of hIDs
   return hIDs
end hKeyArray_NodeIdsInObject


--> hKeyArray | Filter
-
command hKeyArray_DeleteHandler @hKeyLinkArray, handlerName, handlerType
   -- deletes named nodes
   -- and named nodes in links
   local alreadyDeleted
   repeat for each key hKey in hKeyLinkArray
      put hKeyLinkArray [hKey] into subKeys
      
      put hKey_IsHandler(hKey, handlerName, handlerType) into isNamedHandler
      if isNamedHandler then
         linkArray_DeleteNode hKeyLinkArray, hKey, alreadyDeleted
      end if
      
      put empty into goodSubKeys
      repeat for each line subKey in subKeys
         if hKey_IsHandler(subKey, handlerName, handlerType) is false then
            put subKey & CR after goodSubKeys
         end if
      end repeat
      delete char -1 of goodSubKeys
      
      -- if goodSubKeys is empty then
      -- in case
      -- delete local hKeyLinkArray [hKey]
      if isNamedHandler is false then
         put goodSubKeys into hKeyLinkArray [hKey]
      end if
   end repeat
end hKeyArray_DeleteHandler

command hKeyArray_FilterSystemMessages @hKeyLinkArray
   put rev_MessageNames() into revMessageNames
   put keys(hKeyLinkArray) into hKeys
   repeat for each line hKey in hKeys
      if item 1 of hKey is among the lines of revMessageNames then
         -- only delete end nodes not start nodes
         if item 4 of hKey is "Missing" then
            delete local hKeyLinkArray [hKey]
            next repeat
         end if
      end if
      
      put hKeyLinkArray [hKey] into subKeys
      put empty into goodSubKeys
      repeat for each line subKey in subKeys
         if item 1 of subKey is among the lines of revMessageNames then
            if item 4 of subKey is "missing" then
               next repeat
            end if
         end if
         put subKey & CR after goodSubKeys
      end repeat
      delete char -1 of goodSubKeys
      put goodSubKeys into hKeyLinkArray [hKey]
   end repeat
end hKeyArray_FilterSystemMessages

command hKeyArray_FilterCustomMissing @hKeyLinkArray
   repeat for each key hKey in hKeyLinkArray
      if hKey_IsMissingProperty(hKey) then
         delete local hKeyLinkArray [hKey]
      else
         put empty into goodSubKeys
         repeat for each line subKey in hKeyLinkArray [hKey]
            if hKey_IsMissingProperty(subKey) is false then
               put subKey & CR after goodSubKeys
            end if
         end repeat
         delete char -1 of goodSubKeys
         put goodSubKeys into hKeyLinkArray [hKey]
      end if
   end repeat
end hKeyArray_FilterCustomMissing

command hkeyArray_ConstructDependencySuite hkeyArray, pStripScriptObject, @depSuite, pStripObjects, pStripProps, pNotifyMissing
   local depScript
   
   put array_AllNodes (hkeyArray) into allCalls
   hkey_StripDuplicates allCalls
   put the result into duplicateHkeyArray
   
   if exists (pStripScriptObject) is true then
      -- strip the nodes from the scriptObject whose hkeyArray we are processing
      hkey_SimpleStripObject allCalls, pStripScriptObject
      put the result into strippedKeys
   end if
   
   if pStripProps is true then
      -- this does not do a network walk (does this matter?)
      hkey_StripGetProps allCalls
      line_Add the result, strippedKeys
      
      hkey_StripSetProps allCalls
      line_Add the result, strippedKeys
   end if
   
   -- now let's recursively strip the nodes from the objects in pStripObjects we don't want
   repeat for each line stripObject in pStripObjects
      -- take care that the object name is fromatted correctly
      if exists(stripObject) is false then
         put merge ("Cannot find [[stripObject]]!") into someMessage
         opn_Notify someMessage, true
         next repeat
      end if
      
      -- lets get rid of any calls to the objects we are stripping
      -- hkeyArray_RemoveObjectLinks hkeyArray, stripObject
      hkey_SimpleStripObject allCalls, stripObject
      line_Add the result, strippedKeys
   end repeat
   
   sort allCalls
   
   -- put script_ConstructDependencySuite (allCalls) into depSuite
   local missingHkeys
   script_FetchFromHkeys allCalls, depScript, missingHkeys, pNotifyMissing
   put script_ConstructSuite ("Deps", depScript) into depSuite
   
   put allCalls into someArray ["uniqueHkeys"]
   put strippedKeys into someArray ["strippedKeys"]
   put missingHkeys into someArray ["missingHkeys"]
   put duplicateHkeyArray into someArray ["duplicateHkeyArray"]
   return someArray
end hkeyArray_ConstructDependencySuite

function hKeyArray_DotNodeLinks linkArray, pNodeIDs, pTargetObject
   -- this seems specific to scripts?
   -- put the graph_Model of the target  into graphModel
   
   if pNodeIDs is empty then put keys(linkArray) into pNodeIDs
   repeat for each line someKey in pNodeIDs
      put linkArray [someKey] into someLinks
      
      if exists (pTargetObject) then
         get the dot_NodeID [someKey] of pTargetObject
         if it is not empty then put it into someKey
      end if
      repeat for each line someLink in someLinks
         if exists (pTargetObject) then
            get the dot_NodeID [someLink] of pTargetObject
            if it is not empty then put it into someLink
         end if
         put someKey && "->" && someLink & ";" & CR after linkSection
      end repeat
   end repeat
   delete char -1 of linkSection
   return linkSection
end hKeyArray_DotNodeLinks


--> Hkey | Array | Not Tested
-
function hKeyArray_ConstructNodeSection hIdArray, hLinkArray, pGraphController, nodeTypeArray
   repeat for each key handlerType in nodeTypeArray
      put nodeTypeArray [handlerType] into nodeIDs
      if nodeIDs is not empty then
         put hKeyArray_ConstructSubGraph (nodeIDs, hIdArray, handlerType, pGraphController) & CR after colourDefs
      end if
   end repeat
   
   -- node defs
   put hKeyArray_DotNestedObjectClusters (hIdArray, hLinkArray) into clusterDefs  -- specific (construct object clusters)
   put colourDefs & CR & CR & clusterDefs into defSection
   
   -- node links
   put linkArray_DotNodeLinks (hLinkArray, empty) into linkSection
   if defSection is empty then
      return linkSection
   else
      return defSection & CR & CR & linkSection
   end if
end hKeyArray_ConstructNodeSection

function hkeyArray_ExtractEventKeys hkeyArray
    put keys(hkeyArray) into hKeys
    put rev_MessageNames() into revMessageNames
    repeat for each line hKey in hKeys
        if item 1 of hKey is among the lines of revMessageNames then
            put hKey & CR after hKeys
        end if
    end repeat
    delete char -1 of hKeys
    return hKeys
end hkeyArray_ExtractEventKeys

command hkeyArray_StripNonLinked @hkeyArray, topKey
    -- should keep repeating / recursing
    put array_Reverse(hkeyArray) into reversedArray
    repeat for each key hKey in reversedArray
        if hKey = topKey then next repeat
        if reversedArray [hKey] is empty then
            linkArray_DeleteNode hkeyArray, hKey
        end if
    end repeat
end hkeyArray_StripNonLinked

function hkeyArray_InternalLinks hkeyArray, targetObject
    set the wholematches to true
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        if exists(scriptObject) is false then
            next repeat
        end if
         
        if object_Contains(targetObject, scriptObject) is false then
            delete local hkeyArray [hKey]
        else
            put hkeyArray [hKey] into handlerCalls
            put empty into filteredCalls
            repeat for each line callKey in handlerCalls
                script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
                if exists(callObject) is false then
                    put callKey & CR after filteredCalls
                    next repeat
                end if
                if object_Contains(targetObject, callObject) then
                    put callKey & CR after filteredCalls
                end if
            end repeat
            delete last char of filteredCalls
            put filteredCalls into hkeyArray [hKey]
        end if
    end repeat
    return hkeyArray
end hkeyArray_InternalLinks

function hkeyArray_ExternalLinks hkeyArray, targetObject
    set the wholematches to true
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        if exists(scriptObject) is false then
            next repeat
        end if
         
        if object_Contains(targetObject, scriptObject) then
            delete local hkeyArray [hKey]
        else
            put hkeyArray [hKey] into handlerCalls
            put empty into filteredCalls
            repeat for each line callKey in handlerCalls
                script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
                if exists(callObject) is false then
                    next repeat
                end if
                if object_Contains(targetObject, callObject) then
                    -- delete
                else
                    put callKey & CR after filteredCalls
                end if
            end repeat
            delete last char of filteredCalls
            put filteredCalls into hkeyArray [hKey]
        end if
    end repeat
    return hkeyArray
end hkeyArray_ExternalLinks

function hkeyArray_ExtractCalls hkeyArray, hKeys
    -- do the hKey nodes that are in the object   (delete from array when done)
    put empty into hKeyCalls
    repeat for each line hKey in hKeys
        put hkeyArray [hKey] into firstHkeyCalls
        line_Delete hKeys, firstHkeyCalls
        line_Add firstHkeyCalls, hKeyCalls
        delete local hkeyArray [hKey] 
    end repeat
     
    -- now do the hKey nodes that were not in the object 
    repeat for each key hKey in hkeyArray
        line_Add hKey, hKeyCalls
         
        put hkeyArray [hKey] into firstHkeyCalls
        line_Delete hKeys, firstHkeyCalls
        line_Add firstHkeyCalls, hKeyCalls
    end repeat
    return hKeyCalls
end hkeyArray_ExtractCalls

function hkeyArray_GetFiltered
    put the linkArray_Model of me into modelObject
    put model_GetArray("Filtered_hkeyArray", modelObject, "array") into hkeyArray
    return hkeyArray
end hkeyArray_GetFiltered

command hkeyArray_SetFiltered hkeyArray
    put the linkArray_Model of me into modelObject
    model_SetArray "Filtered_hkeyArray", modelObject, hkeyArray, "array"
end hkeyArray_SetFiltered

function hkeyArray_ConstructDot hkeyArray, graphName, graphStyle, graphSize
    local graphDirection, graphOrder, defaultShape
    
    set the cursor to watch
     
    if the filter_System of me is true then hKeyArray_FilterSystemMessages hkeyArray
    if the fllter_CustomMissing of me  is true then hKeyArray_FilterCustomMissing hkeyArray
    if graphSize is empty then
        put the dot_GraphSize of me into graphSize
        put dot_RectFromSize(graphSize) into graphRect
    end if
    
    put the overlay_Overlap of me into overlap
    put the concentrate_Graph of me into concentrate
    put true into splines
    if graphstyle = "clusters" then
        put true into clusterGraph
    else
        put false into clusterGraph
    end if
    
    dot_ConstructHeaderArray dotPropertyArray, overlap, concentrate, true
    put dot_ConstructHeader (graphRect, dotPropertyArray) into graphHeader
    put dot_NestedSubgraphsFromhkeyArray (hkeyArray, clusterGraph, graphName, graphHeader) into dotText
    
    return dotText
end hkeyArray_ConstructDot


--> Hkey | Array | Extract
-
function hkeyArray_ExtractHandlers hkeyArray
    local hKeys
    local arrayObjects
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        line_Add hKey, hKeys
        
        put hkeyArray [hKey] into handlerCalls
        line_Add handlerCalls, hKeys
    end repeat
    sort hKeys
    return hKeys
end hkeyArray_ExtractHandlers

function hkeyArray_ExtractMissingArray hkeyArray, fllterSystem, filterCustomMissing
    local filteredHkeyArray, noCallKeys
    
    set the wholematches to true
    repeat for each key hKey in hkeyArray
        set the cursor to busy
        
        script_DeconstructHkey hKey, handlerName, handlerType, handlerNum, scriptObject
        if exists(scriptObject) is false then
            if fllterSystem is true and handlerType is "m" then next repeat
            if filterCustomMissing is true and handlerType is among the items of "g,s" then next repeat
            line_Add hKey, noCallKeys
        else
            put hkeyArray [hKey] into handlerCalls
            repeat for each line callKey in handlerCalls
                script_DeconstructHkey callKey, handlerName, handlerType, handlerNum, callObject
                if exists(callObject) is false then
                    if fllterSystem is true and handlerType is "m" then next repeat
                    if filterCustomMissing is true and handlerType is among the items of "g,s" then next repeat
                    array_AddToIndex callKey, hKey, filteredHkeyArray
                end if
            end repeat
        end if
    end repeat
    
    put array_AllNodes(filteredHkeyArray) into missingKeys
    line_Delete missingKeys, noCallKeys
    if noCallKeys is not empty then
        put noCallKeys into filteredHkeyArray ["Missing Solo"]
    end if
    return filteredHkeyArray
end hkeyArray_ExtractMissingArray


--> Private
-
private command _addToDepKeyArray @treeArray, sortedHkey, hKeyArray
   put hKeyArray [sortedHkey] into depHkeys
   sort depHkeys by item 1 of each
   put empty into depKeyArray
   repeat for each line depHkey in depHkeys
      -- put empty into parentHkey -- here we should dig into reversed array
      put item 1 of depHkey into hName
      put item 2 of depHkey into hType
      put hName & "_" & hType into displayName
      
      put hName into depKeyArray [displayName]["hName"]
      put hType into depKeyArray [displayName]["hType"]
      put item 3 of depHkey into depKeyArray [displayName]["hObject"]
      put item 4 of depHkey into depKeyArray [displayName]["hNum"]
   end repeat
   replace comma with slash in sortedHkey
   put depKeyArray into treeArray [sortedHkey]
end _addToDepKeyArray


--> Deps
-
function array_AllNodes someArray
   -- unique index of all elements and keys in an array (not for nested arrays)
   local indexArray
   repeat for each key someKey in someArray
      put empty into indexArray [someKey]
      put someArray [someKey] into keyElements
      if keyElements is an array then
         repeat for each key keyElement in keyElements
            if word 1 to -1 of keyElement is empty then next repeat
            put empty into indexArray [keyElement]
         end repeat
      else if keyElements is not empty then
         repeat for each line keyElement in keyElements
            if word 1 to -1 of keyElement is empty then next repeat
            put empty into indexArray [keyElement]
         end repeat
      end if
   end repeat
   return keys (indexArray)
end array_AllNodes

