script "lib_Deps"
--> MetaData
-
license: GPLv3
name: lib_Deps
type: script library
version: 0.1

/*
A library to handle dependencies (in particular script dependencies).
It used to be in "libOPN_Deps"

It provides code for graphing dependencies, and extracting handlers required by a script or stack to function.
It also enables the automatic creation of depndency behavior scripts for libraries.

The Main Stack| Meta Array is the combined hArray and mainStackArray export format.

It superceded the older handlers below. 
There were some problems with stackObject references to substacks,
and the organisation requires some repetition in order to allow accumilation of hArray data as the parsing procedes.
In addition there is some duplication of data, particulalry the "scriptArray" and "objects" sections of the two main arrays.
This woud probably be much better stored in an sqlite database.
*/


--> Deps | Props
-
/*
The main code has been moved to the script only library "lib_Deps.

Here we list all custom property definitions, so we can organise and rationalise them before moving them to a more appropriate place.
These custom properties are important as dependencies refer to an objects script.
This means that it is useful to standardise on calling custom properties, rather than directly functions and commands.

This will provide and interface to a new "model library" for LiveCode dependencies.
All handlers should interface with these custom properties and perhaps the commands and functions should be private.
The issue with that is that at the moment there are propblems with custom properties and the Livecode / revIgniter server I beleive.
*/

getprop script_Hkeys [fetchHow]
   switch fetchHow
      case "hArray"
         return the hArray_Hkeys of the target
      case "script"
         return the script_ArrayHkeys of the target
      default -- case "revAvailableHandlers"
         return the script_FirstHkeys of the target
   end switch
end script_Hkeys

getprop script_FirstHkeys [returnShort]
   -- not in order found in script
   try
      put the long id of the target into tObject
      put revRuggedID (tObject) into tObject
      put the revAvailableHandlers of tObject into handlerTable
      repeat for each line someLine in handlerTable
         put word 1 of someLine into hTableType
         replace "M" with "c" in hTableType
         put tolower (hTableType) into hType
         
         put word 2 of someLine into hName
         if returnShort is true then
            put hName,hType & CR after hKeys
         else
            put hName,hType,tObject,1 & CR after hKeys -- revAvailableHandlers only return first handler.
         end if
      end repeat
      delete char -1 of hKeys
      return hKeys
   catch someError
      return empty -- a locked stack
   end try
end script_FirstHkeys

getprop hArray_Hkeys
   put the hArray_ScriptData of the target into scriptArray
   repeat for each key indexNum in scriptArray
      put scriptArray [indexNum]["hKey"] into hKey
      if hKey is not empty then
         put hKey & CR after hKeys
      end if
   end repeat
   delete char -1 of hKeys
   return hKeys
end hArray_Hkeys

getprop script_ArrayHkeys
   try
      put the script_Array of the target into scriptArray
      repeat for each key indexNum in scriptArray
         put scriptArray [indexNum]["hKey"] into hKey
         if hKey is not empty then
            put hKey & CR after hKeys
         end if
      end repeat
      delete char -1 of hKeys
      return hKeys
   catch someError
      return empty -- a locked stack
   end try
end script_ArrayHkeys


--> Deps | Handler
-
getprop script_Handler [shortHKey]
   if shortHKey is empty then return empty
   put the long id of the target into tObject
   put hkey_ExtractHandlerFromObject (hKey) into foundHandler
   return foundHandler
end script_Handler

getprop script_Handler [shortHKey]
   if shortHKey is empty then return empty
   try
      put the long id of the target into tObject
      put the revAvailableHandlers of tObject into handlerTable
      script_HandlerFromTableOffsets shortHkey, handlerTable, startLineNum, endLineNum
      if startLineNum = 0 then
         -- look for private handler?
         put "P" before item 2 of shortHkey
         script_HandlerFromTableOffsets shortHkey, handlerTable, startLineNum, endLineNum
         if startLineNum = 0 then
            return empty
         end if
      end if
      put the script of tObject into someScript
      return line startLineNum to endLineNum of someScript
   catch someError
      return empty -- a locked stack
   end try
end script_Handler

getprop mainStack_MetaArray [pHashArrayBoolean]
   local pLinkToViews, pExportHandlers, pDontDiff
   
   put the main_Stack of the target into mainStackObject
   
   if pHashArrayBoolean is empty then
      put pref_GetValue ("add object to hArray on export") is not false into createHarray
      put pref_GetValue ("Construct hashArray on stack export") is true into pHashArrayBoolean
   else
      put pHashArrayBoolean is true into pHashArrayBoolean
      pref_SetValue "Construct hashArray on stack export", pHashArrayBoolean
      if pHashArrayBoolean is true then
         pref_SetValue "Add object to hArray on stack export", true
         put true into createHarray
      else
         put pref_GetValue ("Add object to hArray on export") is not false into createHarray
      end if
   end if
   
   if createHarray and pHashArrayBoolean then
      -- only give option of constructing hkeyCalls handlerHashArray if we are also indexing a basic hArray
      put the textStack_Folder of the target into mainStackFolder
      put mainstack_FetchHandlerHashArray (mainStackFolder) into handlerHashArray
      if handlerHashArray is not an array then
         -- in cases where there is no previous index
         -- forces indexing of all hKeys in a new script
         put empty into hArray ["handlerHashArray"]["new"]
      else
         delete variable handlerHashArray ["actual"]
         delete variable handlerHashArray ["new"]
         put handlerHashArray into hArray ["handlerHashArray"]
      end if
   else
      put empty into hArray -- no "handlerHashArray" indexing of hKey calls, let's recreate the rest of hArray
   end if
   
   put true into pDontExport
   put false into pForceIndexHandlerCalls
   put mainstack_ConstructMetaArray (mainStackObject, hArray, pLinkToViews, pExportHandlers, pDontDiff, pDontExport, pForceIndexHandlerCalls) into metaArray
   return metaArray
end mainStack_MetaArray

getprop mainStack_Hash
   put the main_Stack of the target into mainStackObject
   put the filename of mainStackObject into someFile
   return file_Hash (someFile)
end mainStack_Hash

getprop object_HandlerHashArray
   put the rugged_ID of the target into rObject
   put the mainstack_HandlerHashArray of the target into mainStackHandlerHashArray
   
   put mainStackHandlerHashArray ["cached"] into cachedHashArray
   repeat for each key handlerHash in cachedHashArray
      put cachedHashArray [handlerHash]["hkey"] into emptyHkeyArray
      put keys(emptyHkeyArray) into hkey
      if item 3 of hkey = rObject then
         put cachedHashArray [handlerHash] into objectHandlerHashArray [handlerHash]
      end if
   end repeat
   return objectHandlerHashArray
end object_HandlerHashArray


--> Deps | Objects
-
getprop stack_BehaviorButton [bName]
   if bName is empty then put "Stack Handler Deps" into bName
   put the menu_SubStack of the target into menuSubStack
   if exists (btn bName of cd "Behaviors" of menuSubStack) is false then return empty
   return the long id of btn bName of cd "Behaviors" of menuSubStack
end stack_BehaviorButton

getprop stack_BehaviorButtonNames
   put the stack_BehaviorCard of the target into stackBehaviorCard
   if exists (stackBehaviorCard) is false then return empty
   repeat with btNum = 1 to the number of buttons of stackBehaviorCard
      put the short name of btn btNum of stackBehaviorCard & CR after stackBehaviorButtonNames
   end repeat
   delete char -1 of stackBehaviorButtonNames
   return stackBehaviorButtonNames
end stack_BehaviorButtonNames

getprop stack_BehaviorCard
   -- a default (overrride with a getprop handler in the stack script)
   put the menu_SubStack of the target into menuSubStack
   if exists (cd "Behaviors" of menuSubStack) is false then return empty
   return the long id of cd "Behaviors" of menuSubStack
end stack_BehaviorCard

getprop main_Stack
   put the stack_Object of the target into stackObject
   put the mainstack of stackObject into stackName
   return the name of stack stackName
end main_Stack


--> Hkey | Search | Deps
-
command hkey_AddDevelopmentHierarchy @scriptHierarchy, pProjectName
   if pProjectName = "none" then return empty -- let's just use the object hierarchy
   
   put library_ListFrontObjects (pProjectName) into frontObjects
   object_FastStripIndex scriptHierarchy, frontObjects
   if hkey_IncludeDepsInSearch() is true then object_AddBehaviors frontObjects
   
   put library_ListBackObjects (pProjectName) into backObjects
   object_FastStripIndex scriptHierarchy, backObjects
   if hkey_IncludeDepsInSearch() is true then object_AddBehaviors backObjects
   
   -- put library_ListUsedStacks (pProjectName) into usedStacks
   put project_FetchObjects ("used", pProjectName) into usedStacks
   object_FastStripIndex scriptHierarchy, usedStacks
   if hkey_IncludeDepsInSearch() is true then object_AddBehaviors usedStacks
   
   global gREVShowStacks
   if gREVShowStacks is true then
      -- add the revStacks
      -- not done yet
   end if
   
   script_AddLibrariesToHierarchy scriptHierarchy, frontObjects, usedStacks, backObjects
end hkey_AddDevelopmentHierarchy

function hkey_IncludeDepsInSearch
   global gOPN
   put gOPN ["include_DependencyBehaviors"] is not false into someBoolean
   return someBoolean
   
   put pref_GetValue ("include_DependencyBehaviors") is not false into someBoolean
   return someBoolean
end hkey_IncludeDepsInSearch

command hkey_IncludeDepsInSearch someBoolean
   global gOPN
   put someBoolean into gOPN ["include_DependencyBehaviors"]
   return someBoolean
   
   pref_SetValue "include_DependencyBehaviors", someBoolean
   return the result
end hkey_IncludeDepsInSearch

getprop handler_InHierarchy [hKey]
   put the long id of the target into tObject
   put item 1 to 2 of hKey into shortHkey
   
   put hkey_FoundArray (shortHKey, tObject) into foundArray
   put foundArray ["foundHkey"] into foundHkey
   if foundHkey is empty then return empty
   
   put item 3 of foundHkey into foundObject
   put foundArray ["startLineNum"] into startLineNum
   put foundArray ["endLineNum"] into endLineNum
   
   try
      put line startLineNum to endLineNum of the script of foundObject into foundHandler
      return foundHandler
   catch e
      return empty -- stack locked
   end try
end handler_InHierarchy

getprop hkey_InHierarchy [hKey]
   put the long id of the target into tObject
   put item 1 to 2 of hKey into shortHkey
   return hkey_FindInHierarchy (shortHKey, tObject)
   
   /*
   -- old way
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   hkey_FastFindHandlerAndKey hName, hType, hObject, foundHkey, foundHandler
   return foundHkey
   
   -- another old way
   if the number of items of shortHkey = 2 then
      put item 1 of shortHkey into handlerName
      put item 2 of shortHkey into handlerType
      put the long id of the target into scriptObject
      put hkey_Construct (handlerName, handlerType, scriptObject) into hKey
   else
      put shortHkey into hKey
   end if
   
   put script_GetEnvironmentFilter() into environmentFilter
   put the script_Hierarchy [environmentFilter] of the target into scriptHierarchy
   put hkey_SearchObjectHierarchy (hKey, scriptHierarchy) into foundHkey
   return foundHkey
   */
end hkey_InHierarchy

getprop hkey_SearchHierarchy [pProjectName]
   -- see also "getprop script_Hierarchy"
   local standAloneHierachy
   put the long id of the target into targetObject
   
   put the object_Hierarchy of targetObject into scriptHierarchy
   hkey_AddDevelopmentHierarchy scriptHierarchy, pProjectName
   return scriptHierarchy
end hkey_SearchHierarchy

-- getprop script_Hierarchy [pEnvironmentFilter]
   # old
   -- see newer "getprop hkey_SearchHierarchy"
   /*
   Creates an index of objects representing the message path for the target object
   Starts at bottom (with frontscripts), and works up through the hierarchy to the backscripts
   */
   local frontObjects, usedNames, backObjects
   put the long id of the target into targetObject
   
   put the object_Hierarchy of targetObject into scriptHierarchy
   
   if pEnvironmentFilter is empty then put script_GetEnvironmentFilter() into pEnvironmentFilter
   switch pEnvironmentFilter
      case "full"
         put the frontscripts into frontObjects
         object_AddBehaviors frontObjects
         put the backscripts into backObjects
         object_AddBehaviors frontObjects
         
         put the stacksinuse into usedNames
         put stack_NamesToObjects (usedNames) into usedStacks
         object_AddBehaviors usedStacks
         break
      case "development"
         put object_FilterRev (the frontscripts) into frontObjects
         object_AddBehaviors frontObjects
         put object_FilterRev (the backscripts) into backObjects
         object_AddBehaviors backObjects
         
         put the stacksinuse into usedNames
         filter usedNames without ("rev*")
         put stack_NamesToObjects (usedNames) into usedStacks
         object_AddBehaviors usedStacks
         break
      case "application"
         put object_FilterRev (the backscripts) into backObjects
         object_AddBehaviors backObjects
         
         put the stacksinuse into usedNames
         filter usedNames without ("rev*")
         put stack_NamesToObjects (usedNames) into usedStacks
         object_AddBehaviors usedStacks
         break
      case "stack"
         -- don't add anything
         break
   end switch
   
   script_AddLibrariesToHierarchy scriptHierarchy, frontObjects, usedStacks, backObjects
   return scriptHierarchy
end script_Hierarchy


--> Hkey | Deps | From Library
-
function library_HkeyDeps hKey, pAllcalls
   put library_HkeyCallArray (hKey, pAllcalls) into hKeyLinkArray
   put array_AllNodes (hKeyLinkArray) into hkeyDeps
   put item 1 to 2 of hKey into shortHkey
   line_Delete shortHkey, hkeyDeps
   sort hkeyDeps by item 1 of each
   return hkeyDeps
end library_HkeyDeps

function library_HkeyCallArray hKey, pAllcalls
   local hKeyLinkArray
   library_HandlerWalk hKey, empty, hKeyLinkArray, pAllcalls
   array_StripDeeperLevels hKeyLinkArray
   return hKeyLinkArray
end library_HkeyCallArray


--> Handler
-
function hkey_GetObjectHandler hKey, pNotPrivate
   put item 3 of hKey into hObject
   if exists (hObject) is false then return empty
   if pNotPrivate is true then
      put the script of hObject into someScript
      put script_ExtractHandler (hKey, someScript, pNotPrivate) into someHandler
   else
      put the script_Handler [hKey] of hObject into someHandler
   end if
   return someHandler
end hkey_GetObjectHandler

function script_ExtractHandler hKey, pSomeScript, pNotPrivate
   -- this version uses offsets to find the handler not an hArray index
   local startHandler, endHandler
   if pSomeScript is empty then
      hkey_Deconstruct hKey, handlerName, handlerType, scriptObject, handlerNum
      if exists(scriptObject) is false then return empty
      put the script of scriptObject into pSomeScript
   end if
   hkey_SetOffsets hKey, startHandler, endHandler, pSomeScript, pNotPrivate
   put the result into someHandler
   return someHandler
end script_ExtractHandler

function hkey_GetHandler hKey
   return hkey_ExtractHandlerFromObject (hKey)
   
   -- does this also get it from hierarchy???
   put item 1 to 2 of hKey into shortHKey
   put item 3 of hKey into hObject
   if exists (hObject) is false then return empty
   return the script_Handler [shortHKey] of hObject
end hkey_GetHandler


--> Handler | New
-
function hkey_ExtractHandlerFromObject hKey
   hkey_Deconstruct hKey, hName, hType, hObject, hNum 
   
   try
      put the revAvailableHandlers of hObject into handlerTable
      script_HandlerFromTableOffsets hKey, handlerTable, startLineNum, endLineNum
      if startLineNum = 0 then
         -- look for private handler?
         put "P" before item 2 of hKey
         script_HandlerFromTableOffsets hKey, handlerTable, startLineNum, endLineNum
         if startLineNum = 0 then
            return empty
         end if
      end if
      put the script of hObject into someScript
      put line startLineNum to endLineNum of someScript into foundHandler
      return foundHandler
   catch someError
      return empty -- a locked stack
   end try
end hkey_ExtractHandlerFromObject

command script_HandlerFromTableOffsets shortHkey, handlerTable, @startLineNum, @endLineNum
   if handlerTable is empty then
      put 0 into startLineNum
      put 0 into endLineNum
      return false
   end if
   
   put item 1 of shortHkey into hName
   put item 2 of shortHkey into hType
   switch char -1 of hType
      case "c"
         put "M" into char -1 of hType
         break
      case "o"
         put "M" into char -1 of hType
         break
   end switch
   
   repeat for each line someLine in handlerTable      
      put word 2 of someLine into hTableName
      if hTableName is not hName then next repeat
      
      put word 1 of someLine into hTableType
      switch
         case hTableType = hType
            put word 3 of someLine into startLineNum
            put word 4 of someLine into endLineNum
            return true
      end switch
      
      add 1 to handlerLineNum
   end repeat
   put 0 into startLineNum
   put 0 into endLineNum
   return false
end script_HandlerFromTableOffsets


--> Hkey | Hierarchy | New
-
/*
These newer handlers use the more flexible "getprop hkey_SearchHierarchy" and built in "revAvailableHandlers"

See also "put hArray_FindHkeyInHierarchy (shortCall, hObject, hArray, pProjectName) into foundCall"
These handlers will look for private handler only in the actual target,
need to check whether we should also look for private handlers in the behavior of the target.
*/

function hkey_FindInHierarchy shortHKey, tObject, pProjectName
   put hkey_FoundArray (shortHKey, tObject, pProjectName) into foundArray 
   return foundArray ["foundHkey"]
end hkey_FindInHierarchy

function hkey_FoundArray shortHKey, tObject, pProjectName
   put item 1 of shortHKey into hName
   put item 2 of shortHKey into hType
   put the hkey_SearchHierarchy [pProjectName] of tObject into searchHierarchy
   
   put the long id of tObject into tObject
   repeat with lineNum = the number of lines of searchHierarchy down to 1
      put line lineNum of searchHierarchy into hierarchyObject
      put the revAvailableHandlers of hierarchyObject into handlerTable
      
      if the long id of hierarchyObject = tObject and char 1 of hType is not "p" then -- if looking for private skip
         -- look for private handlers first (ideally should get the first version?)
         put "p" & hType into privateHype
         put hName,privateHype into privateShortKey
         script_HandlerFromTableOffsets privateShortKey, handlerTable, startLineNum, endLineNum
         if the result is true then
            put handlerTable into foundArray ["handlerTable"]
            put startLineNum into foundArray ["startLineNum"]
            put endLineNum into foundArray ["endLineNum"]
            put hkey_Construct (hName, privateHype, hierarchyObject) into foundArray ["foundHkey"]
            return foundArray
         else
            script_HandlerFromTableOffsets shortHkey, handlerTable, startLineNum, endLineNum
            if the result is true then
               put handlerTable into foundArray ["handlerTable"]
               put startLineNum into foundArray ["startLineNum"]
               put endLineNum into foundArray ["endLineNum"]
               put hkey_Construct (hName, hType, hierarchyObject) into foundArray ["foundHkey"]
               return foundArray
            end if
         end if
      else
         script_HandlerFromTableOffsets shortHkey, handlerTable, startLineNum, endLineNum
         if the result is true then
            put handlerTable into foundArray ["handlerTable"]
            put startLineNum into foundArray ["startLineNum"]
            put endLineNum into foundArray ["endLineNum"]
            put hkey_Construct (hName, hType, hierarchyObject) into foundArray ["foundHkey"]
            return foundArray
         end if
      end if
   end repeat
   return empty
end hkey_FoundArray

function hArray_FindHkeyInHierarchy shortHkey, hObject, pHarray, pProjectName
   -- see also "hkey_FindInHierarchy"
   if exists (hObject) is false then return empty
   if pHarray is an array and pProjectName is empty then put "none" into pProjectName -- assume we only want to look in a mainstack
   
   put the hkey_SearchHierarchy [pProjectName] of hObject into pSearchHierarchy
   put hArray_GetFoundHkeyArray (shortHkey, pHarray) into hkeyArray
   
   -- also look for private handlers in the first object
   if hkeyArray is not an array and char 1 of item 2 of shortHkey is not "p" then
      put "p" before char 1 of item 2 of shortHkey
      put hArray_GetFoundHkeyArray (shortHkey, pHarray) into hkeyArray
   end if
   
   -- lets get the nearest hKey in the hierarchy
   -- ususally faster to get an indexed shortHkey and do this, than crawl a long hierarchy
   set the wholematches to true
   repeat for each key foundHkey in hkeyArray
      put item 3 of foundHkey into foundObject
      if item 4 of foundHkey > 1 then next repeat -- hack for now (should not be adding repeat hKeys to hKeyArray but using first / revAvailablehandler approach
      put lineOffset (foundObject, pSearchHierarchy) into lineNum
      put foundHkey into foundArray [lineNum]
   end repeat
   put item 2 of the extents of foundArray into maxLineNum
   return foundArray [maxLineNum]
end hArray_FindHkeyInHierarchy


/*
--> Display
-
command display_UnindexedHkeyArray scriptObject, pTreeView
   put the textStack_Folder of scriptObject into mainStackFolder
   put mainstack_FetchWalkArray (mainStackFolder) into hKeyWalkArray
   put hKeyWalkArray ["external"] into externalArray
   
   put mainstack_FetchDepHkeys (mainStackFolder) into shortDepHkeys
   
   repeat for each line shortHkey in shortDepHkeys
      delete variable externalArray [shortHkey]
   end repeat
   
   put "Unindexed External Hkeys for" && scriptObject into someTitle
   if exists (pTreeView) is true then
      lock screen
      set the tree_Array [1] of pTreeView to externalArray
      set the title_Text of pTreeView to someTitle
      unlock screen
   else
      display_Array externalArray, someTitle, "Global | Hkey | Project | External | Menu", "Global | Hkey | Project | External | Line | Menu"
      put the result into pTreeView
      put the object_Hkey ["treeAction_EditHarrayObjectScript,c"] of me into hKey
      set the event_Trigger ["mouseDoubleUp"] of the tree_Field of pTreeView to hKey
      set the displayed_MainStackWalkArray of pTreeView to hKeyWalkArray
      put the main_Stack of scriptObject into mainStackObject
      set the displayed_Object of pTreeView to mainStackObject
   end if
   return pTreeView
end display_UnindexedHkeyArray

command display_ExternalHkeyArray scriptObject, pHKeyWalkArray, pTreeView
   -- component:  true
   put the main_Stack of scriptObject into mainStackObject
   
   if pHKeyWalkArray is an array then
      put pHKeyWalkArray into hKeyWalkArray
   else
      put the textStack_Folder of scriptObject into mainStackFolder
      put mainstack_FetchWalkArray (mainStackFolder) into hKeyWalkArray
   end if
   put hKeyWalkArray ["external"] into externalArray
   
   -- put keys (externalArray) into shortExternalKeys
   put "External dependencies for stack" && kwote (the short name of mainStackObject) into someTitle
   if exists (pTreeView) is true then
      put the tree_Field of pTreeView into treeField
      lock screen
      set the tree_Array [1] of treeField to externalArray
      set the title_Text of treeField to someTitle
      unlock screen
   else
      display_Array externalArray, someTitle, "Global | Hkey | Project | External | Menu", "Global | Hkey | Project | External | Line | Menu"
      put the result into treeField
      put the object_Hkey ["treeAction_EditHarrayObjectScript,c"] of me into hKey
      set the event_Trigger ["mouseDoubleUp"] of treeField to hKey
      set the displayed_MainStackWalkArray of treeField to hKeyWalkArray
      set the displayed_Object of treeField to mainStackObject
   end if
   return pTreeView
end display_ExternalHkeyArray

command display_HkeyWalkArray scriptObject, pHKeyWalkArray
   -- component:  true
   put the main_Stack of scriptObject into mainStackObject
   
   if pHKeyWalkArray is an array then
      put pHKeyWalkArray into hKeyWalkArray
   else
      put the textStack_Folder of scriptObject into mainStackFolder
      put mainstack_FetchWalkArray (mainStackFolder) into hKeyWalkArray
   end if
   
   put hKeyWalkArray ["hKeyArray"] into mainStackHkeyArray
   put hKeyWalkArray ["dontRecurse"] into skippedRecursionArray
   put hKeyWalkArray ["reindexed"] into newlyHarrayIndexed
   put hKeyWalkArray ["external"] into externalArray
   put hKeyWalkArray ["missing"] into missingArray
   
   display_Array hKeyWalkArray, ("hKeyWalkArray for" && scriptObject)
   
   if externalArray is an array then
      display_ExternalHkeyArray scriptObject, hKeyWalkArray
      
      display_ObjectHKeyArray mainStackHkeyArray, mainStackObject, "Mainstack HkeyArray", "Mainstack HkeyArray"
      put the result into treeView
      set the displayed_MainStackWalkArray of treeView to hKeyWalkArray
      set the displayed_Object of treeView to mainStackObject
   else
      put "There are no calls to external handlers from this mainstack. It is a standalone component!" into someMessage
      opn_Notify someMessage, true
   end if
   
   if missingArray is an array then
      put "Missing dependencies for stack" && kwote (the short name of mainStackObject) into someTitle
      display_Array missingArray, someTitle, "Global | Hkey | Dependency | MissingArray | Menu", "Global | Hkey | Dependency | External | Line | Menu"
      put the result into treeView
      
      put the object_Hkey ["treeAction_EditHarrayObjectScript,c"] of me into hKey
      set the event_Trigger ["mouseDoubleUp"] of the tree_Field of treeView to hKey 
      set the displayed_MainStackWalkArray of treeView to hKeyWalkArray
      set the displayed_Object of treeView to mainStackObject
   else
      put "There are no calls to missing handlers from this mainstack." into someMessage
      opn_Notify someMessage, true
   end if
end display_HkeyWalkArray

command treeAction_EditHarrayObjectScript treeField
   put the selected_Index of treeField into someLine
   put the tree_SelectedDepth of treeField into tabLevel
   
   switch
      case the number of items of someLine = 4
         put someLine into hKey
         hkey_EditFoundHandler hKey
         break
      case the number of items of someLine = 2
         put someLine into shortHkey
         put the selected_ArrayValue of treeField into subArray
         repeat for each key parentHkey in subArray
            put subArray [parentHkey] into calledExternalHkey
            switch
               case calledExternalHkey is an array
                  breakpoint
                  exit repeat
               case calledExternalHkey is empty
                  put parentHkey into hKey
                  hkey_EditFoundHandler hKey
                  exit repeat
               default
                  -- they should all be the same, so let's take this one
                  hkey_EditFoundHandler calledExternalHkey
                  exit repeat
            end switch
         end repeat
         break
      case the number of items of someLine = 1
         put the selected_Index of treeField into someObject
         if exists(someObject) then
            edit the script of someObject
         end if
      case tabLevel = 1
         break
      default
         -- put the selected_Array of treeField into selectedArray
         -- put line 1 of keys (selectedArray) into hKey
   end switch
   pass treeAction_EditHarrayObjectScript
end treeAction_EditHarrayObjectScript
*/


--> Deps | Export
-
command mainstack_ExportAsText stackObject, pHashArrayBoolean, pExportHandlers, pUseCustomFolders, pForceCreate
   put the mainstack of stackObject into mainStackName
   
   put the effective filename of stackObject into someFile
   if someFile is empty and the create_NewProjects of stackObject is true then
      breakpoint
      project_CreateNew mainStackName
      put the result into gitRootFolder
      git_InitFolder gitRootFolder
      return "git project created in:" && gitRootFolder
   else  
      dispatch "stack_CleanBeforeSave" to stackObject
      save stackObject
      put the name of stackObject into mainStackObject
      mainStack_ExportAsFiles mainStackObject, pHashArrayBoolean, pExportHandlers, pUseCustomFolders, pForceCreate
      put the result into mainStackMetaArray
      return "exported"
   end if
end mainstack_ExportAsText

command mainStack_ExportAsFiles mainStackObject, pHashArrayBoolean, pExportHandlers, pUseCustomFolders, pForceCreate 
   -- seems like mainStackObject can be any object
   if exists (mainStackObject) is false then return empty
   if char 1 to 3 of the short name of mainStackObject = "rev" then return empty -- don't index rev stack???
   
   ------ put the mainStack_MetaArray [pHashArrayBoolean] of mainStackObject into mainStackMetaArray
   put true into pDontExport
   put true into pLinkToViews
   put false into pForceIndexHandlerCalls
   put empty into pDontDiff
   put true into pDontExport -- as it is exported later in the handler?
   
   if pHashArrayBoolean is empty then
      put pref_GetValue ("add object to hArray on export") is not false into createHarray
      put pref_GetValue ("Construct hashArray on stack export") is true into pHashArrayBoolean
   else
      put pHashArrayBoolean is true into pHashArrayBoolean
      pref_SetValue "Construct hashArray on stack export", pHashArrayBoolean
      if pHashArrayBoolean is true then
         pref_SetValue "Add object to hArray on stack export", true
         put true into createHarray
      else
         put pref_GetValue ("Add object to hArray on export") is not false into createHarray
      end if
   end if
   
   if createHarray and pHashArrayBoolean then -- only give option of constructing hkeyCalls handlerHashArray if we are also indexing a basic hArray
      put the textStack_Folder of mainStackObject into mainStackFolder
      put mainstack_FetchHandlerHashArray (mainStackFolder) into handlerHashArray
      if handlerHashArray is not an array then
         put empty into hArray ["handlerHashArray"]["new"] -- forces indexing of all hKeys in a new script
      else
         delete variable handlerHashArray ["actual"]
         delete variable handlerHashArray ["new"]
         put handlerHashArray into hArray ["handlerHashArray"]
      end if
   else
      put empty into hArray -- no "handlerHashArray" indexing of hKey calls, let's recreate the rest of hArray
   end if
   
   put mainstack_ConstructMetaArray (mainStackObject, hArray, pLinkToViews, pExportHandlers, pDontDiff, pDontExport, pForceCreate) into mainStackMetaArray
   ------ end mainStack_MetaArray
   
   mainstack_AddArrayToGlobal mainStackMetaArray
   
   put mainStackMetaArray ["mainstackArray"]["manifest"] into manifestArray
   put the mainStack_Hash of mainStackObject into mainStackHash
   put manifestArray ["sha1"] into storedHash
   
   /* this is not working reliably
   if mainStackHash = storedHash and pForceCreate is not true then
      put the mainstack_WalkArray of scriptObject into mainStackHkeyWalkArray
      return mainStackHkeyWalkArray
   end if
   */
   
   -- safety check to delete any hashed handlers in old object that are not in actual object
   put mainStackMetaArray ["hArray"]["handlerHashArray"] into handlerHashArray
   put handlerHashArray ["actual"] into actualHashArray
   put handlerHashArray ["cached"] into cachedHashArray
   delete variable mainStackMetaArray ["hArray"]["handlerHashArray"]["actual"]
   delete variable mainStackMetaArray ["hArray"]["handlerHashArray"]["new"]
   intersect cachedHashArray with actualHashArray
   put cachedHashArray into mainStackMetaArray ["hArray"]["handlerHashArray"]["cached"]
   
   put mainStackMetaArray ["hArray"] into hArray
   -- delete variable hArray ["handlerHashArray"]
   put the textStack_Folder of mainStackObject into textStackFolder
   mainstack_StoreHarray hArray, textStackFolder
   
   --here we delete the object folder and re-export
   stackArray_DeleteObjectFolder textStackFolder
   put the result into objectsFolder
   
   put mainStackMetaArray ["mainStackArray"] into mainStackArray
   put mainStackArray ["objects"] into objectArray
   put mainStackArray ["manifest"] into manifestArray
   
   -- put manifestArray ["object"] into stackObject
   put manifestArray ["name"] into stackName   
   if char 1 to 3 of stackName = "rev" then return empty -- don't allow accidental export of rev stacks
   
   put objectArray ["substacks"] into substackData
   delete variable objectArray ["substacks"]
   
   put empty into subStackName
   repeat for each key objectBit in objectArray
      set the cursor to busy
      put stackArray_ConstructObjectFolder (textStackFolder, objectBit, subStackName) into objectFolder
      put objectArray [objectBit] into objectPropArray
      
      if objectBit = "stack" then
         stackArray_ExportStackFiles objectFolder, objectPropArray
         stackArray_ExportVideoClips objectFolder, objectPropArray
         stackArray_ExportAudioClips objectFolder, objectPropArray
      end if
      
      objectArray_ExportAsFiles objectPropArray, objectFolder, pUseCustomFolders, pExportHandlers, pDontExport  -- folder_CreateNested objectFolder
   end repeat
   
   repeat for each key subStackName in substackData
      if char 1 to 3 of subStackName = "rev" then return empty -- don't allow accidental export of rev stacks
      put substackData [subStackName] into subStackArray
      
      put subStackArray ["objects"] into objectArray
      put mainStackMetaArray ["mainstackArray"]["manifest"]["substacks"][subStackName] into subManifestArray
      put subManifestArray into manifestArray ["substacks"][subStackName]
      
      repeat for each key objectBit in objectArray
         set the cursor to busy
         put stackArray_ConstructObjectFolder (textStackFolder, objectBit, subStackName) into objectFolder
         put objectArray [objectBit] into objectPropArray
         
         if objectBit = "stack" then
            stackArray_ExportStackFiles objectFolder, objectPropArray
            stackArray_ExportVideoClips objectFolder, objectPropArray
            stackArray_ExportAudioClips objectFolder, objectPropArray
         end if
         
         objectArray_ExportAsFiles objectPropArray, objectFolder, pUseCustomFolders, pExportHandlers, pDontExport  -- folder_CreateNested objectFolder
      end repeat
   end repeat
   
   mainStack_StoreManifestArray textStackFolder, manifestArray
   
   return mainStackMetaArray
end mainStack_ExportAsFiles

command mainstack_AddArrayToGlobal mainStackMetaArray
   /*
   Rescued from text export
   Better to wait till full db replacement, and / or nested mainstack structure for global gHkey_Array.
   */
   
   global gHkey_Array
   
   put mainStackMetaArray ["hArray"] into newHarray
   put gHkey_Array ["hArray"] into gHarray
   
   put newHarray ["scriptArray"] into scriptArray
   put gHarray ["scriptArray"] into gScriptArray
   union scriptArray with gScriptArray
   put scriptArray into gHarray ["scriptArray"]
   
   -- need to delete all mainstack entries for behaviorArray
   put newHarray ["behaviorArray"] into behaviorArray
   put gHarray ["behaviorArray"] into behaviorArray
   
   -- need to delete all Global Menus in mainstack other than new entries
   put newHarray ["Global Menus"] into menuArray
   put gHarray ["Global Menus"] into menuArray
   
   -- need to add all handlers in handlerArray and remove any old handlers in gHarray
   put newHarray ["handlerArray"] into handlerArray
   put gHarray ["handlerArray"] into handlerArray
   
   put newHarray ["keywordArray"] into keywordArray
   put gHarray ["keywordArray"] into keywordArray
   
   put newHarray ["objectTypeArray"] into objectTypeArray
   put gHarray ["objectTypeArray"] into objectTypeArray
   
end mainstack_AddArrayToGlobal

 
--> Harray | handlerHashArray
-
command object_UpdateHandlerHashArray scriptObject, pUpdateAll
   if pUpdateAll is false then
      hArray_TidyHandlerHashes scriptObject, true
      put the result into resultArray
      if resultArray ["isTidy"] is true then return resultArray
      put resultArray ["oldHandlerHashArray"] into objectHandlerHashArray
      put resultArray ["newHkeys"] into newHkeys
      
      put the mainstack_HandlerHashArray of scriptObject into mainStackHandlerHashArray
      repeat for each key handlerHash in objectHandlerHashArray
         delete variable mainStackHandlerHashArray ["cached"][handlerHash]
         delete variable mainStackHandlerHashArray ["new"][handlerHash]
      end repeat
      set the mainstack_HandlerHashArray of scriptObject to mainStackHandlerHashArray
   else
      set the mainstack_HandlerHashArray of scriptObject to empty
   end if
   
   -- force reindex
   mainStack_ExportAsFiles scriptObject, true, true
   put the result into mainStackMetaArray
   
   -- update
   object_CheckHandlerHashArray scriptObject
   return the result
end object_UpdateHandlerHashArray

command object_CheckHandlerHashArray scriptObject, pDontNotify
   hArray_TidyHandlerHashes scriptObject, pDontNotify
   put the result into resultArray
   put resultArray ["isTidy"] into someBoolean
   if someBoolean is true and pDontNotify is not true then
      put the mobile_Name of scriptObject into mObject
      put "There are no problems with the object_HandlerHashArray of" && mObject into someComment
      opn_Notify someComment, true
   end if
   return resultArray
end object_CheckHandlerHashArray

command hArray_TidyHandlerHashes scriptObject, pDontNotify
   -- just in case things get out of sync
   put the object_HandlerHashArray of scriptObject into objectHandlerHashArray
   -- put the script_Array of scriptObject into scriptArray -- this is broken due to 2 different formats being returned
   put the hArray_ScriptData of scriptObject into scriptData
   repeat for each key indexNum in scriptData
      put scriptData [indexNum]["hKey"] into hKey
      if hKey is empty then next repeat
      put scriptData [indexNum]["sha1"] into handlerHash
      -- put scriptArray [indexNum]["handler"] into someHandler
      -- put sha1_Hash (someHandler) into handlerHash
      
      if objectHandlerHashArray [handlerHash] is an array then
         delete variable objectHandlerHashArray [handlerHash]
      else
         put scriptData [indexNum] into newKeys [hKey]
      end if
   end repeat
   
   put true into isTidy
   
   if objectHandlerHashArray is an array then
      repeat for each key oldHash in objectHandlerHashArray
         put objectHandlerHashArray [oldHash]["hkey"] into hKeyArray
         put keys (hKeyArray) & CR after oldHkeys
      end repeat
      delete char -1 of oldHkeys
      
      if pDontNotify is not true then
         /*
         put "The following old handlers are still in the index:" into someComment
         put CR & outline_IncreaseIndent (oldHkeys, 4, space) after someComment
         opn_Notify someComment, true -- too large sometimes
         */
         
         put the mobile_Name of scriptObject into mObject
         put "Old handlers for" && kwote (mObject) into someTitle
         display_Outline oldHkeys, someTitle
      end if
      put false into isTidy
   end if
   
   put keys (newKeys) into newHkeys
   if newHkeys is not empty then
      if pDontNotify is not true then
         /*
         put "The following new handlers have been added to the index:" into someComment
         put CR & outline_IncreaseIndent (newHkeys, 4, space) after someComment
         opn_Notify someComment, true
         */
         
         put the mobile_Name of scriptObject into mObject
         put "New handlers for" && kwote (mObject) into someTitle
         display_Outline newHkeys, someTitle
      end if
      put false into isTidy
   end if
   
   put isTidy into resultArray ["isTidy"]
   put objectHandlerHashArray into resultArray ["oldHandlerHashArray"]
   put newHkeys into resultArray ["newHkeys"]
   return resultArray
end hArray_TidyHandlerHashes

function hArray_GetHashedHandler hKey, handlerHash
   put hArray_GetFoundHkeyArray (hKey) into hkeyArray
   repeat for each key hKey in hkeyArray
      if hkeyArray [hKey]["handlerHash"] = handlerHash then
         put hkeyArray [hKey]["startLineNum"] into startLineNum
         put hkeyArray [hKey]["endLineNum"] into endLineNum
         put item 3 of hKey into hObject
         put line startLineNum to endLineNum of the script of hObject into someHandler
         return someHandler
      end if
   end repeat
   return empty
end hArray_GetHashedHandler

function hArray_GetHandlerHashArray hArray
   put hArray ["handlerHashArray"] into handlerHashArray
   return handlerHashArray
end hArray_GetHandlerHashArray

command hArray_SetHandlerHashArray @hArray, handlerHashArray
   if handlerHashArray is an array then
      put handlerHashArray into hArray ["handlerHashArray"]
   else
      delete variable hArray ["handlerHashArray"]
   end if
   return hArray
end hArray_SetHandlerHashArray

command hArray_AddHandlerHash @hArray, hKey, someHandler, handlerHash, indexTime, pForceindex
   -- we could add to an hKeyArray here? But can't use hArray to find calls in hierarchy as it is in progress of being built
   
   put hArray ["handlerHashArray"]["cached"][handlerHash]["hashTime"] is not empty into alreadyIndexed
   
   -- let's get the old handler hash and delete the old entry
   put hArray_GetHandlerHash (hKey, hArray) into oldHandlerHash
   if oldHandlerHash is not handlerHash then
      delete variable hArray ["handlerHashArray"]["cached"][oldHandlerHash]
      delete variable hArray ["handlerHashArray"]["new"][oldHandlerHash]
   end if
   
   -- add hKey to list of hkeys with same handler(hash)
   put empty into hArray ["handlerHashArray"]["cached"][handlerHash]["hKey"][hKey]
   
   if alreadyIndexed is false or pForceindex is true then
      -- if new (handlerHash) entry extract calls and add to index
      put indexTime into hArray ["handlerHashArray"]["cached"][handlerHash]["hashTime"]
      
      -- now let's extract keywords and index shortHkey against each (no point doing it for non first Hkeys
      hkey_AddToKeyWordArray hArray, hKey, handlerHash
      
      -- but don't clear hkey list
      put handler_ConstructCallArray (someHandler) into metadataArray
      put metadataArray ["filteredCalls"] into shortCalls
      
      put shortCalls into hArray ["handlerHashArray"]["cached"][handlerHash]["shortCalls"]
      put metadataArray ["hkeyCalls"] into hArray ["handlerHashArray"]["cached"][handlerHash]["allShortCalls"]
      -- put handler_ExtractCalls (someHandler) into hArray ["handlerHashArray"]["cached"][handlerHash]["shortCalls"]
      
      put "Indexed" && kwote (hKey) into someComment
      if shortCalls is not empty then
         put CR & CR & "With the following calls to other handlers:" after someComment
         put CR & outline_IncreaseIndent (shortCalls, 4, space) after someComment
      end if
      opn_Notify someComment
      
      -- put someHandler into hArray ["handlerHashArray"]["cached"][handlerHash]["handler"]
   else
      -- put "Already Indexed" && kwote (hKey) into someComment
   end if
end hArray_AddHandlerHash

function hArray_ListHashHkeys hArray, pHandlerHash
   if pHandlerHash is empty then
      -- let's list all of them
      put hArray ["handlerHashArray"]["cached"] into hashArray
      repeat for each key handlerHash in hashArray
         put hashArray [handlerHash]["hKey"] into emptyHkeyArray
         put keys(emptyHkeyArray) & CR after hashedHkeys
      end repeat
      delete char -1 of hashedHkeys
      return hashedHkeys
   else
      put hArray ["handlerHashArray"]["cached"][handlerHash]["hKey"] into emptyHkeyArray
      return keys(emptyHkeyArray)
   end if
end hArray_ListHashHkeys

function hArray_ListNewHandlerHashes hArray
   put hArray ["handlerHashArray"]["new"] into hashArray
   return keys(hashArray)
end hArray_ListNewHandlerHashes

function hArray_ListNewHkeys hArray
   put hArray ["handlerHashArray"]["new"] into hashArray
   repeat for each key handlerHash in hashArray
      put hashArray [handlerHash]["hKey"] into emptyHkeyArray
      put keys(emptyHkeyArray) & CR after newHkeys
   end repeat
   delete char -1 of newHkeys
   return newHkeys
end hArray_ListNewHkeys

function sha1_Hash someData
   local hexDigest
   put sha1digest (someData) into someBinaryData
   get binarydecode ("H*", someBinaryData, hexDigest)
   return hexDigest
end sha1_Hash


--> Deps | Create Graph | hKey
-
command display_HkeyArrayGraph hkeyArray, pGraphStyle
   -- component: true
   
   if pGraphStyle is empty then put "hierarchical" into pGraphStyle
   -- overlayArray_ReconstructAndCreateFiles hKeyArray, pOverlayName, overlayFolder, pGraphStyle, dotHeaderArray, graphPropertyArray
   put overlayArray_FromLinkArray (hkeyArray) into overlayArray
   overlayArray_SetGraphProperty overlayArray, "overlay_Style", pGraphStyle
   overlayArray_CreateAndDisplayGraph overlayArray, pGraphStyle
   put the result into imageView
   return imageView
end display_HkeyArrayGraph

command hkey_CreateDependencyGraph hKey, pGraphStyle, pOverlayName
   -- direct object walk
   local dotHeaderArray, graphPropertyArray
   if pGraphStyle is empty then put "hierarchical" into pGraphStyle
   
   put library_HkeyFolder (hkey) into overlayFolder
   -- put hkey_ScriptDependencyArray (hkey) into hKeyArray
   put hkey_DependencyArrayFromObjects (hkey) into hKeyArray
   overlayArray_ReconstructAndCreateFiles hKeyArray, pOverlayName, overlayFolder, pGraphStyle, dotHeaderArray, graphPropertyArray
   put the result into overlayArray
end hkey_CreateDependencyGraph


--> Deps | Create Graph | hArray
-
command hArray_CreateDependencyGraph hKey, pGraphStyle, pOverlayName
   if pGraphStyle is empty then put "hierarchical" into pGraphStyle  
   
   put item 3 of hKey into hObject
   put the textStack_Folder of hObject into mainStackFolder
   put mainstack_FetchHarray (mainStackFolder) into hArray
   if hArray is an array then put hArray into hKeyWalkArray ["hArray"]
   
   put hkey_ConstructHarrayWalkArray (hKey, hArray, pDepObject) into hKeyWalkArray
   
   put hKeyWalkArray ["hKeyArray"] into hKeyArray
   library_CreateHkeyGraph hKey, hKeyArray, pGraphStyle, pOverlayName
   
   put the result into overlayArray
   return overlayArray
end hArray_CreateDependencyGraph

function file_Hash someFile, pUseBinary
   if there is not a file someFile then return empty
   if pUseBinary is false then
      put url ("file:" & someFile) into someData
   else
      put url ("binfile:" & someFile) into someData
   end if
   return sha1_Hash (someData)
end file_Hash


--> Mainstack | Deps | Construct
-
command mainstack_ConstructHandlerHashArray hArray, mainStackFolder
   put hArray ["scriptArray"] into objectArray
   repeat for each key rObject in objectArray
      put objectArray [rObject] into scriptObjectArray
      put scriptObjectArray ["data"]["firstHkeyArray"] into firstHkeyArray
      repeat for each key firstShortHkey in firstHkeyArray
         put firstShortHkey,rObject,1 into hKey
         
         put hArray_GetHandler (hKey, hArray) into callHandler
         put sha1_Hash (callHandler) into handlerHash
         put hArray_GetShortCalls (handlerHash, hArray) into shortCalls
         
         -- it has not been indexed lets get the handler from the global index
         -- and extract the calls from the handler
         put hArray_GetHandler (hKey) into callHandler
         put handler_ExtractCalls (callHandler) into shortCalls
         
         put hArray_GetHandler (hKey, hArray) into callHandler
         put handler_ExtractCalls (callHandler) into shortCalls
         
      end repeat
   end repeat
end mainstack_ConstructHandlerHashArray


--> Main Stack | Export | Deps
-
command object_ExportAsFiles scriptObject, pUseCustomFolders, pExportHandlers, pDontDiff, pDontExport, pForceIndexHandlerCalls
   local objectPropArray, hArray
   object_GetPropertyArrays scriptObject, objectPropArray, hArray, pExportHandlers, pDontDiff, pDontExport, pForceIndexHandlerCalls
   
   put the checkout_Folder of scriptObject into objectFolder
   objectArray_ExportAsFiles objectPropArray, objectFolder, pUseCustomFolders, pExportHandlers, pDontExport
   return objectFolder
end object_ExportAsFiles

command objectArray_ExportAsFiles objectPropArray, objectFolder, pUseCustomFolders, pExportHandlers, pDontExport
   local revPropText, someScript, objectText, objectHtml, metadataArray, customArray, someImage
   
   folder_Format objectFolder
   object_DeconstructPropertyArray objectPropArray, revPropertyArray, someScript, objectText, objectHtml, customArray, someImage
   put rev_PropertyArrayToText (revPropertyArray) into revPropText
   
   -- don't translate to native encoding for text files (keep with unix line endings on all platforms)
   if someScript is not empty then object_ExportScript objectFolder, someScript, pExportHandlers, pDontExport
   if revPropText is not empty then object_ExportRevPropText objectFolder, revPropText
   if objectText is not empty then object_ExportMetaText objectFolder, objectText
   if objectHtml is not empty then object_ExportMetaHtml objectFolder, objectHtml
   if someImage is not empty then object_ExportMetaImage objectFolder, someImage -- put someImage into url ("binfile:" & objectFolder & "image.png")  -- no idea what type of image it is (use imagedata) ???
   
   put objectPropArray ["videoclip"] into someData
   if someData is not empty then
      put someData into url ("binfile:" & objectFolder & "video")
   end if
   
   put objectPropArray ["audioclip"] into someData
   if someData is not empty then
      put someData into url ("binfile:" & objectFolder & "audioclip_object")
   end if
   
   object_ExportCustomArray objectFolder, customArray, pUseCustomFolders
   return objectFolder
end objectArray_ExportAsFiles


--> Deps | Create
-
command library_CreateStackDependencyButton pObject
   if pObject is empty then put the long id of the target into pObject
   put the stack_BehaviorButton ["Stack Handler Deps"] of pObject into libraryDepButton
   if exists (libraryDepButton) then return libraryDepButton
   
   put the main_Stack of pObject into mainStackObject
   put the uRIP ["name"] of mainStackObject into libraryName
   put libraryName && "Deps" into uripName
   behavior_CreateStackButton mainStackObject, "Stack Handler Deps", uripName, "deps"
   put the result into libraryDepButton
   return libraryDepButton
end library_CreateStackDependencyButton

command behavior_CreateStackButton someObject, bName, pUripName, pBehaviorType
   if pUripName is empty then put bName into pUripName
   if pBehaviorType is empty then put "behavior" into pBehaviorType
   
   put the stack_BehaviorButton [bName] of someObject into depBehaviorButton
   if exists (depBehaviorButton) is true then return depBehaviorButton
   
   put the defaultstack into oDefault
   --
   behavior_CreateSubStackCard someObject
   put the result into behaviorCard
   
   -- behaviorCard exists or has been created
   -- set the defaultstack to menuSubStack
   go invisible behaviorCard -- would be good to be able to create it on / in a card and not have to go???
   create button bName
   put it into createdButton
   
   put metadata_ConstructUripArray (pUripName, pBehaviorType) into uRipArray
   set the object_Metadata of createdButton to uRipArray
   return createdButton
end behavior_CreateStackButton

command behavior_CreateSubStackCard someObject
   put the menu_SubStack of someObject into menuSubStack
   switch
      case exists (menuSubStack) is false
         stack_CreateSubStack someObject, "OPN Stack Menus"
         put the result into menuSubStack
         set the name of cd 1 of menuSubStack to "Behaviors"
         return the long id of cd 1 of menuSubStack
      case there is a card "Behaviors" of menuSubStack
         return the long id of cd "Behaviors" of menuSubStack
      default
         -- stack exists but there is no named behavior card
         if word 1 to 2 of the short name of cd 1 of menuSubStack = "card id" then
            set the name of cd 1 of menuSubStack to "Behaviors"
            return the long id of cd 1 of menuSubStack
         else
            put the defaultstack into oDefault
            set the defaultstack to menuSubStack
            create card "Behaviors"
            set the defaultstack to oDefault
            return the long id of cd "Behaviors" of menuSubStack
         end if
   end switch
end behavior_CreateSubStackCard

-- function library_ConstructDefaultDepBehaviorScript libraryName, pAuthorName
   put script_GetTemplate ("Library Behavior Deps") into scriptTemplate
   if pAuthorName is empty then
      put pref_GetValue ("userName") into authorName
   else
      put pAuthorName into authorName
   end if
   put merge (scriptTemplate) into someScript
   return someScript
end library_ConstructDefaultDepBehaviorScript


--> Private
-
command hArray_FilterHkeyArray @hKeyArray, pHarray
   local alreadyDeleted
   repeat for each key hKey in hKeyArray
      if hkey_IsAuthored (hKey, pHarray) is false then
         linkArray_DeleteNode hKeyArray, hKey, alreadyDeleted
         next repeat
      end if
      put hKeyArray [hKey] into hkeyLinks
      if hkeyLinks is an array then put keys (hkeyLinks) into hkeyLinks
      
      repeat for each line hkeyLink in hkeyLinks
         if hkey_IsAuthored (hkeyLink, pHarray) is false then
            linkArray_DeleteNode hKeyArray, hkeyLink, alreadyDeleted
         end if
      end repeat
   end repeat
end hArray_FilterHkeyArray

-- command hArray_FilterHkeyArray @hKeyArray, pHarray
put keys (hKeyArray) into filteredKeys
hArray_FilterHkeys filteredKeys, pHarray
repeat for each line hKey in filteredKeys
   put hKeyArray [hKey] into hkeyLinks
   if hkeyLinks is an array then put keys (hkeyLinks) into hkeyLinks
   hArray_FilterHkeys hkeyLinks, pHarray
   put hkeyLinks into filteredHkeyArray [hKey]
end repeat
put filteredHkeyArray into hKeyArray
end hArray_FilterHkeyArray

command hArray_FilterHkeys @hKeys, pHarray
   repeat for each line hKey in hKeys
      if hkey_IsAuthored (hKey, pHarray) is true then
         put hKey & CR after goodHkeys
      end if
   end repeat
   delete char -1 of goodHkeys
   put goodHkeys into hKeys
end hArray_FilterHkeys

function hkey_TestFetchDeps hKey, someHandler, pSkipHkeyComponents, pSkipHkeyProps
   put hkey_TestShortDeps (hKey, someHandler, pSkipHkeyComponents, pSkipHkeyProps) into shortBoolean
   if shortBoolean = false then return false
   
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   if exists (hObject) is false then return shortBoolean  
   
   if pSkipHkeyComponents is empty then put pref_GetValue ("skip_HkeyComponents") is not false into pSkipHkeyComponents
   if pSkipHkeyProps is empty then put pref_GetValue ("skip_HkeyProps") is not false into pSkipHkeyProps
   
   put the uRIP ["Type"] of hObject into objectType
   put the object_MetaData ["component"] of hObject into scriptIsComponent
   switch
      case hkey_IsDataGridCall (hKey, hName, hType, hObject) is true
         return false
      case scriptIsComponent is true and pSkipHkeyComponents is true
         return false
      case objectType is not "library" and hType is among the items of "g,s" and pSkipHkeyProps is true
         return false
      default
         return true
   end switch
end hkey_TestFetchDeps

function hkey_TestShortDeps hKey, someHandler, pSkipHkeyComponents, pSkipHkeyProps
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   if pSkipHkeyComponents is empty then put pref_GetValue ("skip_HkeyComponents") is not false into pSkipHkeyComponents
   if pSkipHkeyProps is empty then put pref_GetValue ("skip_HkeyProps") is not false into pSkipHkeyProps
   
   switch
      case hName = "_"
         return false
      case hName is among the items of "menu_Target,menu_CheckTarget,menu_Version" and hType = "g"
         return false
      case hName is "menu_Init" and hType = "c"
         return false
      case char 1 of hName = "u" and hType is among the items of "g,s"
         return false
      case "_" is not in hName and hType is among the items of "g,s"
         return false
      case char 1 to 3 of hName = "rev" and char 4 of hName is not "_"
         return false
      case handler_IsComponent (someHandler) and pSkipHkeyComponents is true
         return false
      default
         return true
   end switch
end hkey_TestShortDeps

command stackArray_DeleteObjectFolder textStackFolder
   folder_Format textStackFolder
   
   -- hack
   set the itemdelimiter to "/"
   put textStackFolder & "objects/" into oldObjectsFolder
   revDeleteFolder oldObjectsFolder -- lets start again, but keep metadata and other folders
   -- end hack
   
   put textStackFolder & "data/" into dataFolder
   put dataFolder & "objects/" into objectsFolder
   
   revDeleteFolder dataFolder -- lets start again, but keep metadata and other folders
end stackArray_DeleteObjectFolder

-- private command stackArray_ExportAsFiles stackArray, textStackFolder, pUseCustomFolders, pExportHandlers, pDontExport
   /*
   This deletes the objects folder, but leaves the metadata folder untouched.
   It would be good to tidy the metadata folder so that any deleted objects also had their metadata folders removed?
   */
   
   stackArray_DeleteObjectFolder textStackFolder
   put the result into objectsFolder
   
   put stackArray ["objects"] into objectArray
   put stackArray ["manifest"] into manifestArray
   put manifestArray ["name"] into stackName
   put manifestArray ["object"] into stackObject
   
   mainStack_StoreManifestArray textStackFolder, manifestArray
   
   repeat for each key objectBit in objectArray
      if objectBit = "substacks" then next repeat
      
      put stackArray_ConstructObjectFolder (textStackFolder, objectBit, subStackName) into objectFolder
      
      if objectBit = "stack" then
         stackArray_ExportStackFiles objectFolder, stackArray
         stackArray_ExportVideoClips objectFolder, stackArray
         stackArray_ExportAudioClips objectFolder, stackArray
      end if
      
      folder_CreateNested objectFolder
      put objectArray [objectBit] into objectPropArray
      
      objectArray_ExportAsFiles objectPropArray, objectFolder, pUseCustomFolders, pExportHandlers, pDontExport
   end repeat
end stackArray_ExportAsFiles

command stackArray_ExportStackFiles objectFolder, objectPropArray
   put objectPropArray ["stackfiles"] into stackFileTable
   if stackFileTable is empty then return empty
   
   put meta_StackArrayFile (objectFolder, false) into someFile
   put stackFileTable into url ("binfile:" & someFile)
end stackArray_ExportStackFiles

command stackArray_ExportVideoClips objectFolder, objectPropArray

end stackArray_ExportVideoClips

command stackArray_ExportAudioClips objectFolder, objectPropArray
   
end stackArray_ExportAudioClips


--> Old
-
function hkey_SearchObjectHierarchy hKey, scriptHierarchy
   -- was "script_SearchObjectHierarchy"
   /*
   This script finds where a handler call is in the hierarchy.
   It returns multiple objects if the handler is passed and also intercepted further up the hierarchy.
   
   It does not use any caching at the moment but looks directly at the script.
   */
   hkey_Deconstruct hKey, handlerName, handlerType, scriptObject, handlerNum
   hkey_FindHandlerInHierarchy handlerName, handlerType, scriptObject, scriptHierarchy, foundHKey, callHandler
   
   hkey_Deconstruct foundHKey, foundHandlerName, foundHandlerType, foundScriptObject, handlerNum
   return foundScriptObject
end hkey_SearchObjectHierarchy

function hkey_FindAndExtractCalls hKey, pEnvironmentFilter, pHkeyArray, pScriptObject
   -- maybe should use "hkey_SearchHierarchy" instead of "script_Hierarchy"???
   local foundHKey, foundHandler
   
   hkey_Deconstruct hKey, hName, hType, hObject, hNum
   if pScriptObject is empty then put hObject into pScriptObject
   
   put the hkey_SearchHierarchy [pEnvironmentFilter] of pScriptObject into scriptHierarchy
   hkey_FindHandlerInHierarchy hName, hType, pScriptObject, scriptHierarchy, foundHKey, foundHandler
   hkey_Deconstruct foundHkey, foundName, foundType, foundObject, foundNum
   
   -- save unecessary indexing work
   if foundHkey is among the lines of keys (pHkeyArray) then
      opn_Notify merge ("Already indexed '[[hkey]]'. Lets not index it again please :)")
      return empty
   end if
   
   -- get handler calls
   -- this should be short calls for simplicity and speed of recursion
   
   put library_FetchHandler (foundHkey) into storedHandler
   if foundHandler = storedHandler and pForceSearch is not true then
      -- already stored, faster to fetch stored calls
      put hkey_GetCalls (foundHkey) into handlerCalls
   else
      put the hkey_SearchHierarchy [pEnvironmentFilter] of foundObject into foundHierarchy
      put script_ParseHandlerForCalls (foundHandler, foundHierarchy, foundObject) into handlerCalls
      hkey_StoreCallsAndHandler foundHkey, foundHandler, handlerCalls
   end if
   return handlerCalls
end hkey_FindAndExtractCalls

command hkey_FindHandlerInHierarchy handlerName, handlerType, scriptObject, scriptHierarchy, @hKey, @foundHandler, pNotPrivate
   -- this is the step that takes time
   -- looks for first hKey in scriptHierarchy
   local startHandler, endHandler
   
   if exists (scriptObject) is false then
      put scriptObject && "does not exist! Exiting..." into someMessage
      opn_Notify someMessage, true
      return empty
   end if
   
   --  and from now on search rest of hierarchy only for public handler
   put handlerName,handlerType into shortHKey
   repeat with lineNum = (the number of lines of scriptHierarchy) down to 1
      set the cursor to busy
      put empty into hKey
      put line lineNum of scriptHierarchy into someObject
      
      if exists (someObject) is false then
         put someObject && "does not exist! Skipping..." into someMessage
         opn_Notify someMessage, true
         next repeat
      end if
      
      if the long id of someObject = the long id of scriptObject then
         -- as it is the script object where the shortHkey is called from 
         -- allow private handlers
         
         if the hArray_IsCurrent of someObject is true then
            if the hArray_HkeyPresent [hKey] of someObject is true then
               put hkey_Construct (handlerName, handlerType, someObject) into hKey
               put library_FetchHandler (hKey) into foundHandler
               return hKey
            end if         
         else
            -- not properly indexed, so do it manually.
            try
               put the script of someObject into someScript
               
               -- don't think we need to have this option 
               -- change to look for either. Forget whether handlerType = "p"
               if char 1 of handlerType = "p" then
                  put handlerType into privateHandlerType
                  
                  put handlerName,privateHandlerType into shortHKey
                  hkey_SetOffsets shortHKey, startHandler, endHandler, someScript, pNotPrivate
                  put the result into foundHandler
                  
                  if foundHandler is not empty then
                     -- found private handler => construct and return hKey
                     put hkey_Construct (handlerName, privateHandlerType, someObject) into hKey
                     return hKey
                  else
                     -- no point in searching hierarchy for private handlers
                     return empty
                  end if
               else
                  -- should find first regardless of public or private
                  -- for now finds private first
                  put "p" & handlerType into privateHandlerType
                  
                  put handlerName,privateHandlerType into shortHKey
                  hkey_SetOffsets shortHKey, startHandler, endHandler, someScript, pNotPrivate
                  put the result into foundHandler
                  
                  if foundHandler is not empty then
                     -- found private handler => construct and return hKey
                     put hkey_Construct (handlerName, privateHandlerType, someObject) into hKey
                     return hKey
                  else
                     -- lets try public
                     put handlerName,handlerType into shortHKey
                     hkey_SetOffsets shortHKey, startHandler, endHandler, someScript, pNotPrivate
                     put the result into foundHandler
                     if foundHandler is not empty then
                        -- found public handler => construct and return hKey
                        put hkey_Construct (handlerName, handlerType, someObject) into hKey
                        return hKey
                     end if
                  end if
                  
               end if
            catch someError
               -- locked
               put "Did not search" && the mobile_Name of someObject && "as it's script is locked!" into someMessage
               opn_Notify someMessage, true
               next repeat
            end try
         end if
      else
         -- not the script object where the shortHkey is called from
         -- don't allow private handlers
         
         if the hArray_IsCurrent of someObject is true then
            if the hArray_PublicHkeyPresent [hKey] of someObject is true then
               put hkey_Construct (handlerName, handlerType, someObject) into hKey
               put library_FetchHandler (hKey) into foundHandler
               return hKey
            end if         
         else
            try
               put the script of someObject into someScript
            catch someError
               -- locked
               next repeat
            end try
            
            hkey_SetOffsets shortHKey, startHandler, endHandler, someScript, pNotPrivate
            put the result into foundHandler
            if foundHandler is empty then next repeat
            if script_HandlerContainsPass (handlerName, foundHandler) is false then
               -- found => construct and return hKey
               put hkey_Construct (handlerName, handlerType, someObject) into hKey
               return hKey
            end if
         end if
         
      end if
   end repeat
   
   -- gone through every object in hierarchy
   return empty
end hkey_FindHandlerInHierarchy


--> Deps | Private
-
private command _AddVideoClips subStackName, mainStackName, @stackArray
   put the number of videoClips of stack subStackName of stack mainStackName into maxVclipNum
   repeat with clipNum = 1 to maxVclipNum
      put the object_PropertyArray of videoClip clipNum of stack subStackName of stack mainStackName into objectPropertyArray
      put clipNum into objectPropertyArray ["rev"]["layer"]
      put the abbreviated id of videoClip clipNum of stack subStackName of stack mainStackName into aObject
      put object_ConvertAbbreviated (aObject) into aFolderName
      put objectPropertyArray into stackArray ["objects"][aFolderName]
      
      if maxVclipNum = 1 then
         put "videoclip" into clipArrayKey
      else
         put "videoclip[" & clipNum & "]" into clipArrayKey
      end if
      put aObject into stackArray ["manifest"]["videoclips"][clipArrayKey]["object"]
      put objectPropertyArray ["rev"]["name"] into stackArray ["manifest"]["videoclips"][clipArrayKey]["name"]
   end repeat
end _AddVideoClips

private command _AddAudioClips subStackName, mainStackName, @stackArray
   put the number of audioClips of stack subStackName of stack mainStackName into maxAclipNum
   repeat with clipNum = 1 to maxAclipNum
      put the object_PropertyArray of audioClip clipNum of stack subStackName of stack mainStackName into objectPropertyArray
      put clipNum into objectPropertyArray ["rev"]["layer"]
      put the abbreviated id of audioClip clipNum of stack subStackName of stack mainStackName into aObject
      put object_ConvertAbbreviated (aObject) into aFolderName
      put objectPropertyArray into stackArray ["objects"][aFolderName]
      
      if maxAclipNum = 1 then
         put "audioclip" into clipArrayKey
      else
         put "audioclip[" & clipNum & "]" into clipArrayKey
      end if
      put aObject into stackArray ["manifest"]["audioclips"][clipArrayKey]["object"]
      put objectPropertyArray ["rev"]["name"] into stackArray ["manifest"]["audioclips"][clipArrayKey]["name"]
   end repeat
end _AddAudioClips
